<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Gaze Tracking Canvas - Cortical Visual Impairment Assessment</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="Visual Target Management System for Cortical Visual Impairment Functional Assessment by Niall Brown - ECVC">
    <meta name="keywords" content="gaze tracking, visual assessment, cortical visual impairment, CVI, eye tracking, visual targets, functional vision">
    <meta name="author" content="Niall Brown - Early Childhood Vision Consultant">
    <meta name="theme-color" content="#0891b2">
    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#0891b2">
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="apple-mobile-web-app-title" content="Gaze Tracker">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-TileColor" content="#1e293b">
    <meta name="msapplication-config" content="browserconfig.xml">
    <meta name="msapplication-tap-highlight" content="no">
    
    <!-- Manifest and Icons -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="gazetracker.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-72x72.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
    <link rel="mask-icon" href="gazetracker.svg" color="#3b82f6">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="./dist/output.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Andika:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link rel="preload" as="font" href="./fonts/Luciole_webfonts/Luciole-Regular/Luciole-Regular.woff2" type="font/woff2" crossorigin>
    <style>
        /* Luciole webfonts (self-hosted) */
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-Regular/Luciole-Regular.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-Regular/Luciole-Regular.woff') format('woff');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-Italic/Luciole-Italic.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-Italic/Luciole-Italic.woff') format('woff');
            font-weight: 400;
            font-style: italic;
            font-display: swap;
        }
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-Bold/Luciole-Bold.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-Bold/Luciole-Bold.woff') format('woff');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-BoldItalic/Luciole-BoldItalic.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-BoldItalic/Luciole-BoldItalic.woff') format('woff');
            font-weight: 700;
            font-style: italic;
            font-display: swap;
        }
        :root {
            /* Clinical Professional Color System (Light Mode) */
            --md-primary: #0891b2;
            --md-primary-hover: #0e7490;
            --md-on-primary: #ffffff;
            --md-primary-container: #ecfeff;
            --md-on-primary-container: #164e63;
            --md-surface: #ffffff;
            --md-surface-variant: #f1f5f9;
            --md-surface-tertiary: #e2e8f0;
            --md-on-surface: #0f172a;
            --md-on-surface-variant: #334155;
            /* Darken muted text in light mode for WCAG 4.5:1 on white */
            --md-on-surface-muted: #475569;
            --md-outline: #94a3b8;
            --md-outline-variant: #cbd5e1;
            --md-error: #dc2626;
            --md-on-error: #ffffff;
            --md-warning: #f59e0b;
            --md-on-warning: #ffffff;
            /* Professional Elevations (subtle) */
            --md-elev-0: none;
            --md-elev-1: 0 1px 3px rgba(15, 23, 42, 0.08);
            --md-elev-2: 0 2px 6px rgba(15, 23, 42, 0.10);
            --md-elev-3: 0 4px 12px rgba(15, 23, 42, 0.12);

            /* Scrollbar (light) */
            --scrollbar-track: var(--md-surface-variant);
            --scrollbar-thumb: #cbd5e1;
            --scrollbar-thumb-hover: var(--md-primary);
            /* Focus ring for a11y */
            --md-focus: #22d3ee;
        }
        
        .dark {
            /* Clinical Professional Color System (Dark Mode) */
            --md-primary: #06b6d4;
            --md-primary-hover: #22d3ee;
            /* Use white text on primary for strong contrast */
            --md-on-primary: #ffffff;
            --md-primary-container: #164e63;
            --md-on-primary-container: #cffafe;
            --md-surface: #0f172a;
            --md-surface-variant: #1e293b;
            --md-surface-tertiary: #334155;
            --md-on-surface: #f1f5f9;
            --md-on-surface-variant: #cbd5e1;
            --md-on-surface-muted: #94a3b8;
            --md-outline: #475569;
            --md-outline-variant: #334155;
            --md-error: #ef4444;
            --md-on-error: #ffffff;
            --md-warning: #fbbf24;
            --md-on-warning: #0f172a;
            /* Professional Elevations (dark) */
            --md-elev-0: none;
            --md-elev-1: 0 1px 3px rgba(0, 0, 0, 0.20);
            --md-elev-2: 0 2px 6px rgba(0, 0, 0, 0.25);
            --md-elev-3: 0 4px 12px rgba(0, 0, 0, 0.30);

            /* Scrollbar (dark) */
            --scrollbar-track: var(--md-surface-variant);
            --scrollbar-thumb: var(--md-on-surface-muted);
            --scrollbar-thumb-hover: var(--md-primary);
        }
        
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            font-feature-settings: 'cv01', 'cv03', 'cv04', 'cv11';
            overscroll-behavior: none;
            background: var(--md-surface);
            background-image: none;
            color: var(--md-on-surface);
            /* Limit transitions to avoid paint glitches on text */
            transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1), color 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 100vh;
            color-scheme: light dark;
        }
        .drawer {
            /* Avoid transitioning "all" to prevent text paint issues during open/close */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.4s cubic-bezier(0.4, 0, 0.2, 1), border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed;
            top: 0;
            height: 100vh;
            max-height: 100vh;
            background: var(--md-surface);
            box-shadow: var(--md-elev-2);
            z-index: 50;
            border: 1px solid var(--md-outline-variant);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .drawer::before { content: none; }
        
        .drawer-toggle {
            position: fixed;
            top: 20%;
            transform: translateY(-50%);
            background: var(--md-surface-variant);
            border: 1px solid var(--md-outline);
            padding: 12px;
            z-index: 60; /* above .drawer (50) */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 0;
            transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            box-shadow: var(--md-elev-2);
            border-radius: 12px;
        }
        .drawer-right {
            right: 0;
            transform: translateX(100%);
        }
        
        .drawer-right.open {
            transform: translateX(0);
        }
        /* Re-add left drawer closed/open states */
        .drawer-left {
            left: 0;
            transform: translateX(-100%);
            border-right: 1px solid var(--md-outline);
        }
        .drawer-left.open {
            transform: translateX(0);
        }
        
        
    .drawer-toggle::before { content: none; }
        
        .drawer-toggle:hover {
            background: var(--md-surface-variant);
            box-shadow: var(--md-elev-3);
            transform: translateY(-50%) scale(1.03);
        }
        
        .drawer-toggle-left {
            left: 0;
            border-top-right-radius: 12px;
            border-bottom-right-radius: 12px;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-left: none;
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .drawer-left.open ~ .drawer-toggle-left {
            left: 320px;
        }
        
        .drawer-toggle-right {
            right: 0;
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .drawer-right.open ~ .drawer-toggle-right {
            right: 320px;
        }
        
        .drawer-toggle svg {
            color: var(--md-primary);
            transition: color 0.2s ease;
            width: 20px;
            height: 20px;
        }
        
        .drawer-toggle:hover svg {
            color: var(--md-primary-hover);
        }
        /* Tool button base - Professional clinical style */
        .tool-button {
            transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
            background: var(--md-surface);
            border: 1px solid var(--md-outline);
            border-radius: 6px;
            color: var(--md-on-surface-variant);
            box-shadow: none;
            position: relative;
            font-weight: 500;
            font-size: 13px;
        }

    .tool-button::before { content: none; }

        .tool-button:hover {
            background: var(--md-surface-variant);
            color: var(--md-on-surface);
            border-color: var(--md-primary);
        }

        .tool-button.active {
            background: var(--md-primary);
            color: var(--md-on-primary);
            font-weight: 600;
            border-color: var(--md-primary);
        }

        .tool-button svg {
            transition: none;
        }

        /* Accessible focus states */
        .tool-button:focus-visible,
        .upload-button:focus-visible,
        .delete-button:focus-visible,
        .layer-item-button:focus-visible,
        .preset-color-bg:focus-visible {
            outline: 2px solid var(--md-focus);
            outline-offset: 2px;
        }
        /* Move accordion focus outline to the outer card to avoid double border */
        .accordion-button:focus-visible { outline: none; }
        .section-header:focus-within {
            outline: 2px solid var(--md-primary);
            outline-offset: 2px;
            border-radius: 12px;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: var(--md-surface);
            background-image: none;
            overflow: hidden;
        }
        
    #canvas-container::before { content: none; }
        
        canvas {
            display: block;
            border-radius: 0;
            position: relative;
            z-index: 2;
            touch-action: none; /* Enable custom gesture handling for touch */
        }
        
        .context-menu {
            display: none;
            position: absolute;
            background: var(--md-surface);
            border: 1px solid var(--md-outline-variant);
            border-radius: 12px;
            box-shadow: var(--md-elev-3);
            z-index: 1000;
            overflow: hidden;
            min-width: 200px;
        }
        
    .context-menu::before { content: none; }
        
        .context-menu button {
            display: block;
            width: 100%;
            padding: 14px 18px;
            text-align: left;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--md-on-surface);
            transition: background 0.2s ease, color 0.2s ease;
            position: relative;
            z-index: 1;
        }
        
        .context-menu button:hover {
            background: var(--md-surface-variant);
            color: var(--md-on-surface);
        }
        
        .context-menu button.danger {
            color: var(--danger-color);
        }
        
        .context-menu button.danger:hover {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger-color);
        }
        
        .context-menu hr {
            margin: 8px 0;
            border: none;
            border-top: 1px solid var(--md-outline-variant);
            opacity: 0.6;
        }
        .accordion-button {
            font-weight: 600;
            font-size: 14px;
            line-height: 1.5;
            color: var(--md-on-surface);
            border-radius: inherit;
            transition: color 0.2s ease;
            background: transparent;
            backdrop-filter: none;
            border: none;
            letter-spacing: 0;
            box-shadow: none;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
        }

    .accordion-button:hover { color: var(--md-primary); }
        
        .accordion-button svg.arrow-icon {
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--md-primary);
            filter: none;
            transform: rotate(0deg); /* Expanded (default open) points down */
        }

        /* Collapsed state: rotate to point right */
        .accordion-button[aria-expanded="false"] svg.arrow-icon {
            transform: rotate(-90deg);
        }
        
        .section-header {
            background: var(--md-surface-variant);
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid var(--md-outline);
            box-shadow: none;
            transition: border-color 0.2s ease, background 0.2s ease;
            contain: paint;
            background-clip: padding-box;
        }

    .section-header:hover { box-shadow: none; transform: none; border-color: var(--md-primary); background: var(--md-surface-variant); }

        .section-content {
            background: var(--md-surface);
            border-radius: 6px;
            border: 1px solid var(--md-outline-variant);
            box-shadow: none;
            transition: border-color 0.2s ease, background 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
    .section-content::before { content: none; }
        .layer-item-button {
            background: transparent;
            border: none;
            padding: 4px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--md-on-surface-variant);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 11px;
            position: relative;
            overflow: hidden;
            min-width: 26px;
            height: 26px;
            flex-shrink: 0;
        }
        
    .layer-item-button::before { content: none; }
        
        .layer-item-button:hover {
            background: var(--md-surface-variant);
            color: var(--md-primary);
            transform: scale(1.06);
            box-shadow: var(--md-elev-1);
        }
        
        .layer-item-button:hover::before {
            opacity: 0.1;
        }
        
        .layer-item-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .layer-item-button.layer-visibility-hidden {
            opacity: 0.3;
            color: var(--md-on-surface-muted);
        }
        
        .layer-item-button.layer-visibility-hidden:hover {
            opacity: 0.6;
            color: var(--md-on-surface-variant);
        }
        
        .layer-item {
            background: var(--md-surface);
            border: 1px solid var(--md-outline-variant);
            border-radius: 8px;
            transition: border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--md-elev-1);
            position: relative;
            overflow: hidden;
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        
        #layer-list {
            overflow-x: hidden !important;
            width: 100%;
        }
        
    .layer-item::before { content: none; }
        
        .layer-item:hover {
            box-shadow: var(--md-elev-2);
            border-color: var(--md-primary);
        }
        
        .layer-item.selected {
            background: var(--md-surface-variant);
            border-color: var(--md-primary);
            box-shadow: var(--md-elev-1);
        }
        
        .upload-button {
            background: var(--md-surface);
            color: var(--md-on-surface);
            border: 1px solid var(--md-outline);
            border-radius: 6px;
            padding: 10px 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s ease, border-color 0.15s ease;
            box-shadow: none;
            font-size: 13px;
            text-transform: none;
            letter-spacing: 0;
        }

    .upload-button::before { content: none; }

    .upload-button:hover {
        background: var(--md-surface-variant);
        border-color: var(--md-primary);
    }

        .delete-button {
            background: var(--md-surface);
            color: var(--md-error);
            border: 1px solid var(--md-outline);
            border-radius: 6px;
            padding: 10px 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
        }
    .delete-button::before { content: none; }
        .delete-button:hover {
            background: var(--md-error);
            color: var(--md-on-error);
            border-color: var(--md-error);
        }
        .delete-button.inactive {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--md-surface);
            color: var(--md-on-surface-muted);
            border-color: var(--md-outline-variant);
        }
        .delete-button.inactive:hover {
            background: var(--md-surface);
            color: var(--md-on-surface-muted);
            border-color: var(--md-outline-variant);
        }
        
        .preset-color {
            border-radius: 6px;
            border: 2px solid var(--md-outline);
            cursor: pointer;
            transition: border-color 0.15s ease;
            box-shadow: none;
        }

    .preset-color::before { content: none; }

        .preset-color:hover {
            border-color: var(--md-primary);
        }

    .preset-color:hover::before { content: none; }

        .preset-color-bg {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 2px solid var(--md-outline);
            cursor: pointer;
            transition: border-color 0.15s ease, transform 0.15s ease;
            box-shadow: none;
            margin: 4px;
        }

        /* Ensure parent rows allow wrapping with consistent gap */
        .preset-row, .neutral-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            justify-content: flex-start;
        }

        .preset-color-bg.selected {
            border-color: var(--md-primary);
            border-width: 3px;
            transform: scale(1.05);
        }

        .preset-color-bg:hover {
            border-color: var(--md-primary);
        }

        /* Grid Button Styles */
        .grid-button {
            position: relative;
            transition: all 0.2s ease;
            /* Ensure consistent spacing between preview and number */
            gap: 6px;
        }
        
        .grid-button.selected {
            border-color: var(--md-primary) !important;
            background-color: var(--md-primary-container) !important;
            box-shadow: 0 0 0 2px var(--md-primary), var(--md-elev-2);
            transform: scale(1.02);
        }

        .grid-button:hover:not(.selected) {
            border-color: var(--md-primary);
            background-color: var(--md-surface-variant);
            transform: translateY(-1px);
        }

        .grid-button:active {
            transform: scale(0.98);
        }
        
        .grid-preview div {
            background: var(--md-on-surface-variant) !important;
            border-radius: 2px;
        }
        
        .grid-button.selected .grid-preview div {
            background: var(--md-on-surface) !important;
        }

        /* High contrast user preference support */
        @media (prefers-contrast: more) {
            .section-header, .section-content, .upload-button, .tool-button, .delete-button, .grid-button {
                border-color: var(--md-on-surface) !important;
            }
            .grid-button.selected { box-shadow: 0 0 0 2px var(--md-on-surface) !important; }
        }

        /* Windows High Contrast Mode */
        @media (forced-colors: active) {
            .upload-button, .tool-button, .delete-button, .grid-button, .section-header, .section-content {
                border: 1px solid CanvasText;
                background: Canvas;
                color: CanvasText;
            }
            .grid-button.selected { outline: 2px solid Highlight; }
        }
        
        /* Grid overlay visuals */
        @keyframes gridPulse {
            0% { transform: scale(0.9); opacity: .7; }
            70% { transform: scale(1.15); opacity: .2; }
            100% { transform: scale(1.25); opacity: 0; }
        }
        .grid-legend {
            position: absolute;
            right: 10px;
            top: 10px;
            font-size: 11px;
            color: var(--md-on-surface);
            /* Fallback then modern mix for subtle translucent panel */
            background: var(--md-surface-variant);
            background: color-mix(in oklab, var(--md-surface) 85%, transparent);
            padding: 6px 10px;
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            box-shadow: var(--md-elev-1);
            backdrop-filter: blur(6px);
        }

        /* Link colors with accessible contrast */
        a { color: var(--md-primary); text-underline-offset: 2px; }
        a:hover { color: var(--md-primary-hover); }
        
        .form-input {
            border: 1px solid var(--md-outline);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 400;
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            background: var(--md-surface);
            color: var(--md-on-surface);
            box-shadow: none;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--md-primary);
            box-shadow: 0 0 0 2px rgba(8, 145, 178, 0.15);
        }

        .form-input::placeholder {
            color: var(--md-on-surface-muted);
            font-weight: 400;
        }

        .form-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--md-on-surface);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        /* Enhanced select dropdown styling */
        select.form-input {
            background: var(--md-surface) !important;
            color: var(--md-on-surface) !important;
            cursor: pointer !important;
            border: 1px solid var(--md-outline) !important;
            border-radius: 4px !important;
            padding: 8px 32px 8px 12px !important;
            font-size: 13px !important;
            line-height: 1.4 !important;
            transition: border-color 0.15s ease !important;

            /* Remove all native appearances */
            appearance: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;

            /* Custom arrow */
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
            background-position: right 8px center !important;
            background-repeat: no-repeat !important;
            background-size: 16px 12px !important;
        }
        
        /* Specific fix for animation select */
        #animation-select {
            background: var(--md-surface) !important;
            color: var(--md-on-surface) !important;
            cursor: pointer !important;
            border: 1px solid var(--md-outline) !important;
            border-radius: 8px !important;
            padding: 12px 40px 12px 16px !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
            transition: border-color 0.15s ease !important;
            position: relative !important;
            
            /* Remove all native appearances */
            appearance: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            
            /* Single custom arrow only */
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
            background-position: right 12px center !important;
            background-repeat: no-repeat !important;
            background-size: 16px 12px !important;
        }
        
        /* Remove any pseudo-elements that might be adding arrows */
        #animation-select::before,
        #animation-select::after {
            display: none !important;
            content: none !important;
        }
        
        .dark select.form-input {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
        }
        
        /* Completely remove all native dropdown arrows */
        select.form-input::-ms-expand {
            display: none !important;
        }
        
        select.form-input::-webkit-inner-spin-button,
        select.form-input::-webkit-outer-spin-button {
            display: none !important;
            -webkit-appearance: none !important;
        }
        
        /* Firefox specific fixes */
        @-moz-document url-prefix() {
            select.form-input {
                text-indent: 0.01px !important;
                text-overflow: '' !important;
            }
        }
        
        select.form-input option {
            background: var(--md-surface) !important;
            color: var(--md-on-surface) !important;
            padding: 8px 12px !important;
            border: none !important;
        }
        
        .form-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--md-on-surface-variant);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .media-item {
            background: var(--md-surface);
            border: 1px solid var(--md-outline-variant);
            border-radius: 12px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            box-shadow: var(--md-elev-1);
            overflow: hidden;
            aspect-ratio: 1;
            position: relative;
        }
        
    .media-item::before { content: none; }
        
        .media-item:hover {
            border-color: var(--md-primary);
            box-shadow: var(--md-elev-3);
            transform: scale(1.02);
        }

        .media-item .remove-media-btn {
            position:absolute;
            top:4px;
            right:4px;
            width:22px;
            height:22px;
            background:rgba(220,53,69,0.9);
            border:none;
            color:#fff;
            font-weight:700;
            font-size:12px;
            line-height:1;
            border-radius:50%;
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            opacity:0;
            transition:opacity .2s ease, transform .2s ease, background .2s ease;
            z-index:5;
        }
        .media-item:hover .remove-media-btn,
        .media-item:focus-within .remove-media-btn {
            opacity:1;
        }
        .media-item .remove-media-btn:hover {
            background:rgba(200,40,55,1);
            transform:scale(1.08);
        }
        
        .media-item img {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 2;
        }
        
        .media-item:hover img {
            transform: scale(1.1) rotate(1deg);
        }
        /* Always keep properties panel rendered; internal states manage visibility */
        #properties-panel-content {
            display: block;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-active {
            background: var(--success-color);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        
        .status-inactive {
            background: var(--md-on-surface-muted);
        }
        
        .status-drawer-closed {
            background: var(--md-on-surface-muted);
            box-shadow: 0 0 0 2px rgba(156, 163, 175, 0.2);
        }
        
        .professional-badge {
            display: inline-flex;
            align-items: center;
            background: var(--md-primary);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .drawer-header {
            background: var(--md-surface-variant);
            border-bottom: 2px solid var(--md-primary);
            padding: 12px;
            margin: -12px -12px 16px -12px;
            border-radius: 0;
            /* Isolate layer to prevent text pop-in due to parent transitions */
            contain: paint;
            will-change: auto;
        }
        
        .drawer-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--md-on-surface);
            margin: 0;
            /* Avoid opacity/visibility animation on titles */
            transition: color 0.2s ease;
            backface-visibility: hidden;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
        }
        
        .drawer-subtitle {
            font-size: 11px;
            color: var(--md-on-surface-variant);
            margin: 2px 0 0 0;
        }
        
        .drawer-author {
            font-size: 10px;
            color: var(--md-on-surface-muted);
            margin: 2px 0 0 0;
            font-weight: 500;
        }
        
        /* Scrollbar styling (theme-aware, Material flat) */
        .drawer,
        .drawer * {
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
            scrollbar-width: thin;
        }
        .drawer::-webkit-scrollbar,
        .drawer *::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .drawer::-webkit-scrollbar-track,
        .drawer *::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 10px;
        }
        .drawer::-webkit-scrollbar-thumb,
        .drawer *::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 10px;
            border: 1px solid var(--md-outline-variant);
        }
        .drawer::-webkit-scrollbar-thumb:hover,
        .drawer *::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }
        
        /* Animation for elements */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .animate-fade-in {
            animation: fadeInUp 0.3s ease-out;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .drawer {
                width: 280px;
            }
            
            .drawer-toggle {
                padding: 10px;
            }
        }
        
        /* Splash Screen - Enhanced Modern Design */
        #splash-screen-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(16, 185, 129, 0.1)), rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px) saturate(1.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #splash-screen-overlay.fade-out { opacity: 0; pointer-events: none; transform: scale(0.95); }
        #splash-screen {
            width: min(420px, 85vw);
            max-width: 420px;
            background: linear-gradient(145deg, var(--md-surface), var(--md-surface-variant));
            border: 1px solid var(--md-outline-variant);
            border-radius: 24px;
            padding: 36px 32px 32px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 8px 32px rgba(59, 130, 246, 0.15), var(--md-elev-3);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: splashIn 0.8s cubic-bezier(.4,0,.2,1);
        }
        #splash-screen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.03) 0%, transparent 70%);
            animation: glow 4s ease-in-out infinite alternate;
        }
        #splash-screen .logo {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            filter: drop-shadow(0 4px 12px rgba(59, 130, 246, 0.2));
            animation: logoFloat 3s ease-in-out infinite;
        }
        #splash-screen .title {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--md-on-surface);
            margin-bottom: 6px;
            letter-spacing: -0.02em;
            line-height: 1.2;
            background: linear-gradient(135deg, var(--md-on-surface), var(--md-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        #splash-screen .subtitle {
            font-size: 0.95rem;
            color: var(--md-on-surface-variant);
            margin-bottom: 3px;
            font-weight: 500;
            letter-spacing: 0.02em;
        }
        #splash-screen .author {
            font-size: 0.75rem;
            color: var(--md-on-surface-muted);
            margin-bottom: 24px;
            font-weight: 400;
            letter-spacing: 0.01em;
        }
        #splash-screen .start-btn {
            background: linear-gradient(135deg, var(--md-primary), var(--md-primary-hover));
            color: var(--md-on-primary);
            border: none;
            border-radius: 999px;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: .4px;
            padding: 12px 28px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3), 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all .3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        #splash-screen .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        #splash-screen .start-btn:hover::before {
            left: 100%;
        }
        #splash-screen .start-btn:focus-visible { 
            outline: 3px solid var(--md-primary); 
            outline-offset: 4px; 
        }
        #splash-screen .start-btn:hover { 
            background: linear-gradient(135deg, var(--md-primary-hover), var(--md-primary));
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 32px rgba(59, 130, 246, 0.4), 0 6px 16px rgba(0, 0, 0, 0.2);
        }
        #splash-screen .start-btn:active { 
            transform: translateY(0) scale(0.98); 
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3), 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        #splash-screen .about-btn {
            background: transparent;
            color: var(--md-on-surface-variant);
            border: 1px solid var(--md-outline);
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 500;
            letter-spacing: .2px;
            padding: 10px 20px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: all .25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        #splash-screen .about-btn:hover {
            background: var(--md-surface-variant);
            color: var(--md-on-surface);
            border-color: var(--md-outline-variant);
            transform: translateY(-1px);
        }
        #splash-screen .about-btn:active {
            transform: translateY(0);
        }
        @keyframes splashIn { 
            from { 
                transform: translateY(32px) scale(.92); 
                opacity: 0;
                filter: blur(4px);
            } 
            to { 
                transform: translateY(0) scale(1); 
                opacity: 1;
                filter: blur(0);
            } 
        }
        @keyframes glow {
            from { opacity: 0.3; }
            to { opacity: 0.7; }
        }
        @keyframes logoFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        /* Export Info Dialog */
        #export-info-dialog-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
        }
        #export-info-dialog-overlay.show {
            display: flex;
            opacity: 1;
        }
        #export-info-dialog {
            width: min(520px, 92vw);
            max-width: 520px;
            max-height: 85vh;
            background: var(--md-surface);
            border: 1px solid var(--md-outline-variant);
            border-radius: 20px;
            box-shadow: 0 24px 64px rgba(0, 0, 0, 0.4), var(--md-elev-3);
            overflow: hidden;
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #export-info-dialog-overlay.show #export-info-dialog {
            transform: scale(1) translateY(0);
        }
        #export-info-dialog-header {
            padding: 24px 28px 20px;
            border-bottom: 1px solid var(--md-outline-variant);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(145deg, var(--md-surface), var(--md-surface-variant));
        }
        #export-info-dialog-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--md-on-surface);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        #export-info-dialog-close {
            background: transparent;
            border: none;
            color: var(--md-on-surface-variant);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        #export-info-dialog-close:hover {
            background: var(--md-surface-variant);
            color: var(--md-on-surface);
        }
        #export-info-dialog-content {
            padding: 28px;
            overflow-y: auto;
            max-height: calc(85vh - 100px);
        }
        .export-info-section {
            text-align: center;
        }
        .export-info-image {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 16px;
            margin: 0 auto 24px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--md-outline-variant);
        }
        .export-info-description {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--md-on-surface-variant);
            margin: 0;
            text-align: left;
            padding: 20px 24px;
            background: var(--md-surface-variant);
            border-radius: 12px;
            border: 1px solid var(--md-outline-variant);
        }
        
    #splash-screen::before { content: none; }
        
    #splash-screen.fade-out { opacity: 0; }
        
        #splash-screen .logo {
            width: 80px;
            height: 80px;
            margin-bottom: 24px;
            filter: none;
            position: relative;
            z-index: 2;
            animation: gentlePulse 2s ease-in-out infinite;
        }
        
        #splash-screen .title {
            color: var(--md-on-surface);
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            text-align: center;
            position: relative;
            z-index: 2;
            letter-spacing: -0.5px;
        }
        
        #splash-screen .subtitle {
            color: var(--md-on-surface-variant);
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            margin-bottom: 16px;
            position: relative;
            z-index: 2;
        }
        
        #splash-screen .author {
            color: var(--md-on-surface-muted);
            font-size: 13px;
            text-align: center;
            font-weight: 500;
            padding: 8px 20px;
            background: var(--md-surface-variant);
            border-radius: 20px;
            border: 1px solid var(--md-outline-variant);
            position: relative;
            z-index: 2;
        }
        
        @keyframes gentlePulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.02); 
                opacity: 0.95; 
            }
        }
        
        @keyframes pulse {
            0%, 100% { 
                transform: scale(1) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.08) rotate(2deg); 
                opacity: 0.9; 
            }
        }
        
        @keyframes float {
            0%, 100% { 
                transform: translate(0, 0) rotate(0deg); 
            }
            33% { 
                transform: translate(30px, -30px) rotate(1deg); 
            }
            66% { 
                transform: translate(-20px, 20px) rotate(-1deg); 
            }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .app-logo {
            width: 48px;
            height: 48px;
            margin-right: 16px;
            flex-shrink: 0;
        }
        
        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--md-surface);
            border: 1px solid var(--md-outline-variant);
            border-radius: 12px;
            padding: 24px;
            box-shadow: var(--md-elev-3);
            z-index: 10000;
            min-width: 300px;
            text-align: center;
            color: var(--md-on-surface);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--md-surface-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--md-primary);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            color: var(--md-on-surface);
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .progress-detail {
            color: var(--md-on-surface-variant);
            font-size: 12px;
        }
        
        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 24px 12px;
            color: var(--md-on-surface-muted);
        }
        
        .empty-state svg {
            margin: 0 auto 12px;
            opacity: 0.6;
        }
        
        .empty-state .title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--md-on-surface-variant);
        }
        
        .empty-state .subtitle {
            font-size: 12px;
            line-height: 1.4;
        }
        
    /* Media Grid Improvements: unified styling now defined earlier; duplicate removed */
        
        
        
        /* Animation Trigger Panel */
        .animation-trigger-btn {
            background: var(--md-surface-variant);
            border: 1px solid var(--md-outline-variant);
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: .5px;
            color: var(--md-on-surface-muted);
            cursor: pointer;
            transition: background .18s ease, transform .18s ease, opacity .25s ease;
            display: inline-flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 18px; /* slimmer */
            position: relative;
            box-shadow: none;
            opacity: 0.6; /* subtle */
        }
        
        .animation-trigger-btn:hover {
            background: var(--md-surface-tertiary);
            opacity: 0.55;
            transform: translateY(-1px);
        }
        
        .animation-trigger-btn:active {
            transform: translateY(0);
        }
        
        .animation-trigger-btn.triggering {
            background: rgba(56,189,248,0.3);
            color: var(--md-on-surface-variant);
            opacity: 0.7;
            transform: scale(1.05);
        }
        
        .animation-trigger-btn .key-indicator {
            background: rgba(148,163,184,0.25);
            color: var(--md-on-surface-variant);
            border-radius: 2px;
            padding: 0 2px;
            width: auto;
            height: 14px;
            font-size: 9px;
            font-weight: 600;
            line-height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(148,163,184,0.35);
            margin-right: 2px;
        }
        
        .animation-trigger-btn .animation-icon {
            font-size: 8px;
            line-height: 1;
            color: var(--md-on-surface-muted);
            margin-left: 1px;
        }
        
        .animation-trigger-btn.triggering .animation-icon {
            color: var(--md-on-surface-variant);
        }
        
        .animation-trigger-btn .object-name { /* hide for low profile */
            display: none;
        }
        
        .animation-trigger-btn.gentle-shake .animation-icon {
            animation: gentle-shake 0.5s ease-in-out;
        }
        
        .animation-trigger-btn.pendum .animation-icon {
            animation: pendum 0.5s ease-in-out;
        }
        
        .animation-trigger-btn.circular .animation-icon {
            animation: circular 0.5s ease-in-out;
        }
        
        /* Animation Keyframes */
        @keyframes gentle-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        
        @keyframes pendum {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-6deg); }
            75% { transform: rotate(6deg); }
        }
        
        @keyframes circular {
            0% { transform: rotate(0deg) translateX(2px) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(2px) rotate(-360deg); }
        }
        
        /* Object Animations */
        .canvas-object-shake {
            animation: object-shake var(--animation-duration, 1s) ease-in-out;
        }
        
        .canvas-object-pendum {
            animation: object-pendum var(--animation-duration, 1s) ease-in-out;
        }
        
        .canvas-object-circular {
            animation: object-circular var(--animation-duration, 1s) ease-in-out;
        }
        
        @keyframes object-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(calc(-1px * var(--animation-intensity, 5))); }
            75% { transform: translateX(calc(1px * var(--animation-intensity, 5))); }
        }
        
        @keyframes object-pendum {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(calc(-1.5deg * var(--animation-intensity, 5))); }
            75% { transform: rotate(calc(1.5deg * var(--animation-intensity, 5))); }
        }
        
        @keyframes object-circular {
            0% { transform: rotate(0deg) translateX(calc(1px * var(--animation-intensity, 5))) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(calc(1px * var(--animation-intensity, 5))) rotate(-360deg); }
        }
    /* About links */
    .about-link { color: #93c5fd; text-decoration: underline; text-underline-offset: 2px; }
    /* Text style toggle buttons */
    .btn-toggle { display: inline-flex; align-items: center; justify-content: center; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(148,163,184,0.25); background: rgba(255,255,255,0.04); color: #e2e8f0; font-weight: 600; min-width: 36px; }
    .btn-toggle:hover { background: rgba(255,255,255,0.08); }
    .btn-toggle.active { background: rgba(59,130,246,0.15); border-color: rgba(59,130,246,0.45); color: #bfdbfe; }

    /* Auto-load toggle switches */
    .auto-load-toggle {
        background: var(--md-outline);
    }
    .auto-load-toggle::after {
        background: var(--md-surface);
    }
    .auto-load-toggle input:checked + div {
        background: var(--md-primary);
    }

    /* Animation type buttons */
    .animation-type-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 12px 10px;
        border: 1px solid rgba(148,163,184,0.25);
        border-radius: 10px;
        background: rgba(255,255,255,0.04);
        color: #e2e8f0;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    .animation-type-btn:hover {
        background: rgba(255,255,255,0.08);
        border-color: rgba(148,163,184,0.4);
    }
    .animation-type-btn.active {
        background: var(--md-primary);
        border-color: var(--md-primary);
        color: white;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    .animation-type-btn.active .anim-label {
        color: white;
        font-weight: 600;
    }
    .animation-type-btn.active .anim-preview {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(79, 70, 229, 0.15));
        border-color: rgba(129, 140, 248, 0.4);
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.1), 0 2px 8px rgba(79, 70, 229, 0.2);
    }
    
    /* Enhanced preview visuals */
    .anim-preview { position: relative; width: 56px; height: 36px; border-radius: 10px; background: linear-gradient(135deg, rgba(148,163,184,0.08), rgba(100,116,139,0.12)); overflow: hidden; border: 1px solid rgba(255,255,255,0.08); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: inset 0 1px 0 rgba(255,255,255,0.05); }
    .animation-type-btn:hover .anim-preview { background: linear-gradient(135deg, rgba(148,163,184,0.15), rgba(100,116,139,0.18)); transform: scale(1.05); }
    .anim-label { font-size: 12px; color: #94a3b8; transition: all 0.2s; font-weight: 500; }
    
    /* Static "No Motion" preview */
    .preview-none .no-motion-icon {
        position: absolute; top: 50%; left: 50%;
        width: 16px; height: 16px;
        border: 2px solid var(--md-on-surface-variant);
        border-radius: 3px;
        transform: translate(-50%, -50%);
        background: transparent;
    }

    /* Follow Path SVG - ensure good contrast in both light and dark modes */
    .preview-none svg {
        color: var(--md-on-surface);
        opacity: 0.7;
    }
    .animation-type-btn.active .preview-none svg {
        color: white;
        opacity: 1;
    }

    /* Wiggle: Simple left-right shake */
    .preview-wiggle .dot {
        width: 10px; height: 10px;
        background: var(--md-on-surface-variant);
        border-radius: 50%;
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        animation: preview-wiggle 0.6s ease-in-out infinite;
    }
    @keyframes preview-wiggle {
        0%, 100% { transform: translate(-50%, -50%); }
        50% { transform: translate(calc(-50% - 8px), -50%); }
    }

    /* Pendum: Pivot swing from top */
    .preview-pendum .arm {
        position: absolute; top: 6px; left: 50%;
        width: 1px; height: 24px;
        transform-origin: top center;
        animation: preview-pendum 1.2s ease-in-out infinite;
    }
    .preview-pendum .rod {
        position: absolute; top: 0; left: -0.5px;
        width: 1px; height: 18px;
        background: var(--md-on-surface-variant);
        border-radius: 0.5px;
    }
    .preview-pendum .bob {
        position: absolute; bottom: 0; left: -5px;
        width: 10px; height: 10px;
        background: var(--md-on-surface-variant);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    @keyframes preview-pendum {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(-15deg); }
        75% { transform: rotate(15deg); }
    }

    /* Circular: Simple circular orbit */
    .preview-circular .bob {
        position: absolute; top: 50%; left: 50%;
        width: 10px; height: 10px;
        background: var(--md-on-surface-variant);
        border-radius: 50%;
        transform-origin: -12px 0px;
        animation: preview-circle 1.5s linear infinite;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    @keyframes preview-circle {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Remove duplicated legacy previews */
    .wiggle-preview, .sway-preview, .circle-preview { animation: none; }
    @keyframes wiggle-preview {}
    @keyframes sway-preview {}
    @keyframes circle-preview {}
    </style>
</head>
<body class="overflow-hidden">

    <!-- Splash Screen -->
    <div id="splash-screen-overlay">
        <div id="splash-screen">
            <img src="gazetracker.svg" alt="Gaze Tracker Logo" class="logo">
            <h1 class="title">Gaze Tracking Canvas</h1>
            <p class="subtitle">Visual Target Management System</p>
            <p class="author">by Niall Brown - Early Childhood Vision Consultant (ECVC)</p>
            <div class="flex gap-3 mt-4">
                <button id="splash-close-btn" class="start-btn" type="button" aria-label="Start using the application">
                    <span>Start</span>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"></path><path d="M12 5l7 7-7 7"></path></svg>
                </button>
                <button id="about-btn" class="about-btn" type="button" aria-label="About and licensing information">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>
                    <span>About & Licensing</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Export Info Dialog -->
    <div id="export-info-dialog-overlay">
        <div id="export-info-dialog">
            <div id="export-info-dialog-header">
                <div id="export-info-dialog-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="16" x2="12" y2="12"/>
                        <circle cx="12" cy="8" r="0.5" fill="currentColor"/>
                    </svg>
                    Export Information
                </div>
                <button id="export-info-dialog-close" onclick="hideExportInfoDialog()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div id="export-info-dialog-content">
                <div class="export-info-section">
                    <img src="complexitypicture.png" alt="Complexity Scene Example" class="export-info-image">
                    <p class="export-info-description">
                        This tool allows you to create and export complex visual scenes for 2D image assessment. Combine various visual targets, backgrounds, and foregrounds to create scenes for 2D image assessment.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="relative w-screen h-screen">
        <!-- Canvas Area -->
        <main id="canvas-container" class="w-full h-full">
            <canvas id="main-canvas"></canvas>
        </main>

        <!-- Left Controls Drawer -->
        <aside id="controls-drawer" class="drawer drawer-left w-80 overflow-y-auto">
            <div class="flex-1 overflow-y-auto p-3">
                <div class="drawer-header">
                    <div class="flex items-center">
                        <img src="gazetracker.svg" alt="Gaze Tracker Logo" class="app-logo">
                        <div class="flex-1">
                            <div class="flex items-center justify-between">
                                <h2 class="drawer-title">Gaze Tracking Canvas</h2>
                            </div>
                            <p class="drawer-subtitle">Visual Target Management</p>
                            <p class="drawer-author">by Niall Brown - ECVC</p>
                        </div>
                    </div>
                </div>
                
                <!-- Professional Header Bar -->
                <div class="mb-4" style="background: var(--md-surface-variant); border: 1px solid var(--md-outline); border-radius: 6px; padding: 16px;">
                    <div class="flex items-center justify-between">
                        <div style="flex: 1;">
                            <h3 style="color: var(--md-primary); font-size: 13px; font-weight: 600; letter-spacing: 0.5px; margin: 0; text-transform: uppercase;">App Appearance</h3>
                            <p style="color: var(--md-on-surface-muted); font-size: 11px; margin: 4px 0 0 0; font-weight: 400;">Theme & Display Settings</p>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; margin-left: 16px;">
                            <button id="theme-toggle" class="p-2 rounded transition-colors" aria-label="Toggle theme" style="color: var(--md-on-surface-variant); background: transparent; border: none; cursor: pointer;">
                                <svg id="theme-light-icon" class="h-4 w-4 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                                </svg>
                                <svg id="theme-dark-icon" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                                </svg>
                            </button>
                            <button id="fullscreen-toggle" class="p-2 rounded transition-colors" aria-label="Toggle fullscreen" style="color: var(--md-on-surface-variant); background: transparent; border: none; cursor: pointer;">
                                <svg id="fullscreen-enter-icon" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                                </svg>
                                <svg id="fullscreen-exit-icon" class="h-4 w-4 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>

                <div id="left-panel-accordion" class="space-y-2">
                <!-- Mode Toggle -->
                <div class="p-4 border-b-2" style="border-color: var(--md-outline); background: var(--md-surface-container);">
                    <!-- Current Mode Display -->
                    <div class="mb-3">
                        <p class="text-xs font-semibold uppercase tracking-wide text-center mb-2" style="color: var(--md-on-surface-variant);">You are in</p>
                        <div id="mode-description" class="text-center px-4 py-3 rounded-lg" style="background: #1976d2; border: 3px solid #1976d2;">
                            <p id="current-mode-text" class="text-base font-bold" style="color: white;">
                                <span class="flex items-center justify-center space-x-2">
                                    <svg id="current-mode-icon-edit" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                    </svg>
                                    <svg id="current-mode-icon-play" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    <span id="current-mode-name">EDIT MODE</span>
                                </span>
                            </p>
                            <p id="current-mode-description" class="text-xs mt-1" style="color: rgba(255,255,255,0.9);">Create and modify targets</p>
                        </div>
                    </div>

                    <!-- Switch Mode Button -->
                    <button id="mode-toggle-btn" class="w-full py-6 px-5 rounded-xl font-bold text-base transition-all shadow-lg hover:shadow-xl" style="background: #4caf50; color: white; border: 2px solid #4caf50;">
                        <span class="flex flex-col items-center justify-center space-y-1">
                            <span class="text-xs opacity-80">Switch to</span>
                            <span class="flex items-center justify-center space-x-2">
                                <svg id="switch-icon-play" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <svg id="switch-icon-edit" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                                <span id="mode-toggle-text" class="text-base">PLAY MODE</span>
                            </span>
                        </span>
                    </button>
                </div>

                <!-- Drawing Tools Panel -->
                <div class="section-header">
                    <button class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                        <span class="flex items-center space-x-2">
                            <svg class="w-4 h-4" style="color: var(--md-primary);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                            </svg>
                            <span>Drawing Tools</span>
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div id="edit-mode-tools" class="accordion-content section-content p-3">
                    <label class="text-xs font-medium uppercase tracking-wide mb-3 block" style="color: var(--md-on-surface-muted);">Tools</label>
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        <button id="select-tool" class="tool-button active flex items-center justify-center space-x-2 p-3 rounded-md" title="Select Tool (V)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path></svg>
                            <span class="font-medium">Select</span>
                        </button>
                        <button id="text-tool" class="tool-button flex items-center justify-center space-x-2 p-3 rounded-md" title="Add Text">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 12a4 4 0 0 0 0-8H6v8"></path><path d="M15 20a4 4 0 0 0 0-8H6v8Z"></path></svg>
                            <span class="font-medium">Text</span>
                        </button>
                    </div>
                    <label class="text-xs font-medium uppercase tracking-wide mb-3 mt-4 block" style="color: var(--md-on-surface-muted);">Shapes</label>
                    <div id="shape-tools" class="grid grid-cols-3 gap-2">
                        <button id="rect-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Rectangle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="4" y="6" width="16" height="12" rx="2"/>
                            </svg>
                        </button>
                        <button id="square-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Square">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="6" y="6" width="12" height="12" rx="2"/>
                            </svg>
                        </button>
                        <button id="circle-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Circle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="8"/>
                            </svg>
                        </button>
                        <button id="triangle-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Triangle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 4 L20 18 L4 18 Z" stroke-linejoin="round"/>
                            </svg>
                        </button>
                        <button id="star-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Star">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" stroke-linejoin="round"/>
                            </svg>
                        </button>
                        <button id="octagon-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Octagon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M7.86 2h8.28l5.86 5.86v8.28l-5.86 5.86H7.86L2 16.14V7.86L7.86 2z" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <!-- Object Properties -->
                <div class="section-header">
                    <button id="properties-accordion-button" class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                        <span class="flex items-center space-x-2">
                            <svg class="w-4 h-4" style="color: var(--md-primary);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path>
                            </svg>
                            <span>Object Properties</span>
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div id="properties-panel-content" class="accordion-content section-content p-3">
                    <!-- Text Properties -->
                    <div id="text-properties" class="hidden space-y-4">
                        <!-- Text Content Section -->
                        <div class="space-y-3">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Text Content</h3>
                            <div>
                                <label for="text-content-input" class="form-label block mb-2">Content</label>
                                <textarea id="text-content-input" rows="3" class="form-input w-full resize-none"></textarea>
                            </div>
                        </div>

                        <!-- Text Appearance Section -->
                        <div class="space-y-3 pt-4 mt-4" style="border-top: 1px solid var(--md-outline-variant);">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Appearance</h3>
                            <div>
                                <label for="text-color-input" class="form-label block mb-2">Color</label>
                                <input type="color" id="text-color-input" class="form-input w-full h-10 cursor-pointer">
                            </div>
                            <div>
                                <label for="text-font-select" class="form-label block mb-2">Font</label>
                                <select id="text-font-select" class="form-input w-full">
                                    <option value="luciole">Luciole (Low Vision)</option>
                                    <option value="atkinson">Atkinson Hyperlegible (Low Vision)</option>
                                    <option value="andika">Andika (Printed 'a')</option>
                                    <option value="serif">Noto Serif (Serif)</option>
                                    <option value="inter">Inter</option>
                                    <option value="system">System UI</option>
                                </select>
                                <div class="text-xs text-slate-400 mt-1">Printed 'a' example: <span style="font-family: Andika, Inter, system-ui, sans-serif; font-size: 1.1em;">a</span></div>
                            </div>
                            <div>
                                <label class="form-label block mb-2">Style</label>
                                <div class="flex gap-2">
                                    <button id="text-bold-toggle" type="button" class="btn-toggle" title="Bold" aria-pressed="false"><span style="font-weight:700">B</span></button>
                                    <button id="text-italic-toggle" type="button" class="btn-toggle" title="Italic" aria-pressed="false"><span style="font-style:italic">I</span></button>
                                </div>
                            </div>
                            <div>
                                <label for="text-size-input" class="form-label block mb-2">Size</label>
                                <input type="range" id="text-size-input" min="10" max="200" class="w-full">
                            </div>
                        </div>
                    </div>

                    <!-- Shape Properties -->
                    <div id="shape-properties" class="hidden space-y-4">
                        <div class="space-y-3">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Shape Color</h3>
                            <input type="color" id="shape-color-input" class="form-input w-full h-10 cursor-pointer">
                        </div>
                    </div>

                    <!-- Image Properties -->
                    <div id="image-properties" class="hidden space-y-4">
                        <div class="space-y-3">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Flip Image</h3>
                            <div class="flex space-x-2">
                                <button id="flip-horizontal-btn" class="upload-button flex-1 py-2 px-3 text-sm" aria-label="Flip horizontally">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path>
                                    </svg>
                                    Horizontal
                                </button>
                                <button id="flip-vertical-btn" class="upload-button flex-1 py-2 px-3 text-sm" aria-label="Flip vertically">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                                    </svg>
                                    Vertical
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Transform Properties (for all objects) -->
                    <div id="transform-properties" class="hidden space-y-4">
                        <div class="space-y-3 pt-4 mt-4" style="border-top: 1px solid var(--md-outline-variant);">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Rotate Target</h3>
                            <div class="flex space-x-2">
                                <button id="rotate-90-btn" class="upload-button w-full py-2 px-3 text-sm" title="Rotate selected object 90 degrees clockwise">
                                    Rotate 90
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Speech Properties (for all objects) -->
                    <div id="speech-properties" class="hidden space-y-4">
                        <div class="space-y-3 pt-4 mt-4" style="border-top: 1px solid var(--md-outline-variant);">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Speak Target Name</h3>
                            <div class="space-y-2">
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="radio" name="speech-mode" value="none" class="form-radio" checked>
                                    <span class="text-sm">Do not read</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="radio" name="speech-mode" value="default" class="form-radio">
                                    <span class="text-sm">Read default name</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="radio" name="speech-mode" value="custom" class="form-radio">
                                    <span class="text-sm">Custom text</span>
                                </label>
                            </div>
                            <div id="custom-speech-input-container" class="mt-3 hidden">
                                <label for="custom-speech-text" class="form-label block mb-2">Custom Speech Text</label>
                                <input type="text" id="custom-speech-text" class="form-input w-full" placeholder="Enter text to speak...">
                            </div>
                            <p class="text-xs mb-0" style="color: var(--md-on-surface-variant);">
                                <strong>Note:</strong> Speech only works in Play Mode when targets are clicked.
                            </p>
                        </div>
                    </div>

                    <!-- Animation Properties -->
                    <div id="animation-properties" class="space-y-4 hidden">
                        <div class="space-y-3 pt-4 mt-4" style="border-top: 1px solid var(--md-outline-variant);">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Animate Target</h3>
                            <label class="form-label block mb-2">Motion Type</label>
                            <div id="animation-buttons" class="grid grid-cols-2 gap-2">
                                <button type="button" class="animation-type-btn" data-animation="" aria-label="No animation - object stays still">
                                    <div class="anim-preview preview-none">
                                        <div class="no-motion-icon"></div>
                                    </div>
                                    <span class="anim-label">No Motion</span>
                                </button>
                                <button type="button" class="animation-type-btn" data-animation="gentle-shake" aria-label="Wiggle animation - gentle shaking motion">
                                    <div class="anim-preview preview-wiggle">
                                        <div class="dot"></div>
                                    </div>
                                    <span class="anim-label">Wiggle</span>
                                </button>
                                <button type="button" class="animation-type-btn" data-animation="pendum" aria-label="Sway animation - pendulum swinging motion">
                                    <div class="anim-preview preview-pendum">
                                        <div class="arm">
                                            <div class="rod"></div>
                                            <div class="bob"></div>
                                        </div>
                                    </div>
                                    <span class="anim-label">Sway</span>
                                </button>
                                <button type="button" class="animation-type-btn" data-animation="circular" aria-label="Circular animation - object moves in a circle">
                                    <div class="anim-preview preview-circular">
                                        <div class="bob"></div>
                                    </div>
                                    <span class="anim-label">Circle</span>
                                </button>
                                <button type="button" class="animation-type-btn" data-animation="path" aria-label="Follow a custom path">
                                    <div class="anim-preview preview-none">
                                        <svg width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M3 12 Q 9 6, 12 12 T 21 12" stroke-dasharray="none"/>
                                            <circle cx="3" cy="12" r="2" fill="currentColor"/>
                                            <circle cx="21" cy="12" r="2" fill="currentColor"/>
                                        </svg>
                                    </div>
                                    <span class="anim-label">Follow Path</span>
                                </button>
                            </div>
                        </div>
                        <div id="animation-settings" class="hidden space-y-3 pt-4 mt-4" style="border-top: 1px solid var(--md-outline-variant);">
                            <h3 class="text-xs font-semibold uppercase tracking-wide mb-3" style="color: var(--md-primary);">Motion Settings</h3>
                            
                            <!-- Standard Animation Controls (hidden when path is selected) -->
                            <div id="standard-animation-controls">
                                <div>
                                    <label for="animation-cycles" class="form-label block mb-2 flex items-center justify-between">
                                        <span>Number of Cycles</span>
                                        <span id="cycles-value" class="text-[11px] text-slate-400">5 cycles</span>
                                    </label>
                                    <input type="range" id="animation-cycles" min="1" max="20" step="1" value="5" class="w-full" aria-label="Number of animation cycles">
                                    <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>1 cycle</span>
                                        <span>20 cycles</span>
                                    </div>
                                </div>
                                <div class="mt-3">
                                    <label for="animation-intensity" class="form-label block mb-2 flex items-center justify-between">
                                        <span>Movement Size</span>
                                        <span id="intensity-value" class="text-[11px] text-slate-400">Medium</span>
                                    </label>
                                    <input type="range" id="animation-intensity" min="1" max="10" value="5" class="w-full" aria-label="Movement size">
                                    <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>Small</span>
                                        <span>Large</span>
                                    </div>
                                </div>
                                <div class="mt-3">
                                    <label for="animation-duration" class="form-label block mb-2 flex items-center justify-between">
                                        <span>Cycle Speed</span>
                                        <span id="duration-value" class="text-[11px] text-slate-400">Medium</span>
                                    </label>
                                    <input type="range" id="animation-duration" min="0.5" max="3" step="0.1" value="1" class="w-full" aria-label="Animation cycle speed">
                                    <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>Fast</span>
                                        <span>Slow</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Path Animation Controls (shown when path is selected) -->
                            <div id="path-animation-controls" class="hidden">
                                <!-- Path Animation Mode -->
                                <div>
                                    <label class="form-label block mb-2">Animation Mode</label>
                                    <div class="space-y-2">
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="radio" name="path-mode" value="to-end" class="cursor-pointer" checked>
                                            <span class="text-sm" style="color: var(--md-on-surface);">Play once</span>
                                        </label>
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="radio" name="path-mode" value="loop" class="cursor-pointer">
                                            <span class="text-sm" style="color: var(--md-on-surface);">Loop continuously</span>
                                        </label>
                                        <label class="flex items-center gap-2 cursor-pointer">
                                            <input type="radio" name="path-mode" value="pingpong" class="cursor-pointer">
                                            <span class="text-sm" style="color: var(--md-on-surface);">Ping-pong (back and forth)</span>
                                        </label>
                                    </div>
                                </div>

                                <div class="mt-3">
                                    <label for="path-speed-main" class="form-label block mb-2 flex items-center justify-between">
                                        <span>Animation Speed</span>
                                        <span id="path-speed-value-main" class="text-[11px] text-slate-400">Normal</span>
                                    </label>
                                    <input type="range" id="path-speed-main" min="0.25" max="3" step="0.25" value="1" class="w-full">
                                    <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>0.25x (Slow)</span>
                                        <span>3x (Fast)</span>
                                    </div>
                                </div>
                                <div class="mt-3">
                                    <label for="path-cycles-main" class="form-label block mb-2 flex items-center justify-between">
                                        <span>Number of Repetitions</span>
                                        <span id="path-cycles-value-main" class="text-[11px] text-slate-400">5 cycles</span>
                                    </label>
                                    <input type="range" id="path-cycles-main" min="1" max="20" step="1" value="5" class="w-full" aria-label="Number of path animation cycles">
                                    <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                        <span>1 cycle</span>
                                        <span>20 cycles</span>
                                    </div>
                                </div>
                            </div>

                            <button id="animation-control-btn" class="upload-button w-full py-2 px-3 text-sm mt-4" title="Start or stop the animation">
                                <svg id="play-icon" class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.01M15 10h1.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                                <svg id="stop-icon" class="w-4 h-4 inline-block mr-2 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z M9 10h6v4H9z"/></svg>
                                <span id="control-text">Start Motion</span>
                            </button>
                        </div>

                        <!-- Animation Triggers -->
                        <div class="space-y-3 pt-4 mt-4" style="border-top: 1px solid var(--md-outline-variant);">
                            <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: var(--md-primary);">Animation Triggers</h3>
                            <p class="text-xs" style="color: var(--md-on-surface-variant);">Choose when the animation should play in Play Mode:</p>

                            <div class="space-y-2">
                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="checkbox" id="trigger-on-press" class="cursor-pointer" checked>
                                    <span class="text-sm" style="color: var(--md-on-surface);">Press (touch or click)</span>
                                </label>

                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="checkbox" id="trigger-on-key" class="cursor-pointer">
                                    <span class="text-sm" style="color: var(--md-on-surface);">Keyboard key</span>
                                </label>
                            </div>

                            <div id="key-selection-container" class="mt-3 hidden">
                                <label for="trigger-key-select" class="form-label block mb-2">Select Key</label>
                                <select id="trigger-key-select" class="form-input w-full">
                                    <option value="">-- Select a key --</option>
                                    <optgroup label="Number Keys">
                                        <option value="1">1</option>
                                        <option value="2">2</option>
                                        <option value="3">3</option>
                                        <option value="4">4</option>
                                        <option value="5">5</option>
                                        <option value="6">6</option>
                                        <option value="7">7</option>
                                        <option value="8">8</option>
                                        <option value="9">9</option>
                                    </optgroup>
                                    <optgroup label="Letter Keys">
                                        <option value="a">A</option>
                                        <option value="b">B</option>
                                        <option value="c">C</option>
                                        <option value="d">D</option>
                                        <option value="e">E</option>
                                        <option value="f">F</option>
                                        <option value="g">G</option>
                                        <option value="h">H</option>
                                        <option value="i">I</option>
                                        <option value="j">J</option>
                                        <option value="k">K</option>
                                        <option value="l">L</option>
                                        <option value="m">M</option>
                                        <option value="n">N</option>
                                        <option value="o">O</option>
                                        <option value="p">P</option>
                                        <option value="q">Q</option>
                                        <option value="r">R</option>
                                        <option value="s">S</option>
                                        <option value="t">T</option>
                                        <option value="u">U</option>
                                        <option value="v">V</option>
                                        <option value="w">W</option>
                                        <option value="x">X</option>
                                        <option value="y">Y</option>
                                        <option value="z">Z</option>
                                    </optgroup>
                                </select>
                            </div>
                        </div>

                        <!-- Path Animation Settings (shown when Follow Path is selected) -->
                        <div id="path-animation-settings" class="hidden space-y-3 pt-4 mt-4" style="border-top: 1px solid var(--md-outline-variant);">
                            <h3 class="text-xs font-semibold uppercase tracking-wide mb-3" style="color: var(--md-primary);">Path Settings</h3>

                            <!-- Path Controls -->
                            <div id="path-draw-controls">
                                <button id="clear-path-btn" class="delete-button w-full py-2 px-3 text-sm hidden" title="Remove the path">
                                    <svg class="w-4 h-4 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                    </svg>
                                    <span>Remove Path</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div id="no-selection-properties" class="text-center py-8 animate-fade-in">
                        <div class="text-slate-400 mb-2">
                            <svg class="w-12 h-12 mx-auto mb-3 opacity-40" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </div>
                        <p id="no-selection-message" class="text-sm text-slate-300 font-medium">Add a visual target or shape to begin editing its properties.</p>
                        <p class="text-xs text-slate-500 mt-1">Once selected, its color, animation, and transforms appear here.</p>
                    </div>
                </div>
                <!-- Background Color -->
                <div class="section-header">
                    <button class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                        <span class="flex items-center space-x-2">
                            <svg class="w-4 h-4" style="color: var(--md-primary);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
                            </svg>
                            <span>Background Color</span>
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div class="accordion-content section-content p-3">
                    <div class="space-y-3">
                        <div>
                            <label class="form-label block mb-2">Background Colour</label>
                            <input type="color" id="bg-color-slider" value="#000000" class="form-input w-full h-10 cursor-pointer">
                        </div>
                        <div>
                            <label class="form-label block mb-2">Quick Background Colours</label>
                            <!-- Row 1: High Contrast & Greys -->
                            <div class="flex justify-between px-2 mb-8 gap-2">
                                <button class="preset-color-bg" style="background-color: #000000;" data-color="#000000" title="Black" aria-label="Black background"></button>
                                <button class="preset-color-bg" style="background-color: #2a2a2a;" data-color="#2a2a2a" title="Dark Grey" aria-label="Dark grey background"></button>
                                <button class="preset-color-bg" style="background-color: #808080;" data-color="#808080" title="Medium Grey" aria-label="Medium grey background"></button>
                                <button class="preset-color-bg" style="background-color: #c0c0c0;" data-color="#c0c0c0" title="Light Grey" aria-label="Light grey background"></button>
                            </div>
                            
                            <!-- Row 2: Light Colors & Neutrals -->
                            <div class="flex justify-between px-2 mt-2 gap-2">
                                <button class="preset-color-bg" style="background-color: #ffffff; border-color: #333;" data-color="#ffffff" title="White" aria-label="White background"></button>
                                <button class="preset-color-bg" style="background-color: #f5f5dc;" data-color="#f5f5dc" title="Beige" aria-label="Beige background"></button>
                                <button class="preset-color-bg" style="background-color: #ddd8c7;" data-color="#ddd8c7" title="Cream" aria-label="Cream background"></button>
                                <button class="preset-color-bg" style="background-color: #d2b48c;" data-color="#d2b48c" title="Tan" aria-label="Tan background"></button>
                            </div>
                        </div>
                    </div>
                </div>
                 <!-- Layer Management -->
                <div class="section-header">
                    <button class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                        <span class="flex items-center">
                            <span id="layers-status" class="status-indicator status-active"></span>
                            Layers
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div class="accordion-content section-content p-2">
                    <div id="layer-list" class="space-y-1 max-h-64 overflow-y-auto mb-2"></div>
                    <div id="layers-empty-state" class="empty-state">
                        <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                        </svg>
                        <div class="title">No Objects Yet</div>
                        <div class="subtitle">Add text, shapes, or images to see them appear here as layers</div>
                    </div>
                    <div class="pt-2 mt-2 border-t border-slate-600/40">
                        <div class="flex gap-2">
                            <button id="save-image-btn" class="tool-button flex-1 flex items-center justify-center space-x-2 p-2 rounded-md text-sm" title="Export Scene to Image (PNG)">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 10v6m0 0l-3-3m3 3 3-3m2 8H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5.586a1 1 0 0 1 .707.293l5.414 5.414a1 1 0 0 1 .293.707V19a2 2 0 0 1-2 2z" />
                                </svg>
                                <span class="font-medium">Export Scene to Image</span>
                            </button>
                            <button id="export-info-btn" class="tool-button p-2 rounded-md text-sm" title="Information about exporting scenes">
                                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <line x1="12" y1="16" x2="12" y2="12"/>
                                    <circle cx="12" cy="8" r="0.5" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </aside>

        <!-- Right Media Drawer -->
        <div id="media-library" class="drawer drawer-right w-80">
            <div class="p-3 flex-shrink-0">
                <div class="drawer-header">
                    <h2 class="drawer-title">Media Library</h2>
                    <p class="drawer-subtitle">Import and manage media assets</p>
                </div>
            </div>
            
            <div class="flex-1 overflow-y-auto px-3 pb-3">
                <div id="media-library-accordion" class="space-y-2">
                    <!-- Auto Load Saved Folders Button - Only shown when folders are configured and enabled -->
                    <button id="auto-load-quick-btn" class="hidden w-full upload-button py-2 px-3 rounded-md text-sm font-medium mb-1" style="background: var(--md-primary); color: var(--md-on-primary);" title="Load files from all configured auto-load folders">
                        <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                        </svg>
                        Auto Load Saved Folders
                    </button>

                    <!-- Settings panel relocated to bottom for better grouping -->
                    <!-- Visual Targets Section -->
                    <div class="section-header">
                        <button class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                Visual Targets
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div class="accordion-content section-content p-3">
                        <div class="space-y-3">
                            <label for="image-upload" class="upload-button w-full text-center py-2 px-3 rounded-md cursor-pointer block" title="Add a visual target (image, video, gif)">
                                <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                Add Visual Target
                            </label>
                            <input type="file" id="image-upload" multiple accept="image/*,video/*,.gif,.mp4,.mov,.avi,.mkv,.webm,.3gp,.wmv,.flv,.m4v" class="hidden">
                            <label for="folder-upload" class="upload-button w-full text-center py-2 px-3 rounded-md cursor-pointer block">
                                <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                                </svg>
                                Add Folder
                            </label>
                            <input type="file" id="folder-upload" webkitdirectory directory multiple class="hidden">
                        </div>
                        <div class="mt-4">
                            <div id="visual-targets-grid" class="grid grid-cols-3 gap-2"></div>
                            <div id="visual-targets-empty-state" class="empty-state">
                                <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                <div class="title">No Visual Targets</div>
                                <div class="subtitle">Add images, videos, or GIFs to place as visual targets on the canvas</div>
                            </div>
                        </div>
                    </div>

                    <!-- Backgrounds Section -->
                    <div class="section-header">
                        <button class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                Backgrounds
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div class="accordion-content section-content p-3">
                        <div class="space-y-3">
                            <div class="flex flex-wrap items-center gap-2">
                                <label for="bg-image-input" class="upload-button flex-grow text-center py-2 px-3 rounded-md cursor-pointer order-1">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                    </svg>
                                    Upload Background
                                </label>
                                <input type="file" id="bg-image-input" class="hidden" accept="image/*">
                                <label for="bg-folder-upload" class="upload-button text-center py-2 px-3 rounded-md cursor-pointer order-2" title="Add Backgrounds Folder">
                                    <svg class="w-4 h-4 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                    </svg>
                                    Folder
                                </label>
                                <input type="file" id="bg-folder-upload" webkitdirectory directory multiple class="hidden" accept="image/*,video/*">
                                <button id="delete-bg-btn" class="delete-button hidden p-2 rounded-md order-3" title="Clear Current Background">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="mt-4">
                            <div id="backgrounds-grid" class="grid grid-cols-2 gap-2"></div>
                            <div id="backgrounds-empty-state" class="empty-state">
                                <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                <div class="title">No Backgrounds</div>
                                <div class="subtitle">Upload images to use as backgrounds. These images will always stay as the bottom layer.</div>
                            </div>
                        </div>
                    </div>

                    <!-- Foregrounds Section -->
                    <div class="section-header">
                        <button class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                                </svg>
                                Foregrounds
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div class="accordion-content section-content p-3">
                        <div class="space-y-3">
                            <div class="flex flex-wrap items-center gap-2">
                                <label for="fg-image-input" class="upload-button flex-grow text-center py-2 px-3 rounded-md cursor-pointer order-1">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                    </svg>
                                    Upload Foreground
                                </label>
                                <input type="file" id="fg-image-input" class="hidden" accept="image/*">
                                <label for="fg-folder-upload" class="upload-button text-center py-2 px-3 rounded-md cursor-pointer order-2" title="Add Foregrounds Folder">
                                    <svg class="w-4 h-4 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                    </svg>
                                    Folder
                                </label>
                                <input type="file" id="fg-folder-upload" webkitdirectory directory multiple class="hidden" accept="image/*,video/*">
                                <button id="delete-fg-btn" class="delete-button hidden p-2 rounded-md order-3" title="Clear Current Foreground">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="mt-4">
                            <div id="foregrounds-grid" class="grid grid-cols-2 gap-2"></div>
                            <div id="foregrounds-empty-state" class="empty-state">
                                <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                                </svg>
                                <div class="title">No Foregrounds</div>
                                <div class="subtitle">Upload images to use as foregrounds. These images will always be the top layer and need to have transparent areas to show images behind them.</div>
                            </div>
                        </div>
                    </div>

                    <!-- Position Grids Section -->
                    <div class="section-header mt-4">
                        <button id="grids-toggle" class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="true">
                            <span class="flex items-center space-x-2">
                                <svg class="w-4 h-4" style="color: var(--md-primary);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                                </svg>
                                <span>Position Grids</span>
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div id="grids-panel" class="accordion-content section-content p-3">
                        <div class="space-y-4">
                            <!-- Grid Selection -->
                            <div>
                                <div class="text-xs font-medium mb-2" style="color: var(--md-on-surface-variant);">Grid Layout</div>
                                <div class="grid grid-cols-5 gap-2">
                                    <button id="grid-2" class="grid-button flex flex-col items-center justify-center p-2 rounded" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant); gap: 6px;" data-frames="2">
                                        <div class="grid-preview" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1px; width: 20px; height: 10px; margin-bottom: 8px;">
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                        </div>
                                        <span class="text-[10px]" style="color: var(--md-on-surface-variant);">2</span>
                                    </button>

                                    <button id="grid-4" class="grid-button flex flex-col items-center justify-center p-2 rounded" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant); gap: 6px;" data-frames="4">
                                        <div class="grid-preview" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1px; width: 20px; height: 20px; margin-bottom: 8px;">
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                        </div>
                                        <span class="text-[10px]" style="color: var(--md-on-surface-variant);">4</span>
                                    </button>

                                    <button id="grid-6" class="grid-button flex flex-col items-center justify-center p-2 rounded" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant); gap: 6px;" data-frames="6">
                                        <div class="grid-preview" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1px; width: 24px; height: 16px; margin-bottom: 8px;">
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                        </div>
                                        <span class="text-[10px]" style="color: var(--md-on-surface-variant);">6</span>
                                    </button>

                                    <button id="grid-9" class="grid-button flex flex-col items-center justify-center p-2 rounded" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant); gap: 6px;" data-frames="9">
                                        <div class="grid-preview" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1px; width: 24px; height: 24px; margin-bottom: 8px;">
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                        </div>
                                        <span class="text-[10px]" style="color: var(--md-on-surface-variant);">9</span>
                                    </button>

                                    <button id="grid-12" class="grid-button flex flex-col items-center justify-center p-2 rounded" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant); gap: 6px;" data-frames="12">
                                        <div class="grid-preview" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1px; width: 28px; height: 21px; margin-bottom: 8px;">
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                            <div style="background: var(--md-on-surface-variant); border-radius: 2px;"></div>
                                        </div>
                                        <span class="text-[10px]" style="color: var(--md-on-surface-variant);">12</span>
                                    </button>
                                </div>
                            </div>

                            <!-- Grid Options -->
                            <div style="border-top: 1px solid var(--md-outline); padding-top: 12px;">
                                <div class="text-xs font-medium mb-2" style="color: var(--md-on-surface-variant);">Grid Options</div>
                                <div class="space-y-2">
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="show-position-guides" class="cursor-pointer" checked>
                                        <span class="text-xs" style="color: var(--md-on-surface);">Show position guides <span style="color: var(--md-on-surface-variant);">(Shortcut G)</span></span>
                                    </label>
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="enable-auto-snap" class="cursor-pointer" checked>
                                        <span class="text-xs" style="color: var(--md-on-surface);">Snap targets to positions</span>
                                    </label>
                                </div>
                            </div>

                            <!-- Arrange Options -->
                            <div style="border-top: 1px solid var(--md-outline); padding-top: 12px;">
                                <div class="text-xs font-medium mb-2" style="color: var(--md-on-surface-variant);">Arrange Options</div>
                                <div class="space-y-2">
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="arrange-text-boxes" class="cursor-pointer" checked>
                                        <span class="text-xs" style="color: var(--md-on-surface);">Text boxes are arranged as targets</span>
                                    </label>
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" id="arrange-shapes" class="cursor-pointer" checked>
                                        <span class="text-xs" style="color: var(--md-on-surface);">Shapes are arranged as targets</span>
                                    </label>
                                </div>
                            </div>

                            <!-- Grid Actions -->
                            <div style="border-top: 1px solid var(--md-outline); padding-top: 12px;">
                                <button id="arrange-all-targets" class="upload-button w-full py-2 px-3 rounded text-xs font-medium">
                                    Arrange All Targets
                                </button>
                                <button id="turn-off-grid" class="delete-button w-full py-2 px-3 rounded text-xs mt-4" style="display: none;">
                                    Turn Off Grid
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Auto-Load Folders Section -->
                    <div class="section-header mt-4">
                        <button id="media-settings-toggle" class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="false">
                            <span class="flex items-center space-x-2">
                                <svg class="w-4 h-4" style="color: var(--md-primary);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2-2z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5a2 2 0 012-2h4a2 2 0 012 2v2H8V5z" />
                                </svg>
                                <span>Auto-Load Folders</span>
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div id="media-settings-panel" class="accordion-content section-content p-3" style="max-height:0; overflow:hidden;">
                        <div class="text-[10px] leading-snug mb-3" style="color: var(--md-on-surface-muted);">
                            Save up to 3 directories to automatically load content in future sessions. When loading, you'll need to authorize each folder by clicking "Accept" to grant access permissions.
                        </div>

                        <div class="space-y-3">
                            <!-- Visual Targets Card -->
                            <div id="vt-card" class="auto-load-card rounded-lg p-3" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant);">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <div id="vt-status-indicator" class="w-3 h-3 rounded-full" style="background: var(--md-on-surface-muted);"></div>
                                        <h4 class="font-medium text-sm" style="color: var(--md-on-surface);">Visual Targets</h4>
                                        <div id="vt-file-count" class="text-xs px-2 py-0.5 rounded-full hidden" style="background: var(--md-surface); color: var(--md-on-surface-variant);">0 files</div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="auto-load-visual-targets" class="sr-only peer">
                                        <div class="auto-load-toggle w-9 h-5 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:rounded-full after:h-4 after:w-4 after:transition-all"></div>
                                    </label>
                                </div>
                                <div id="vt-folder-info" class="text-xs mb-2" style="color: var(--md-on-surface-variant);">No folder selected</div>
                                <div class="flex gap-2">
                                    <button id="pick-vt-folder" class="flex-1 upload-button py-1.5 px-3 rounded text-xs" title="Choose folder containing visual target images">Select Folder</button>
                                    <button id="clear-vt-folder" class="delete-button inactive py-1.5 px-2 rounded text-xs" title="Clear folder"></button>
                                </div>
                            </div>

                            <!-- Backgrounds Card -->
                            <div id="bg-card" class="auto-load-card rounded-lg p-3" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant);">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <div id="bg-status-indicator" class="w-3 h-3 rounded-full" style="background: var(--md-on-surface-muted);"></div>
                                        <h4 class="font-medium text-sm" style="color: var(--md-on-surface);">Backgrounds</h4>
                                        <div id="bg-file-count" class="text-xs px-2 py-0.5 rounded-full hidden" style="background: var(--md-surface); color: var(--md-on-surface-variant);">0 files</div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="auto-load-backgrounds" class="sr-only peer">
                                        <div class="auto-load-toggle w-9 h-5 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:rounded-full after:h-4 after:w-4 after:transition-all"></div>
                                    </label>
                                </div>
                                <div id="bg-folder-info" class="text-xs mb-2" style="color: var(--md-on-surface-variant);">No folder selected</div>
                                <div class="flex gap-2">
                                    <button id="pick-bg-folder" class="flex-1 upload-button py-1.5 px-3 rounded text-xs" title="Choose folder containing background images">Select Folder</button>
                                    <button id="clear-bg-folder" class="delete-button inactive py-1.5 px-2 rounded text-xs" title="Clear folder"></button>
                                </div>
                            </div>

                            <!-- Foregrounds Card -->
                            <div id="fg-card" class="auto-load-card rounded-lg p-3" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant);">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <div id="fg-status-indicator" class="w-3 h-3 rounded-full" style="background: var(--md-on-surface-muted);"></div>
                                        <h4 class="font-medium text-sm" style="color: var(--md-on-surface);">Foregrounds</h4>
                                        <div id="fg-file-count" class="text-xs px-2 py-0.5 rounded-full hidden" style="background: var(--md-surface); color: var(--md-on-surface-variant);">0 files</div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="auto-load-foregrounds" class="sr-only peer">
                                        <div class="auto-load-toggle w-9 h-5 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:rounded-full after:h-4 after:w-4 after:transition-all"></div>
                                    </label>
                                </div>
                                <div id="fg-folder-info" class="text-xs mb-2" style="color: var(--md-on-surface-variant);">No folder selected</div>
                                <div class="flex gap-2">
                                    <button id="pick-fg-folder" class="flex-1 upload-button py-1.5 px-3 rounded text-xs" title="Choose folder containing foreground images">Select Folder</button>
                                    <button id="clear-fg-folder" class="delete-button inactive py-1.5 px-2 rounded text-xs" title="Clear folder"></button>
                                </div>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex gap-2 mt-4">
                            <button id="run-auto-load-now" class="w-full upload-button py-2 px-3 rounded-md text-sm" title="Load files from all configured folders now">Load All Files</button>
                        </div>

                        <!-- Save TTS Settings Option -->
                        <div class="mt-4 p-3 rounded-lg" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant);">
                            <label class="flex items-start gap-2 cursor-pointer">
                                <input type="checkbox" id="save-tts-settings" class="cursor-pointer mt-0.5">
                                <span class="text-xs" style="color: var(--md-on-surface);">Save the link between visual targets and their text-to-speech settings</span>
                            </label>
                            <div class="text-[10px] mt-1 ml-5" style="color: var(--md-on-surface-variant);">When the same file is loaded in this browser the text-to-speech settings and labels will be saved.</div>
                        </div>
                    </div>

                    <!-- Advanced Settings Section -->
                    <div class="section-header mt-4">
                        <button class="accordion-button w-full flex justify-between items-center p-3 font-semibold rounded-md" aria-expanded="false">
                            <span class="flex items-center space-x-2">
                                <svg class="w-4 h-4" style="color: var(--md-primary);" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                                <span>Advanced Settings</span>
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div class="accordion-content section-content p-3" style="max-height:0; overflow:hidden;">
                        <!-- Cache Management -->
                        <div class="p-3 rounded-lg" style="border: 1px solid var(--md-outline); background: var(--md-surface-variant);">
                            <h4 class="text-sm font-medium mb-2" style="color: var(--md-on-surface);">App Cache Management</h4>
                            <div class="text-xs mb-3" style="color: var(--md-on-surface-variant);">
                                If you're seeing an old version after the app has been updated, clear the app cache to force a fresh reload.
                            </div>
                            <div class="flex gap-2 text-xs">
                                <button id="clear-app-cache" class="upload-button px-3 py-1.5 rounded text-xs" title="Clear cached files and reload the app">Clear Cache & Reload</button>
                                <button id="check-app-version" class="tool-button px-3 py-1.5 rounded text-xs" style="border: 1px solid var(--md-outline); color: var(--md-on-surface-variant);" title="View current app version and cache info">Check Version</button>
                            </div>
                            <div id="version-info" class="mt-4 text-xs hidden p-2 rounded max-h-32 overflow-y-auto" style="color: var(--md-on-surface-variant); background: var(--md-surface); border: 1px solid var(--md-outline);"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Drawer Toggles -->
        <button id="toggle-controls-btn" class="drawer-toggle drawer-toggle-left" title="Toggle Controls (Ctrl+L)" aria-label="Toggle Controls Panel">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
            </svg>
        </button>
        <button id="toggle-library-btn" class="drawer-toggle drawer-toggle-right" title="Toggle Media Library (Ctrl+M)" aria-label="Toggle Media Library Panel">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"></path>
            </svg>
        </button>

        <!-- Progress Bar -->
        <div id="progress-container" class="progress-container" style="display: none;">
            <div class="progress-text">Loading Media...</div>
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
            <div id="progress-detail" class="progress-detail">0 of 0 files processed</div>
        </div>

        <!-- Context Menu -->
        <div id="context-menu" class="context-menu">
            <button id="ctx-animate" class="flex items-center space-x-2" aria-label="Animate object">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.01M15 10h1.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <span>Animate...</span>
            </button>
            <hr class="my-1">
            <button id="ctx-bring-to-front" class="flex items-center space-x-2" aria-label="Bring to front">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11l5-5m0 0l5 5m-5-5v12"></path>
                </svg>
                <span>Bring to Front</span>
            </button>
            <button id="ctx-send-to-back" class="flex items-center space-x-2" aria-label="Send to back">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 13l-5 5m0 0l-5-5m5 5V6"></path>
                </svg>
                <span>Send to Back</span>
            </button>
            <hr class="my-1">
            <button id="ctx-delete" class="danger flex items-center space-x-2" aria-label="Delete object">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                </svg>
                <span>Delete</span>
            </button>
        </div>

        <!-- Animation Trigger Panel -->
        <div id="animation-panel" class="fixed bottom-4 left-4 z-40 transition-all duration-300 translate-y-full">
            <div id="animation-triggers" class="flex items-center space-x-1"></div>
        </div>

        <!-- Toast Notification Container -->
        <div id="auto-load-toast" class="hidden fixed top-4 right-4 z-50 bg-slate-800 border border-slate-600 rounded-lg p-4 shadow-lg min-w-[300px] max-w-[400px]">
            <div class="flex items-start gap-3">
                <div id="toast-icon" class="w-5 h-5 mt-0.5 flex-shrink-0"></div>
                <div class="flex-1">
                    <div id="toast-title" class="font-medium text-slate-200 text-sm"></div>
                    <div id="toast-message" class="text-slate-400 text-xs mt-1"></div>
                    <div id="toast-progress-container" class="hidden mt-2">
                        <div class="bg-slate-700 rounded-full h-2">
                            <div id="toast-progress-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                        <div id="toast-progress-text" class="text-xs text-slate-400 mt-1"></div>
                    </div>
                </div>
                <button id="toast-close" class="text-slate-400 hover:text-slate-200 text-lg leading-none">&times;</button>
            </div>
        </div>

    <!-- About section (moved into left drawer bottom) -->

    <script>
    document.addEventListener('DOMContentLoaded', () => {
            // --- Version Management & Cache Busting ---
            const APP_VERSION = '2024.09.14.001'; // Update this when deploying new versions
            const VERSION_KEY = 'eyeTrackingAppVersion';
            const SETTINGS_BACKUP_KEY = 'eyeTrackingAppSettingsBackup';
            
            function checkVersionAndManageCache() {
                const storedVersion = localStorage.getItem(VERSION_KEY);
                const currentVersion = APP_VERSION;
                
                if (storedVersion !== currentVersion) {
                    // Version update detected
                    
                    // Backup current settings before any potential cache clearing
                    backupUserSettings();
                    
                    // Show update notification to user
                    showUpdateNotification(storedVersion, currentVersion);
                    
                    // Update stored version
                    localStorage.setItem(VERSION_KEY, currentVersion);
                    
                    // Optional: Clear specific caches while preserving user data
                    clearApplicationCache();
                }
            }
            
            function backupUserSettings() {
                try {
                    const settingsToBackup = {
                        autoLoadFolders: localStorage.getItem('autoLoadFolders.v1'),
                        timestamp: Date.now()
                    };
                    localStorage.setItem(SETTINGS_BACKUP_KEY, JSON.stringify(settingsToBackup));
                } catch (e) {
                    console.warn('Could not backup settings:', e);
                }
            }
            
            function showUpdateNotification(oldVersion, newVersion) {
                // Create a subtle notification that doesn't interrupt workflow
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                    z-index: 10000;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: 14px;
                    max-width: 300px;
                    animation: slideInRight 0.3s ease-out;
                `;
                
                notification.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 4px;"> App Updated!</div>
                    <div style="opacity: 0.9; font-size: 12px;">
                        Version ${newVersion} loaded successfully.<br>
                        Your settings and folders are preserved.
                    </div>
                `;
                
                // Add slide-in animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideInRight {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(notification);
                
                // Auto-remove after 4 seconds
                setTimeout(() => {
                    notification.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => notification.remove(), 300);
                }, 4000);
            }
            
            function clearApplicationCache() {
                // Clear browser cache programmatically where possible
                if ('caches' in window) {
                    caches.keys().then(names => {
                        names.forEach(name => {
                            caches.delete(name);
                        });
                    });
                }
                
                // Add cache-busting to future requests
                addCacheBustingToResources();
            }
            
            function addCacheBustingToResources() {
                // Add cache-busting parameters to dynamically loaded resources
                const timestamp = Date.now();
                
                // Bust cache for any dynamically loaded images/videos
                const originalCreateObjectURL = URL.createObjectURL;
                URL.createObjectURL = function(blob) {
                    const url = originalCreateObjectURL.call(this, blob);
                    return url + '?cb=' + timestamp;
                };
            }
            
            // Force reload if severe cache issues detected
            function forceReloadIfNeeded() {
                const lastReloadTime = localStorage.getItem('lastForceReload');
                const now = Date.now();
                const oneHour = 60 * 60 * 1000;
                
                // Only allow force reload once per hour to prevent reload loops
                if (!lastReloadTime || (now - parseInt(lastReloadTime)) > oneHour) {
                    const urlParams = new URLSearchParams(window.location.search);
                    if (!urlParams.has('nocache')) {
                        localStorage.setItem('lastForceReload', now.toString());
                        window.location.href = window.location.href + '?nocache=' + now;
                        return true;
                    }
                }
                return false;
            }
            
            // Add meta tag to prevent caching of the main HTML file
            function addCacheControlMeta() {
                const metaNoCache = document.createElement('meta');
                metaNoCache.httpEquiv = 'Cache-Control';
                metaNoCache.content = 'no-cache, no-store, must-revalidate';
                document.head.appendChild(metaNoCache);
                
                const metaPragma = document.createElement('meta');
                metaPragma.httpEquiv = 'Pragma';
                metaPragma.content = 'no-cache';
                document.head.appendChild(metaPragma);
                
                const metaExpires = document.createElement('meta');
                metaExpires.httpEquiv = 'Expires';
                metaExpires.content = '0';
                document.head.appendChild(metaExpires);
            }
            
            // Initialize version management
            addCacheControlMeta();
            
            // Check for updates but don't force reload on first load
            const urlParams = new URLSearchParams(window.location.search);
            if (!urlParams.has('nocache')) {
                checkVersionAndManageCache();
            }
            
            // Add keyboard shortcut for manual refresh (Ctrl+Shift+R)
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                    e.preventDefault();
                    if (!forceReloadIfNeeded()) {
                        // If reload was prevented, clear caches and refresh normally
                        if ('caches' in window) {
                            caches.keys().then(names => {
                                Promise.all(names.map(name => caches.delete(name)))
                                    .then(() => window.location.reload(true));
                            });
                        } else {
                            window.location.reload(true);
                        }
                    }
                }
            });
            
            // --- Service Worker for Cache Management ---
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    // Update existing service worker if present
                    registrations.forEach(registration => {
                        registration.update();
                    });
                });
                
                // Register service worker if sw.js exists
                navigator.serviceWorker.register('./sw.js', { updateViaCache: 'none' })
                    .then(registration => {
                        // Check for updates every 30 seconds
                        setInterval(() => {
                            registration.update();
                        }, 30000);
                        
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    showUpdateAvailablePrompt();
                                }
                            });
                        });
                    })
                    .catch(err => {
                        // Service worker not available or failed - not critical
                        console.log('Service worker not available:', err.message);
                    });
            }
            
            function showUpdateAvailablePrompt() {
                const prompt = document.createElement('div');
                prompt.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #2563eb;
                    color: white;
                    padding: 16px 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                    z-index: 10001;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: 14px;
                    max-width: 320px;
                    animation: slideInUp 0.3s ease-out;
                `;
                
                prompt.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;"> New Version Available!</div>
                    <div style="opacity: 0.9; font-size: 13px; margin-bottom: 12px;">
                        A newer version is ready. Your settings will be preserved.
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="this.parentElement.parentElement.remove()" style="
                            background: rgba(255,255,255,0.2);
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 6px;
                            font-size: 12px;
                            cursor: pointer;
                        ">Later</button>
                        <button onclick="window.location.reload()" style="
                            background: white;
                            color: #2563eb;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 6px;
                            font-size: 12px;
                            font-weight: bold;
                            cursor: pointer;
                        ">Update Now</button>
                    </div>
                `;
                
                // Add slide-in animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideInUp {
                        from { transform: translateY(100%); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(prompt);
            }
            
            // --- Splash Screen ---
            const splashScreen = document.getElementById('splash-screen');
            const splashOverlay = document.getElementById('splash-screen-overlay');
            
            const splashCloseBtn = document.getElementById('splash-close-btn');
            function hideSplash() {
                if (!splashOverlay) return;
                splashScreen.classList.add('fade-out');
                splashOverlay.classList.add('fade-out');
                setTimeout(() => {
                    splashOverlay.remove();
                }, 600);
            }
            splashCloseBtn.addEventListener('click', hideSplash);
            // Allow Enter / Space to trigger while focused
            splashCloseBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); hideSplash(); }
            });
            // Give initial focus for accessibility
            setTimeout(() => { splashCloseBtn.focus(); }, 50);

            // About button - simple alert instead of complex dialog
            const aboutBtn = document.getElementById('about-btn');
            aboutBtn.addEventListener('click', () => {
                alert(`Gaze Tracking Canvas - Visual Target Management System

Developed by Niall Brown, Early Childhood Vision Consultant (ECVC)

This application streamlines the process of managing visual targets, backgrounds, and foregrounds for vision assessment and eye gaze tracking applications.

MIT License - Copyright  2024 Niall Brown (ECVC)
This software is provided "as is" without warranty of any kind.`);
            });

            // Export Info Dialog functionality
            const exportInfoBtn = document.getElementById('export-info-btn');
            const exportInfoDialogOverlay = document.getElementById('export-info-dialog-overlay');
            const exportInfoDialogClose = document.getElementById('export-info-dialog-close');

            function showExportInfoDialog() {
                exportInfoDialogOverlay.classList.add('show');
                setTimeout(() => exportInfoDialogClose.focus(), 100);
            }

            function hideExportInfoDialog() {
                exportInfoDialogOverlay.classList.remove('show');
                setTimeout(() => exportInfoBtn.focus(), 300);
            }

            exportInfoBtn.addEventListener('click', showExportInfoDialog);
            exportInfoDialogClose.addEventListener('click', hideExportInfoDialog);

            // Close dialog with Escape key
            exportInfoDialogOverlay.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    hideExportInfoDialog();
                }
            });

            // Close dialog when clicking outside
            exportInfoDialogOverlay.addEventListener('click', (e) => {
                if (e.target === exportInfoDialogOverlay) {
                    hideExportInfoDialog();
                }
            });

            // Allow Enter/Space on close button
            exportInfoDialogClose.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    hideExportInfoDialog();
                }
            });
            
            // --- DOM Elements ---
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvas-container');
            
            const controlsDrawer = document.getElementById('controls-drawer');
            const mediaLibrary = document.getElementById('media-library');
            const toggleControlsBtn = document.getElementById('toggle-controls-btn');
            const toggleLibraryBtn = document.getElementById('toggle-library-btn');
            const fullscreenToggle = document.getElementById('fullscreen-toggle');
            const fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
            const fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');
            const fullscreenText = document.getElementById('fullscreen-text');
            
            const imageUpload = document.getElementById('image-upload');
            const folderUpload = document.getElementById('folder-upload');
            const backgroundsGrid = document.getElementById('backgrounds-grid');
            const foregroundsGrid = document.getElementById('foregrounds-grid');
            const visualTargetsGrid = document.getElementById('visual-targets-grid');
            const backgroundsEmptyState = document.getElementById('backgrounds-empty-state');
            const foregroundsEmptyState = document.getElementById('foregrounds-empty-state');
            const visualTargetsEmptyState = document.getElementById('visual-targets-empty-state');
            
            const selectTool = document.getElementById('select-tool');
            const textTool = document.getElementById('text-tool');
            const rectTool = document.getElementById('rect-tool');
            const squareTool = document.getElementById('square-tool');
            const circleTool = document.getElementById('circle-tool');
            const triangleTool = document.getElementById('triangle-tool');
            const starTool = document.getElementById('star-tool');
            const octagonTool = document.getElementById('octagon-tool');

            const bgColorSlider = document.getElementById('bg-color-slider');
            const presetColorBtns = document.querySelectorAll('.preset-color-bg');
            const bgImageInput = document.getElementById('bg-image-input');
            const deleteBgBtn = document.getElementById('delete-bg-btn');
            const fgImageInput = document.getElementById('fg-image-input');
            const deleteFgBtn = document.getElementById('delete-fg-btn');

            const layerList = document.getElementById('layer-list');
            const layersEmptyState = document.getElementById('layers-empty-state');
            const contextMenu = document.getElementById('context-menu');
            const accordionButtons = document.querySelectorAll('.accordion-button');
            
            // Progress Bar Elements
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressDetail = document.getElementById('progress-detail');

            // Properties Panel Elements
            const propertiesPanel = document.getElementById('properties-panel-content');
            const textProperties = document.getElementById('text-properties');
            const shapeProperties = document.getElementById('shape-properties');
            const transformProperties = document.getElementById('transform-properties');
            const imageProperties = document.getElementById('image-properties');
            const animationProperties = document.getElementById('animation-properties');
            const noSelectionProperties = document.getElementById('no-selection-properties');
            const textContentInput = document.getElementById('text-content-input');
            const textColorInput = document.getElementById('text-color-input');
            const textSizeInput = document.getElementById('text-size-input');
            const textFontSelect = document.getElementById('text-font-select');
            // Large handles: always enabled (removed toggle)
            // --- Touch / Pointer Capability Flags ---
            const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
            // Base handle size (will be user-adjustable)
            let handleSize = 24; // Moderate circular handles for better aesthetics & touch
            let largeHandlesForced = true; // kept for minimal code changes
            let activePointers = new Map();
            let pinchStartInfo = null; // { distance, objOrig }
            let longPressTimer = null;
            const LONG_PRESS_MS = 550;
            let longPressStart = null; // {x,y}
            let lastTapTime = 0; let lastTapPos = null; const DOUBLE_TAP_MS = 350; const DOUBLE_TAP_DIST = 30;
            const textBoldToggle = document.getElementById('text-bold-toggle');
            const textItalicToggle = document.getElementById('text-italic-toggle');
            const shapeColorInput = document.getElementById('shape-color-input');
            const flipHorizontalBtn = document.getElementById('flip-horizontal-btn');
            const flipVerticalBtn = document.getElementById('flip-vertical-btn');
            const rotate90Btn = document.getElementById('rotate-90-btn');

            // Speech Elements
            const speechProperties = document.getElementById('speech-properties');
            const speechModeRadios = document.querySelectorAll('input[name="speech-mode"]');
            const customSpeechInputContainer = document.getElementById('custom-speech-input-container');
            const customSpeechText = document.getElementById('custom-speech-text');

            // Mode Toggle Elements
            const modeToggleBtn = document.getElementById('mode-toggle-btn');
            const modeToggleText = document.getElementById('mode-toggle-text');
            const modeDescription = document.getElementById('mode-description');
            const currentModeName = document.getElementById('current-mode-name');
            const currentModeDescription = document.getElementById('current-mode-description');
            const currentModeIconEdit = document.getElementById('current-mode-icon-edit');
            const currentModeIconPlay = document.getElementById('current-mode-icon-play');
            const switchIconEdit = document.getElementById('switch-icon-edit');
            const switchIconPlay = document.getElementById('switch-icon-play');
            const editModeTools = document.getElementById('edit-mode-tools');

            // Animation Elements
            const animationSelect = document.getElementById('animation-select');
            const animationSettings = document.getElementById('animation-settings');
            const animationDuration = document.getElementById('animation-duration');
            const animationCycles = document.getElementById('animation-cycles');
            const animationIntensity = document.getElementById('animation-intensity');
            const durationValue = document.getElementById('duration-value');
            const cyclesValue = document.getElementById('cycles-value');
            const intensityValue = document.getElementById('intensity-value');
            const animationControlBtn = document.getElementById('animation-control-btn');
            const triggerOnPressChk = document.getElementById('trigger-on-press');
            const triggerOnKeyChk = document.getElementById('trigger-on-key');
            const keySelectionContainer = document.getElementById('key-selection-container');
            const triggerKeySelect = document.getElementById('trigger-key-select');
            const playIcon = document.getElementById('play-icon');
            const stopIcon = document.getElementById('stop-icon');
            const controlText = document.getElementById('control-text');
            const animationPanel = document.getElementById('animation-panel');
            const animationTriggers = document.getElementById('animation-triggers');
            const animationEasing = document.getElementById('animation-easing');
            const animationIteration = document.getElementById('animation-iteration');
            const livePreviewToggle = document.getElementById('live-preview-toggle');

            // Path Animation Elements
            const clearPathBtn = document.getElementById('clear-path-btn');
            const pathAnimationSettings = document.getElementById('path-animation-settings');
            const standardAnimationControls = document.getElementById('standard-animation-controls');
            const pathAnimationControls = document.getElementById('path-animation-controls');
            const pathSpeedMain = document.getElementById('path-speed-main');
            const pathSpeedValueMain = document.getElementById('path-speed-value-main');
            const pathCyclesMain = document.getElementById('path-cycles-main');
            const pathCyclesValueMain = document.getElementById('path-cycles-value-main');

            // --- State ---
            let objects = [];
            let selectedObject = null;
            let isDragging = false;
            let interactionMode = 'edit'; // 'edit' or 'play'
            let isResizing = false;
            let resizeHandle = null;
            let dragStartX, dragStartY;
            let currentTool = 'select';
            let backgroundColor = '#000000'; // Default to black
            let backgroundImage = null;
            let foregroundImage = null;
            let animationLoopRunning = false;
            let lastTime = 0;
            let pingPongDirection = 1; // used for ping-pong loop style

            // Path Animation State
            let isDrawingPath = false; // Whether currently drawing a path
            let pathDrawingObject = null; // Object whose path is being drawn
            let selectedPathNode = null; // Currently selected path node {path, nodeIndex}
            let isDraggingPathNode = false; // Whether dragging a path node
            
            // Grid State
            let currentGrid = null; // null, 2, 4, 6, 9, or 12
            let gridFrames = [];
            let showGuides = true; // Show position guides
            let enableAutoSnap = true; // Enable automatic snapping
            let snapStrength = 80; // Increased for easier snapping
            let isSnapping = false;
            let snapAnimation = null;
            let tempGridVisibility = false; // Track if grid was temporarily shown during drag
            
            // Shape Creation State
            // Color harmony palettes - each palette contains harmonious colors
            const colorHarmonyPalettes = {
                // Warm Sunset palette
                warm: [
                    '#FF6B35', '#F7931E', '#FFD23F', '#FF4500', '#FF8C42',
                    '#FF6347', '#FFA500', '#FFB347', '#FF7F50', '#FF8C69'
                ],
                // Cool Ocean palette  
                cool: [
                    '#0077BE', '#00A8CC', '#7DD3C0', '#4ECDC4', '#45B7D1',
                    '#96CEB4', '#85C1E9', '#5DADE2', '#3498DB', '#2E86AB'
                ],
                // Earth/Nature palette
                earth: [
                    '#8FBC8F', '#228B22', '#32CD32', '#9ACD32', '#6B8E23',
                    '#708238', '#87A96B', '#A4BE7B', '#C5D6A6', '#8FC93A'
                ],
                // Purple/Magenta palette
                cosmic: [
                    '#8E44AD', '#9B59B6', '#AF7AC5', '#C39BD3', '#D7BDE2',
                    '#BA55D3', '#DA70D6', '#DDA0DD', '#E6E6FA', '#9370DB'
                ],
                // Vibrant Mixed (complementary colors)
                vibrant: [
                    '#E74C3C', '#3498DB', '#F39C12', '#2ECC71', '#9B59B6',
                    '#E67E22', '#1ABC9C', '#34495E', '#F1C40F', '#16A085'
                ]
            };
            
            // Current palette and color management
            let currentPalette = 'vibrant'; // Start with vibrant
            let currentColorIndex = 0;
            let paletteRotationCount = 0;
            
            // Function to get next harmonious color
            function getNextHarmoniousColor() {
                const palette = colorHarmonyPalettes[currentPalette];
                const color = palette[currentColorIndex];
                
                currentColorIndex++;
                
                // When we reach the end of a palette, switch to the next one
                if (currentColorIndex >= palette.length) {
                    currentColorIndex = 0;
                    paletteRotationCount++;
                    
                    // Cycle through palettes
                    const paletteNames = Object.keys(colorHarmonyPalettes);
                    const currentPaletteIndex = paletteNames.indexOf(currentPalette);
                    const nextPaletteIndex = (currentPaletteIndex + 1) % paletteNames.length;
                    currentPalette = paletteNames[nextPaletteIndex];
                }
                
                return color;
            }
            
            let shapeOffsetX = 0;
            let shapeOffsetY = 0;
            
            // Media Library State (encapsulated via MediaLibrary object)
            const MediaLibrary = (() => {
                const assets = {
                    backgrounds: [],
                    foregrounds: [],
                    visualTargets: []
                };
                return {
                    assets,
                    add(category, el, metadata = {}){ 
                        // Add auto-load metadata to the element
                        if (metadata.autoLoaded) {
                            el.dataset.autoLoaded = 'true';
                            el.dataset.autoLoadSource = metadata.sourceFolderName || 'Auto-loaded';
                            el.dataset.autoLoadCategory = metadata.category || category;
                            el.dataset.loadedAt = new Date().toISOString();
                        }
                        assets[category].push(el); 
                    },
                    remove(category, el){ const i = assets[category].indexOf(el); if(i>-1) assets[category].splice(i,1); },
                    move(from,to,el){ this.remove(from,el); this.add(to,el); },
                    list(category){ return assets[category]; },
                    isEmpty(category){ return assets[category].length===0; },
                    getAutoLoadedFiles(category){ 
                        return assets[category].filter(el => el.dataset.autoLoaded === 'true'); 
                    },
                    clearAutoLoadedFiles(category){ 
                        const autoLoadedFiles = this.getAutoLoadedFiles(category);
                        autoLoadedFiles.forEach(el => this.remove(category, el));
                        return autoLoadedFiles.length;
                    },
                    getAllAutoLoadedFiles(){
                        const allAutoLoaded = [];
                        Object.keys(assets).forEach(category => {
                            const autoFiles = this.getAutoLoadedFiles(category);
                            autoFiles.forEach(file => {
                                allAutoLoaded.push({
                                    file,
                                    category,
                                    sourceFolderName: file.dataset.autoLoadSource,
                                    loadedAt: file.dataset.loadedAt
                                });
                            });
                        });
                        return allAutoLoaded;
                    }
                };
            })();
            // Backwards compatibility alias
            const mediaAssets = MediaLibrary.assets;
            
            // Animation State
            let animatedObjects = [];
            let animationPanelVisible = false;

            // Animation Panel Management
            function updateAnimationTriggerPanel() {
                // Show any object that has an animation type configured (running or not)
                const animatedObjs = objects.filter(obj => !!obj.animationType);
                animationTriggers.innerHTML = '';
                
                if (animatedObjs.length === 0) {
                    hideAnimationPanel();
                    return;
                }
                
                animatedObjs.forEach((obj, index) => {
                    const triggerBtn = document.createElement('button');
                    triggerBtn.className = `animation-trigger-btn ${obj.animationType}`;
                    triggerBtn.dataset.objectId = obj.id;
                    triggerBtn.dataset.keyIndex = index + 1;
                    triggerBtn.title = `${obj.name} - Press ${index + 1}`;
                    
                    triggerBtn.innerHTML = `
                        <div class="key-indicator">${index + 1}</div>
                        <div class="animation-icon"></div>
                        <div class="object-name">${obj.name}</div>
                    `;
                    
                    triggerBtn.addEventListener('click', () => {
                        triggerAnimation(obj);
                        if(obj === selectedObject) updateAnimationControlButton();
                    });
                    
                    animationTriggers.appendChild(triggerBtn);
                });
                
                showAnimationPanel();
            }
            
            function showAnimationPanel() {
                if (!animationPanelVisible) {
                    animationPanel.classList.remove('translate-y-full');
                    animationPanelVisible = true;
                }
            }
            
            function hideAnimationPanel() {
                if (animationPanelVisible) {
                    animationPanel.classList.add('translate-y-full');
                    animationPanelVisible = false;
                }
            }
            
            function triggerAnimation(obj) {
                if (!obj || !obj.animationType) {
                    console.warn('Animation trigger failed: Invalid object or no animation type');
                    return false;
                }
                
                // Restart animation from beginning
                obj.isAnimating = true;
                obj.animationStartTime = performance.now();
                obj.cycleCount = 0;

                if (obj.animationType) {
                    // Visual feedback on trigger button
                    const triggerBtn = document.querySelector(`[data-object-id="${obj.id}"]`);
                    if (triggerBtn) {
                        triggerBtn.classList.add('triggering');
                        setTimeout(() => {
                            triggerBtn.classList.remove('triggering');
                        }, 500);
                    }
                    if(selectedObject === obj) {
                        updateAnimationControlButton();
                    }
                    
                    // Start animation loop if not already running
                    if (!animationLoopRunning) {
                        startAnimationLoop();
                    }
                    ensureRenderLoop();
                    return true;
                }
                return false;
            }
            
            function startAnimationLoop() {
                if (animationLoopRunning) return; // Prevent multiple loops
                animationLoopRunning = true;
                lastTime = 0;
                
                function animate(currentTime) {
                    if (lastTime === 0) lastTime = currentTime;
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;
                    
                    // Check if any objects are still animating
                    const stillAnimating = objects.some(obj => obj.isAnimating);
                    
                    if (stillAnimating) {
                        draw();
                        requestAnimationFrame(animate);
                    } else {
                        animationLoopRunning = false;
                        lastTime = 0;
                        // All animations finished  reset preview button UI
                        try {
                            if (typeof updateAnimationControlButton === 'function') {
                                updateAnimationControlButton();
                            }
                        } catch {}
                    }
                }
                
                requestAnimationFrame(animate);
            }

            // --- Canvas Setup ---
            function getCanvasDimensions() {
                const rect = canvasContainer.getBoundingClientRect();
                return { width: rect.width, height: rect.height };
            }
            
            function resizeCanvas() {
                const rect = canvasContainer.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // Set the canvas internal size accounting for device pixel ratio
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;

                // Set the canvas CSS size to the display size
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';

                // Scale the context to match device pixel ratio
                ctx.scale(dpr, dpr);

                // Recalculate grid frames and reposition objects if a grid is active
                if (currentGrid) {
                    const oldGridFrames = [...gridFrames]; // Save old grid positions
                    gridFrames = calculateGridFrames(currentGrid); // Calculate new positions

                    // Reposition objects that were snapped to grid
                    if (oldGridFrames.length === gridFrames.length) {
                        objects.forEach(obj => {
                            if (!obj.visible) return;

                            const center = getObjectCenter(obj);

                            // Find which old grid position this object was closest to
                            let closestOldIndex = -1;
                            let minDistance = 50; // Threshold to consider object "on grid"

                            oldGridFrames.forEach((oldFrame, index) => {
                                const distance = Math.sqrt(
                                    (center.x - oldFrame.x) ** 2 +
                                    (center.y - oldFrame.y) ** 2
                                );
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestOldIndex = index;
                                }
                            });

                            // If object was on a grid position, move it to the same position in new grid
                            if (closestOldIndex >= 0 && gridFrames[closestOldIndex]) {
                                const newFrame = gridFrames[closestOldIndex];
                                setObjectCenterPosition(obj, newFrame.x, newFrame.y);
                            }
                        });
                    }

                    if (typeof recomputeGridOccupancy === 'function') recomputeGridOccupancy();
                }

                draw();
            }
            // Initialize large handles preference
            (function initHandlePreference(){
                applyHandleSize();
            })();
            function applyHandleSize(){ handleSize = 24; }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Initialize mode toggle button color (starts in edit mode)
            modeToggleBtn.style.background = '#4caf50'; // Green for Play Mode button
            modeToggleBtn.style.color = 'white';
            modeToggleBtn.style.borderColor = '#4caf50';

            // Initialize status indicators
            updateStatusIndicators();

            // Initialize empty states
            updateLayerList();
            updateEmptyStates();

            // --- Drawing Engine ---
            function draw() {
                const dpr = window.devicePixelRatio || 1;
                const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                
                // Reset transform to clear any previous scaling
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Apply device pixel ratio scaling
                ctx.scale(dpr, dpr);
                
                // Configure image smoothing for crisp rendering
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                if (backgroundImage) {
                    drawCoverImage(backgroundImage.img, canvasWidth, canvasHeight);
                }

                // Draw grid overlay (below objects, above background)
                drawGridOverlay();

                objects.sort((a, b) => a.zIndex - b.zIndex).forEach(obj => {
                    if (obj.visible) {
                       obj.draw(ctx);
                    }
                });

                // Draw path for selected object (in edit mode only)
                if (interactionMode === 'edit' && selectedObject && selectedObject.animationPath) {
                    const isActive = isDrawingPath;
                    const selectedNodeIdx = selectedPathNode && selectedPathNode.path === selectedObject.animationPath ? selectedPathNode.nodeIndex : -1;
                    selectedObject.animationPath.draw(ctx, isActive, selectedNodeIdx);
                }

                if (foregroundImage) {
                    drawCoverImage(foregroundImage.img, canvasWidth, canvasHeight);
                }

                // Draw active drag indicator on top (above objects)
                drawGridDragIndicator();

                // Only show selection handles in Edit mode
                if (interactionMode === 'edit' && selectedObject && currentTool === 'select') {
                    drawSelectionHandles(selectedObject);
                }
            }

            // Continuous render loop to keep video frames updating
            let continuousLoop = false;
            function ensureRenderLoop() {
                if (continuousLoop) return;
                continuousLoop = true;
                function loop() {
                    const hasVideo = objects.some(o => o.type === 'video');
                    const dragging = isDragging || isResizing;
                    const animating = objects.some(o => o.isAnimating);
                    const snapping = isSnapping;
                    if (hasVideo || dragging || animating || snapping) {
                        draw();
                        requestAnimationFrame(loop);
                    } else {
                        continuousLoop = false; // allow restart when needed
                    }
                }
                requestAnimationFrame(loop);
            }
            
            function drawCoverImage(img, canvasWidth, canvasHeight) {
                const canvasRatio = canvasWidth / canvasHeight;
                const imgRatio = img.width / img.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imgRatio > canvasRatio) {
                    // Image is wider than canvas
                    drawHeight = canvasHeight;
                    drawWidth = drawHeight * imgRatio;
                    drawX = (canvasWidth - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas
                    drawWidth = canvasWidth;
                    drawHeight = drawWidth / imgRatio;
                    drawX = 0;
                    drawY = (canvasHeight - drawHeight) / 2;
                }
                
                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            }
            
            function drawSelectionHandles(obj) {
                const center = { x: obj.x + obj.width / 2, y: obj.y + obj.height / 2 };
                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.rotate(obj.rotation);
                ctx.translate(-center.x, -center.y);
                
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                ctx.setLineDash([]);
                
                getResizeHandles(obj).forEach(handle => {
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#4f46e5';
                    ctx.lineWidth = 2;
                    const radius = (handle.size / 2);
                    const cx = handle.x + handle.size / 2;
                    const cy = handle.y + handle.size / 2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                });
                ctx.restore();
            }

            // --- Object Classes ---
            class CanvasObject { 
                constructor(x, y, width, height, zIndex, type) { 
                    this.id = Date.now() + Math.random(); 
                    this.x = x; 
                    this.y = y; 
                    this.initialX = x; 
                    this.initialY = y; 
                    this.width = width; 
                    this.height = height; 
                    this.zIndex = zIndex; 
                    this.type = type; 
                    this.visible = true; 
                    this.rotation = 0; 
                    this.scale = 1; 
                    this.flipHorizontal = false;
                    this.flipVertical = false;
                    // Animation properties
                    this.animationType = null;
                    this.animationDuration = 1.0;
                    this.animationCycles = 1; // Default to a single cycle
                    this.animationIntensity = 5;
                    this.cycleCount = 0;
                    this.animationEasing = 'ease-in-out';
                    this.animationIteration = 'infinite'; // 'infinite' | '1' | 'yoyo'
                    this.isAnimating = false;
                    this.animationStartTime = 0;
                    this.animationCycleTime = 0; // accumulative for smooth looping
                    // Speech properties
                    this.speechMode = 'none'; // 'none' | 'default' | 'custom'
                    this.customSpeechText = ''; // Custom text to read when speechMode is 'custom'
                    // Animation trigger properties
                    this.triggerOnPress = true; // Trigger animation on press/click (default ON)
                    this.triggerOnKey = false; // Trigger animation on keyboard key
                    this.triggerKey = ''; // The key that triggers the animation
                    // Path animation properties
                    this.animationPath = null; // AnimationPath object for this target
                    this.pathAnimationMode = 'to-end'; // 'to-end' | 'loop' | 'pingpong'
                    this.pathAnimationDuration = 5; // Seconds to complete the path (default slower)
                    this.pathAnimationSpeed = 1; // Speed multiplier (0.25 to 3)
                    this.pathAnimationProgress = 0; // Current position on path (0 to 1)
                    this.pathAnimationDirection = 1; // 1 for forward, -1 for reverse (pingpong)
                    this.isPathAnimating = false;
                    this.pathAnimationStartTime = 0;
                }

                // Get center point of object
                getCenterPoint() {
                    return {
                        x: this.x + this.width / 2,
                        y: this.y + this.height / 2
                    };
                } 
                
                isPointInside(px, py) { 
                    const center = { x: this.x + this.width / 2, y: this.y + this.height / 2 }; 
                    const translatedX = px - center.x; 
                    const translatedY = py - center.y; 
                    const rotatedX = translatedX * Math.cos(-this.rotation) - translatedY * Math.sin(-this.rotation); 
                    const rotatedY = translatedX * Math.sin(-this.rotation) + translatedY * Math.cos(-this.rotation); 
                    return Math.abs(rotatedX) <= this.width / 2 && Math.abs(rotatedY) <= this.height / 2; 
                } 
                
                draw(ctx) { 
                    const center = { x: this.x + this.width / 2, y: this.y + this.height / 2 }; 
                    ctx.save(); 
                    ctx.translate(center.x, center.y); 
                    ctx.rotate(this.rotation); 
                    ctx.scale(
                        this.scale * (this.flipHorizontal ? -1 : 1), 
                        this.scale * (this.flipVertical ? -1 : 1)
                    ); 
                    
                    // Apply animation transform only while actively animating
                    if (this.animationType && this.isAnimating) {
                        // Cycle-based animation
                        const now = performance.now();
                        if(!this.animationStartTime) this.animationStartTime = now;
                        let elapsed = (now - this.animationStartTime) / 1000; // seconds

                        // Apply speed modifier for path animations
                        if (this.animationType === 'path' && this.pathAnimationSpeed) {
                            elapsed *= this.pathAnimationSpeed;
                        }

                        const cycle = this.animationDuration || 1;
                        let maxCycles = this.animationCycles || 5;
                        
                        // For path animations in 'to-end' mode, only do one cycle regardless of setting
                        if (this.animationType === 'path' && this.pathAnimationMode === 'to-end') {
                            maxCycles = 1;
                        }
                        
                        // Calculate current cycle and progress within cycle
                        const totalCyclesFloat = elapsed / cycle;
                        const currentCycle = Math.floor(totalCyclesFloat);
                        let rawProgress = totalCyclesFloat - currentCycle; // 0..1 within current cycle
                        
                        // Check if we've completed all desired cycles
                        if (totalCyclesFloat >= maxCycles) {
                            // Animation finished - stop immediately without fade
                            this.isAnimating = false;
                            this.animationStartTime = 0;
                            this.cycleCount = 0;
                            // If this was the selected object, revert the play/stop UI
                            try {
                                if (typeof updateAnimationControlButton === 'function' && typeof selectedObject !== 'undefined' && selectedObject === this) {
                                    updateAnimationControlButton();
                                }
                            } catch {}
                        } else {
                            // Normal animation with smooth start
                            this.cycleCount = currentCycle;
                            
                            // Apply smooth start-up for first cycle
                            let startupMultiplier = 1;
                            if (currentCycle === 0 && rawProgress < 0.3) {
                                // Smooth ease-in during first 30% of first cycle
                                const startupProgress = rawProgress / 0.3;
                                startupMultiplier = Math.sin((startupProgress * Math.PI) / 2); // Smooth start using sine
                            }
                            
                            this.tempStartupMultiplier = startupMultiplier;
                            this.applyAnimationTransform(ctx, rawProgress);
                            this.tempStartupMultiplier = 1; // Reset
                        }
                    }
                    
                    ctx.translate(-center.x, -center.y); 
                    this.drawContent(ctx); 
                    ctx.restore(); 
                } 
                
                applyAnimationTransform(ctx, progress) {
                    const baseIntensity = this.animationIntensity;
                    const fadeMultiplier = this.tempFadeMultiplier || 1;
                    const startupMultiplier = this.tempStartupMultiplier || 1;
                    const intensity = baseIntensity * fadeMultiplier * startupMultiplier;

                    // Clamp progress to prevent overshooting
                    const clampedProgress = Math.max(0, Math.min(1, progress));

                    switch (this.animationType) {
                        case 'path': {
                            // Follow the animation path
                            if (this.animationPath && this.animationPath.nodes.length >= 2) {
                                // Calculate path progress based on animation mode
                                let pathProgress = clampedProgress;

                                if (this.pathAnimationMode === 'pingpong') {
                                    // Ping-pong: go forward then backward
                                    pathProgress = pathProgress < 0.5
                                        ? pathProgress * 2
                                        : (1 - pathProgress) * 2;
                                }
                                // For 'loop' mode, progress just wraps around 0-1
                                // For 'to-end' mode, it stays at 1 after completion

                                const point = this.animationPath.getPointAt(pathProgress);
                                if (point) {
                                    // Get object's current center
                                    const currentCenter = this.getCenterPoint();
                                    // Calculate offset to move object to path point
                                    const offsetX = point.x - currentCenter.x;
                                    const offsetY = point.y - currentCenter.y;
                                    ctx.translate(offsetX, offsetY);
                                }
                            }
                            break;
                        }
                        case 'gentle-shake': {
                            // Smooth sinusoidal shake - starts and ends at center
                            const angle = clampedProgress * Math.PI * 2;
                            const shakeX = Math.sin(angle) * intensity;
                            ctx.translate(shakeX, 0);
                            break;
                        }
                        case 'pendum': {
                            // Smooth pendulum swing - starts and ends at center (equilibrium)
                            const amplitudeRad = (intensity * 3) * Math.PI / 180;
                            const angle = clampedProgress * Math.PI * 2;
                            // Use sine for pendulum to start/end at center position
                            const pendulumAngle = Math.sin(angle) * amplitudeRad;
                            const pivotTopY = -this.height / 2;
                            ctx.translate(0, pivotTopY);
                            ctx.rotate(pendulumAngle);
                            ctx.translate(0, -pivotTopY);
                            break;
                        }
                        case 'circular': {
                            // Smooth circular orbit - continuous motion
                            const radius = intensity * 2;
                            const angle = clampedProgress * Math.PI * 2;
                            const circularX = Math.cos(angle) * radius;
                            const circularY = Math.sin(angle) * radius;
                            ctx.translate(circularX, circularY);
                            break;
                        }
                    }
                }
                
                startAnimation() {
                    if(!this.animationType) return false;
                    this.isAnimating = true;
                    this.animationStartTime = performance.now();
                    this.cycleCount = 0;
                    return true;
                }
                
                drawContent(ctx) { } 
                updateMetrics() { } 
            }
            class ImageObject extends CanvasObject { 
                constructor(img, x, y, width, height, zIndex, type = 'image') { 
                    super(x, y, width, height, zIndex, type); 
                    this.img = img; 
                    this.name = type === 'foreground' ? `[FG] ${img.dataset.name}` : (img.dataset.name || 'Image'); 
                } 
                
                drawContent(ctx) { 
                    // Note: Flipping is handled by the base class draw() method
                    // so we don't need to apply it here again
                    ctx.drawImage(this.img, this.x, this.y, this.width, this.height); 
                } 
            }
            
            class VideoObject extends CanvasObject { 
                constructor(video, x, y, width, height, zIndex, type = 'video') { 
                    super(x, y, width, height, zIndex, type); 
                    this.video = video; 
                    this.name = video.dataset.name || 'Video'; 
                } 
                
                drawContent(ctx) { 
                    // Draw video frame to canvas
                    ctx.drawImage(this.video, this.x, this.y, this.width, this.height); 
                } 
            }
    class TextObject extends CanvasObject { 
                constructor(text, x, y, zIndex) { 
                    super(x, y, 0, 0, zIndex, 'text'); 
                    this.text = text; 
                    this.color = '#FFFFFF'; 
                    this.size = 40; 
            this.fontFamily = 'Luciole, "Atkinson Hyperlegible", Inter, system-ui, sans-serif';
        this.fontWeight = 400;
        this.fontStyle = 'normal';
            this.name = `Text: "${text.substring(0, 15)}..."`; 
                    this.initialX = x;
                    this.initialY = y;
                    this.hasBeenPositioned = false; // Track if text has been initially positioned
                    this.updateMetrics(); 
                } 
                drawContent(ctx) { 
                    ctx.fillStyle = this.color; 
            ctx.font = `${this.fontStyle} ${this.fontWeight} ${this.size}px ${this.fontFamily}`; 
                    ctx.textBaseline = 'top'; 
                    ctx.fillText(this.text, this.x, this.y); 
                } 
                updateMetrics() { 
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = `${this.fontStyle} ${this.fontWeight} ${this.size}px ${this.fontFamily}`; 
                    const metrics = tempCtx.measureText(this.text); 
                    
                    // Store old dimensions
                    const oldWidth = this.width || 0;
                    const oldHeight = this.height || 0;
                    
                    // Update dimensions
                    this.width = metrics.width; 
                    this.height = this.size; 
                    
                    // Only update position if it's initial creation (not during resize or edit)
                    if (!this.isResizing && !this.hasBeenPositioned) {
                        this.x = this.initialX - this.width / 2; 
                        this.y = this.initialY - this.height / 2;
                        this.hasBeenPositioned = true;
                    }
                    
                    this.name = `Text: "${this.text.substring(0, 15)}..."`; 
                } 
            }
            class ShapeObject extends CanvasObject { 
                constructor(shapeType, x, y, zIndex, color = '#FF5733') { 
                    // Set initial dimensions; make rectangles slightly wider than tall for recognizability
                    let initWidth = 100;
                    let initHeight = 100;
                    if (shapeType === 'rect') {
                        initWidth = 120; // slightly longer on X axis
                        initHeight = 100;
                    }
                    super(x - initWidth/2, y - initHeight/2, initWidth, initHeight, zIndex, 'shape'); 
                    this.shapeType = shapeType; 
                    this.color = color; 
                    this.name = `Shape: ${shapeType}`; 
                } 
                drawContent(ctx) { 
                    // Save the current context state
                    ctx.save();
                    
                    // Add subtle shadow for depth
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 2;
                    
                    switch(this.shapeType) { 
                        case 'rect': 
                            // Create gradient for rectangle
                            const rectGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            rectGradient.addColorStop(0, this.color);
                            rectGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            
                            ctx.fillStyle = rectGradient;
                            
                            // Draw rounded rectangle
                            const rectRadius = Math.min(8, Math.min(this.width, this.height) / 4);
                            ctx.beginPath();
                            ctx.roundRect(this.x, this.y, this.width, this.height, rectRadius);
                            ctx.fill();
                            
                            // Add subtle border
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            break; 
                        case 'square':
                            // Render a square (same as rect, but the size is enforced elsewhere)
                            const sqGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            sqGradient.addColorStop(0, this.color);
                            sqGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            ctx.fillStyle = sqGradient;
                            const sqRadius = Math.min(8, Math.min(this.width, this.height) / 4);
                            ctx.beginPath();
                            ctx.roundRect(this.x, this.y, this.width, this.height, sqRadius);
                            ctx.fill();
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            break;
                            
                        case 'circle': 
                            // Create radial gradient for circle
                            const centerX = this.x + this.width / 2;
                            const centerY = this.y + this.height / 2;
                            const radius = this.width / 2;
                            
                            const circleGradient = ctx.createRadialGradient(
                                centerX - radius * 0.3, centerY - radius * 0.3, 0,
                                centerX, centerY, radius
                            );
                            circleGradient.addColorStop(0, this.adjustColorBrightness(this.color, 30));
                            circleGradient.addColorStop(0.7, this.color);
                            circleGradient.addColorStop(1, this.adjustColorBrightness(this.color, -25));
                            
                            ctx.fillStyle = circleGradient;
                            ctx.beginPath(); 
                            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2); 
                            ctx.fill();
                            
                            // Add subtle border
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            break; 
                            
                        case 'triangle': 
                            // Create linear gradient for triangle
                            const triangleGradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                            triangleGradient.addColorStop(0, this.adjustColorBrightness(this.color, 20));
                            triangleGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            
                            ctx.fillStyle = triangleGradient;
                            ctx.beginPath(); 
                            ctx.moveTo(this.x + this.width / 2, this.y); 
                            ctx.lineTo(this.x + this.width, this.y + this.height); 
                            ctx.lineTo(this.x, this.y + this.height); 
                            ctx.closePath(); 
                            ctx.fill();
                            
                            // Add subtle border
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.lineJoin = 'round';
                            ctx.stroke();
                            break;
                        case 'star':
                            const starGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            starGradient.addColorStop(0, this.adjustColorBrightness(this.color, 20));
                            starGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            ctx.fillStyle = starGradient;
                            ctx.beginPath();
                            this.drawStar(ctx, this.x + this.width / 2, this.y + this.height / 2, 5, this.width / 2, this.width / 4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.lineJoin = 'round';
                            ctx.stroke();
                            break;
                        case 'octagon':
                            const octagonGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            octagonGradient.addColorStop(0, this.adjustColorBrightness(this.color, 20));
                            octagonGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            ctx.fillStyle = octagonGradient;
                            ctx.beginPath();
                            this.drawPolygon(ctx, this.x + this.width / 2, this.y + this.height / 2, 8, this.width / 2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.lineJoin = 'round';
                            ctx.stroke();
                            break;
                    }
                    
                    // Restore the context state
                    ctx.restore();
                }

                drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                    let rot = Math.PI / 2 * 3;
                    let x = cx;
                    let y = cy;
                    let step = Math.PI / spikes;

                    ctx.moveTo(cx, cy - outerRadius);
                    for (let i = 0; i < spikes; i++) {
                        x = cx + Math.cos(rot) * outerRadius;
                        y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y);
                        rot += step;

                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y);
                        rot += step;
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                }

                drawPolygon(ctx, cx, cy, sides, radius) {
                    const angle = 2 * Math.PI / sides;
                    ctx.moveTo(cx + radius * Math.cos(0), cy + radius * Math.sin(0));
                    for (let i = 1; i <= sides; i++) {
                        ctx.lineTo(cx + radius * Math.cos(i * angle), cy + radius * Math.sin(i * angle));
                    }
                }
                
                // Helper method to adjust color brightness
                adjustColorBrightness(color, amount) {
                    // Convert hex to RGB
                    const hex = color.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    
                    // Adjust brightness
                    const newR = Math.max(0, Math.min(255, r + amount));
                    const newG = Math.max(0, Math.min(255, g + amount));
                    const newB = Math.max(0, Math.min(255, b + amount));
                    
                    // Convert back to hex
                    const toHex = (c) => {
                        const hex = c.toString(16);
                        return hex.length === 1 ? "0" + hex : hex;
                    };
                    
                    return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
                }
            }

            // --- Path Class for Animation Paths ---
            class AnimationPath {
                constructor(name, ownerObject = null) {
                    this.id = 'path_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    this.name = name || `Path ${Date.now()}`;
                    this.nodes = []; // Array of {x, y} points
                    this.closed = false; // Whether path connects back to start
                    this.color = '#4caf50'; // Green color for path
                    this.visible = true;
                    this.ownerObject = ownerObject; // Reference to the object this path belongs to
                }

                addNode(x, y) {
                    this.nodes.push({x, y});
                }

                removeLastNode() {
                    if (this.nodes.length > 0) {
                        this.nodes.pop();
                    }
                }

                removeNode(index) {
                    if (index >= 0 && index < this.nodes.length) {
                        this.nodes.splice(index, 1);
                    }
                }

                updateNode(index, x, y) {
                    if (index >= 0 && index < this.nodes.length) {
                        // Keep first node locked to object center
                        if (index === 0 && this.ownerObject) {
                            const center = this.ownerObject.getCenterPoint();
                            this.nodes[0] = {x: center.x, y: center.y};
                            return;
                        }

                        // Check if dragging last node close to first node for snapping
                        if (index === this.nodes.length - 1 && this.nodes.length > 2) {
                            const firstNode = this.nodes[0];
                            const dist = Math.sqrt(Math.pow(x - firstNode.x, 2) + Math.pow(y - firstNode.y, 2));
                            const snapThreshold = 20; // pixels
                            
                            if (dist < snapThreshold) {
                                // Snap to first node and close path
                                this.nodes[index].x = firstNode.x;
                                this.nodes[index].y = firstNode.y;
                                this.closed = true;
                                return;
                            } else {
                                this.closed = false;
                            }
                        }

                        this.nodes[index].x = x;
                        this.nodes[index].y = y;
                    }
                }

                // Check if a point is near a node (for selection)
                getNodeAt(x, y, threshold = 12) {
                    for (let i = 0; i < this.nodes.length; i++) {
                        const node = this.nodes[i];
                        const dist = Math.sqrt(Math.pow(x - node.x, 2) + Math.pow(y - node.y, 2));
                        if (dist <= threshold) {
                            return i;
                        }
                    }
                    return -1;
                }

                // Check if point is near the path line (for inserting nodes)
                getPathSegmentAt(x, y, threshold = 15) {
                    if (this.nodes.length < 2) return -1;

                    for (let i = 0; i < this.nodes.length - 1; i++) {
                        const p1 = this.nodes[i];
                        const p2 = this.nodes[i + 1];

                        // Calculate distance from point to line segment
                        const dist = this.pointToSegmentDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist <= threshold) {
                            return i; // Return index of segment start
                        }
                    }

                    // Check closing segment if path is closed
                    if (this.closed && this.nodes.length > 2) {
                        const p1 = this.nodes[this.nodes.length - 1];
                        const p2 = this.nodes[0];
                        const dist = this.pointToSegmentDistance(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist <= threshold) {
                            return this.nodes.length - 1;
                        }
                    }

                    return -1;
                }

                // Calculate distance from point to line segment
                pointToSegmentDistance(px, py, x1, y1, x2, y2) {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const lengthSquared = dx * dx + dy * dy;

                    if (lengthSquared === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);

                    let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
                    t = Math.max(0, Math.min(1, t));

                    const projX = x1 + t * dx;
                    const projY = y1 + t * dy;

                    return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
                }

                // Insert a node between two existing nodes
                insertNodeAt(x, y, afterIndex) {
                    if (afterIndex >= 0 && afterIndex < this.nodes.length) {
                        this.nodes.splice(afterIndex + 1, 0, {x, y});
                    }
                }

                closePath() {
                    this.closed = true;
                }

                openPath() {
                    this.closed = false;
                }

                reversePath() {
                    this.nodes.reverse();
                }

                // Get point on path at normalized position t (0 to 1)
                getPointAt(t) {
                    if (this.nodes.length < 2) return null;

                    // Update first node to object center if owner exists
                    if (this.ownerObject && this.nodes.length > 0) {
                        const center = this.ownerObject.getCenterPoint();
                        this.nodes[0] = {x: center.x, y: center.y};
                    }

                    const totalNodes = this.nodes.length;
                    const effectiveNodes = this.closed ? totalNodes : totalNodes - 1;

                    // Clamp t between 0 and 1
                    t = Math.max(0, Math.min(1, t));

                    // Calculate which segment we're on
                    const segmentFloat = t * effectiveNodes;
                    const segmentIndex = Math.floor(segmentFloat);
                    const segmentT = segmentFloat - segmentIndex;

                    // Get the two nodes for this segment
                    const node1 = this.nodes[segmentIndex % totalNodes];
                    const node2 = this.nodes[(segmentIndex + 1) % totalNodes];

                    // Use Catmull-Rom spline for smooth curves
                    if (this.nodes.length > 2) {
                        const node0 = this.nodes[(segmentIndex - 1 + totalNodes) % totalNodes];
                        const node3 = this.nodes[(segmentIndex + 2) % totalNodes];
                        return this.catmullRomSpline(node0, node1, node2, node3, segmentT);
                    } else {
                        // Linear interpolation for 2 nodes
                        return {
                            x: node1.x + (node2.x - node1.x) * segmentT,
                            y: node1.y + (node2.y - node1.y) * segmentT
                        };
                    }
                }

                // Catmull-Rom spline interpolation for smooth curves
                catmullRomSpline(p0, p1, p2, p3, t) {
                    const t2 = t * t;
                    const t3 = t2 * t;

                    const x = 0.5 * (
                        (2 * p1.x) +
                        (-p0.x + p2.x) * t +
                        (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                        (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3
                    );

                    const y = 0.5 * (
                        (2 * p1.y) +
                        (-p0.y + p2.y) * t +
                        (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                        (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3
                    );

                    return {x, y};
                }

                draw(ctx, isActive = false, selectedNodeIndex = -1) {
                    if (!this.visible) return;

                    // Always update first node to object center if owner exists
                    if (this.ownerObject && this.nodes.length > 0) {
                        const center = this.ownerObject.getCenterPoint();
                        this.nodes[0] = {x: center.x, y: center.y};
                    }

                    // If only 1 node, just show it
                    if (this.nodes.length === 1) {
                        ctx.save();
                        const node = this.nodes[0];
                        ctx.fillStyle = isActive ? '#ff9800' : this.color;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
                        ctx.fill();

                        // Pulsing ring to show it's waiting for more nodes
                        ctx.strokeStyle = isActive ? '#ff9800' : this.color;
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, 12 + Math.sin(Date.now() / 300) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                        return;
                    }

                    if (this.nodes.length < 2) return;

                    ctx.save();

                    // Draw thicker shadow for better visibility
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;

                    // Draw the path curve
                    ctx.strokeStyle = isActive ? '#ff9800' : this.color;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.setLineDash([8, 6]);

                    ctx.beginPath();

                    if (this.nodes.length === 2) {
                        // Simple line for 2 nodes
                        ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
                        ctx.lineTo(this.nodes[1].x, this.nodes[1].y);
                    } else {
                        // Smooth curve for 3+ nodes
                        const steps = 50;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const point = this.getPointAt(t);
                            if (i === 0) {
                                ctx.moveTo(point.x, point.y);
                            } else {
                                ctx.lineTo(point.x, point.y);
                            }
                        }
                    }

                    if (this.closed && this.nodes.length > 2) {
                        ctx.closePath();
                    }

                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw nodes
                    this.nodes.forEach((node, index) => {
                        const isSelected = index === selectedNodeIndex;

                        // Draw selection ring for selected node
                        if (isSelected) {
                            ctx.strokeStyle = '#ff9800';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(node.x, node.y, 10, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        // Draw node
                        ctx.fillStyle = isActive ? '#ff9800' : this.color;
                        ctx.beginPath();
                        ctx.arc(node.x, node.y, isSelected ? 8 : 6, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw node number
                        ctx.fillStyle = 'white';
                        ctx.font = isSelected ? 'bold 11px sans-serif' : 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText((index + 1).toString(), node.x, node.y);
                    });

                    ctx.restore();
                }
            }

            // --- Layer & Properties Panel Management ---
            function updateAccordionHeightForCategory(category) {
                // Removed problematic accordion height updates that were causing visual issues
                // The accordion now uses fixed max-height for stability
            }
            
            function updateLayerList() { 
                layerList.innerHTML = ''; 
                const sortedObjects = [...objects].sort((a, b) => b.zIndex - a.zIndex); 
                
                if (sortedObjects.length === 0) {
                    layersEmptyState.style.display = 'block';
                    layerList.style.display = 'none';
                    return;
                }
                
                layersEmptyState.style.display = 'none';
                layerList.style.display = 'block';
                
                sortedObjects.forEach((obj, index) => { 
                    const isTop = index === 0; 
                    const isBottom = index === sortedObjects.length - 1; 
                    const div = document.createElement('div');
                    div.className = `layer-item px-3 py-3 mb-2 rounded-md flex justify-between items-center cursor-pointer text-sm transition-all ${selectedObject?.id === obj.id ? 'selected' : ''}`;
                    div.dataset.id = obj.id;

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = obj.name;
                    nameSpan.className = 'flex-grow truncate mr-2 ml-1 font-medium text-sm overflow-hidden';
                    div.appendChild(nameSpan); 
                    
                    const controls = document.createElement('div');
                    controls.className = 'flex items-center gap-2'; 
                    
                    const upBtn = document.createElement('button'); 
                    upBtn.innerHTML = ''; 
                    upBtn.className = 'layer-item-button'; 
                    upBtn.disabled = isTop; 
                    upBtn.title = 'Move up'; 
                    upBtn.onclick = (e) => { e.stopPropagation(); moveObject(obj.id, 'up'); }; 
                    controls.appendChild(upBtn); 
                    
                    const downBtn = document.createElement('button'); 
                    downBtn.innerHTML = ''; 
                    downBtn.className = 'layer-item-button'; 
                    downBtn.disabled = isBottom; 
                    downBtn.title = 'Move down'; 
                    downBtn.onclick = (e) => { e.stopPropagation(); moveObject(obj.id, 'down'); }; 
                    controls.appendChild(downBtn); 
                    
                    const visibilityToggle = document.createElement('button'); 
                    visibilityToggle.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 616 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>';
                    visibilityToggle.className = `layer-item-button ${!obj.visible ? 'layer-visibility-hidden' : ''}`;
                    visibilityToggle.title = obj.visible ? 'Hide' : 'Show'; 
                    visibilityToggle.onclick = (e) => { 
                        e.stopPropagation(); 
                        obj.visible = !obj.visible; 
                        draw(); 
                        updateLayerList(); 
                    }; 
                    controls.appendChild(visibilityToggle); 
                    
                    div.appendChild(controls); 
                    div.onclick = () => { 
                        setSelectedObject(objects.find(o => o.id === obj.id)); 
                    }; 
                    layerList.appendChild(div); 
                }); 
            }
            function updatePropertiesPanel() {
                propertiesPanel.style.display = 'block';
                noSelectionProperties.style.display = 'none';
                textProperties.style.display = 'none';
                shapeProperties.style.display = 'none';
                transformProperties.style.display = 'none';
                imageProperties.style.display = 'none';
                speechProperties.style.display = 'none';
                const animationProperties = document.getElementById('animation-properties');
                const noSelectionMsg = document.getElementById('no-selection-message');
                // Always start hidden
                animationProperties.style.display = 'none';

                if (selectedObject) {
                    // Show transform properties for all objects
                    transformProperties.style.display = 'block';

                    // Show speech properties for all objects
                    speechProperties.style.display = 'block';

                    // Update speech mode radio buttons
                    const speechMode = selectedObject.speechMode || 'none';
                    speechModeRadios.forEach(radio => {
                        radio.checked = (radio.value === speechMode);
                    });

                    // Show/hide custom input based on mode
                    if (speechMode === 'custom') {
                        customSpeechInputContainer.classList.remove('hidden');
                        customSpeechText.value = selectedObject.customSpeechText || '';
                    } else {
                        customSpeechInputContainer.classList.add('hidden');
                    }
                    // Do not offer rotation for text objects
                    if (selectedObject.type === 'text') {
                        rotate90Btn.style.display = 'none';
                    } else {
                        rotate90Btn.style.display = '';
                    }
                    
                    if (selectedObject.type === 'text') { 
                        textProperties.style.display = 'block'; 
                        textContentInput.value = selectedObject.text; 
                        textColorInput.value = selectedObject.color; 
                        textSizeInput.value = selectedObject.size; 
                        // Set font dropdown based on current family
                        if (selectedObject.fontFamily?.includes('Atkinson')) textFontSelect.value = 'atkinson';
                        else if (selectedObject.fontFamily?.includes('Andika')) textFontSelect.value = 'andika';
                        else if (selectedObject.fontFamily?.includes('Noto Serif')) textFontSelect.value = 'serif';
                        else if (selectedObject.fontFamily?.startsWith('Inter')) textFontSelect.value = 'inter';
                        else if (selectedObject.fontFamily?.startsWith('system-ui')) textFontSelect.value = 'system';
                        else textFontSelect.value = 'luciole';
                        // Sync style toggles
                        textBoldToggle.classList.toggle('active', (selectedObject.fontWeight || 400) >= 600);
                        textBoldToggle.setAttribute('aria-pressed', ((selectedObject.fontWeight || 400) >= 600).toString());
                        textItalicToggle.classList.toggle('active', (selectedObject.fontStyle || 'normal') === 'italic');
                        textItalicToggle.setAttribute('aria-pressed', ((selectedObject.fontStyle || 'normal') === 'italic').toString());
                    } else if (selectedObject.type === 'shape') { 
                        shapeProperties.style.display = 'block'; 
                        shapeColorInput.value = selectedObject.color; 
                    } else if (selectedObject.type === 'image') {
                        imageProperties.style.display = 'block';
                        // Update flip button states
                        flipHorizontalBtn.classList.toggle('active', selectedObject.flipHorizontal || false);
                        flipVerticalBtn.classList.toggle('active', selectedObject.flipVertical || false);
                    }
                    // Show animation properties only for animatable types
                    const animatableTypes = ['text','shape','image'];
                    if (animatableTypes.includes(selectedObject.type)) {
                        animationProperties.style.display = 'block';
                        animationProperties.classList.remove('hidden');
                    }
                } else { 
                    noSelectionProperties.style.display = 'block'; 
                    if (objects.length === 0) {
                        noSelectionMsg.textContent = 'Add a visual target, shape, or text object to see its properties here.';
                    } else {
                        noSelectionMsg.textContent = 'Select an object on the canvas to see and edit its properties.';
                    }
                    animationProperties.style.display = 'none';
                } 
                
                // Update animation properties at the end to ensure proper sync
                updateAnimationProperties();
            }
            
            // Debounce timer for animation properties updates
            let animationUpdateTimeout = null;
            
            function updateAnimationProperties() {
                // Clear any pending updates
                if (animationUpdateTimeout) {
                    clearTimeout(animationUpdateTimeout);
                }
                
                // Use a small delay to batch updates and prevent accordion flicker
                animationUpdateTimeout = setTimeout(() => {
                    if (selectedObject) {
                        // Ensure animation properties exist with defaults
                        if (typeof selectedObject.animationDuration === 'undefined') {
                            selectedObject.animationDuration = 1.0;
                        }
                        if (typeof selectedObject.animationIntensity === 'undefined') {
                            selectedObject.animationIntensity = 5;
                        }
                        
                        // Update animation button selection
                        const animationButtons = document.querySelectorAll('.animation-type-btn');
                        animationButtons.forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.animation === (selectedObject.animationType || ''));
                        });
                        
                        animationDuration.value = selectedObject.animationDuration;
                        animationCycles.value = selectedObject.animationCycles || 1;
                        animationIntensity.value = selectedObject.animationIntensity;
                        
                        // Update text displays
                        const durVal = parseFloat(selectedObject.animationDuration);
                        durationValue.textContent = durVal <= 0.7 ? 'Fast' : durVal >= 2 ? 'Slow' : 'Medium';
                        const cyclesVal = parseInt(selectedObject.animationCycles || 1);
                        cyclesValue.textContent = cyclesVal + ' cycle' + (cyclesVal === 1 ? '' : 's');
                        const intVal = parseInt(selectedObject.animationIntensity);
                        intensityValue.textContent = intVal <= 3 ? 'Small' : intVal >= 7 ? 'Large' : 'Medium';
                        
                        // Show/hide animation settings based on selection
                        updateAnimationUIVisibility();
                        updateAnimationControlButton();

                        // Update animation trigger checkboxes and key selection
                        triggerOnPressChk.checked = selectedObject.triggerOnPress || false;
                        triggerOnKeyChk.checked = selectedObject.triggerOnKey || false;
                        triggerKeySelect.value = selectedObject.triggerKey || '';

                        // Show/hide key selection based on checkbox state
                        if (selectedObject.triggerOnKey) {
                            keySelectionContainer.classList.remove('hidden');
                        } else {
                            keySelectionContainer.classList.add('hidden');
                        }

                        // Update path animation UI
                        if (selectedObject.animationType === 'path') {
                            if (pathAnimationSettings) {
                                pathAnimationSettings.classList.remove('hidden');
                            }
                            // Show animation settings section
                            animationSettings.classList.remove('hidden');
                            // Show path controls, hide standard controls
                            if (standardAnimationControls) standardAnimationControls.classList.add('hidden');
                            if (pathAnimationControls) pathAnimationControls.classList.remove('hidden');
                            
                            // Show/hide clear path button based on whether path exists
                            const clearPathBtn = document.getElementById('clear-path-btn');
                            if (clearPathBtn) {
                                clearPathBtn.classList.toggle('hidden', !selectedObject.animationPath);
                            }

                            // Update path mode radio buttons
                            const pathModeRadios = document.querySelectorAll('input[name="path-mode"]');
                            pathModeRadios.forEach(radio => {
                                radio.checked = radio.value === (selectedObject.pathAnimationMode || 'to-end');
                            });

                            // Update path speed slider in main controls
                            if (pathSpeedMain) {
                                pathSpeedMain.value = selectedObject.pathAnimationSpeed || 1;
                            }
                            if (pathSpeedValueMain) {
                                const speedVal = selectedObject.pathAnimationSpeed || 1;
                                if (speedVal === 1) {
                                    pathSpeedValueMain.textContent = 'Normal';
                                } else if (speedVal < 1) {
                                    pathSpeedValueMain.textContent = speedVal.toFixed(2) + 'x (Slower)';
                                } else {
                                    pathSpeedValueMain.textContent = speedVal.toFixed(2) + 'x (Faster)';
                                }
                            }

                            // Update path cycles slider in main controls
                            if (pathCyclesMain) {
                                pathCyclesMain.value = selectedObject.animationCycles || 5;
                            }
                            if (pathCyclesValueMain) {
                                const cycles = selectedObject.animationCycles || 5;
                                pathCyclesValueMain.textContent = cycles + (cycles === 1 ? ' cycle' : ' cycles');
                            }
                        } else {
                            if (pathAnimationSettings) {
                                pathAnimationSettings.classList.add('hidden');
                            }
                            // Show standard controls, hide path controls
                            if (standardAnimationControls) standardAnimationControls.classList.remove('hidden');
                            if (pathAnimationControls) pathAnimationControls.classList.add('hidden');
                        }
                    } else {
                        // Clear all animation button selections when no object selected
                        const animationButtons = document.querySelectorAll('.animation-type-btn');
                        animationButtons.forEach(btn => btn.classList.remove('active'));
                        animationSettings.classList.add('hidden');
                        if (pathAnimationSettings) {
                            pathAnimationSettings.classList.add('hidden');
                        }
                    }
                    animationUpdateTimeout = null;
                }, 50); // 50ms debounce
            }
            
            function setSelectedObject(obj) { 
                selectedObject = obj; 
                draw(); 
                updateLayerList(); 
                updatePropertiesPanel(); 
                updateAnimationControlButton();
                updateAnimationTriggerPanel();
            }

            // --- UI Interaction ---
            function updateStatusIndicators() {
                // Map status IDs to their accordion button (assumes structure: indicator inside button span sibling)
                const mapping = [
                    { id: 'tools-status', buttonIndex: 0 },
                    { id: 'properties-status', buttonIndex: 1 },
                    { id: 'background-status', buttonIndex: 2 },
                    { id: 'layers-status', buttonIndex: 3 }
                ];

                mapping.forEach(m => {
                    const indicator = document.getElementById(m.id);
                    if (!indicator) return;
                    // Find nearest ancestor button
                    const btn = indicator.closest('button.accordion-button');
                    let isExpanded = false;
                    if (btn) {
                        isExpanded = btn.getAttribute('aria-expanded') === 'true';
                    }
                    indicator.className = `status-indicator ${isExpanded ? 'status-active' : 'status-drawer-closed'}`;
                });
            }
            
            toggleControlsBtn.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                mediaLibrary.classList.remove('open'); 
                controlsDrawer.classList.toggle('open'); 
                updateStatusIndicators();
            });
            
            toggleLibraryBtn.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                controlsDrawer.classList.remove('open'); 
                mediaLibrary.classList.toggle('open'); 
                updateStatusIndicators();
            });
            
            // Fullscreen toggle functionality
            fullscreenToggle.addEventListener('click', async (e) => {
                e.stopPropagation();

                try {
                    const elem = document.documentElement;

                    // Check for fullscreen across browser prefixes
                    const isFullscreen = document.fullscreenElement ||
                                        document.webkitFullscreenElement ||
                                        document.mozFullScreenElement ||
                                        document.msFullscreenElement;

                    if (!isFullscreen) {
                        // Enter fullscreen with vendor prefixes for cross-browser support
                        if (elem.requestFullscreen) {
                            await elem.requestFullscreen({ navigationUI: "hide" });
                        } else if (elem.webkitRequestFullscreen) {
                            await elem.webkitRequestFullscreen();
                        } else if (elem.mozRequestFullScreen) {
                            await elem.mozRequestFullScreen();
                        } else if (elem.msRequestFullscreen) {
                            await elem.msRequestFullscreen();
                        }
                        fullscreenEnterIcon.classList.add('hidden');
                        fullscreenExitIcon.classList.remove('hidden');
                        fullscreenText.textContent = 'Exit Fullscreen';
                        fullscreenToggle.classList.add('active');
                    } else {
                        // Exit fullscreen with vendor prefixes
                        if (document.exitFullscreen) {
                            await document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            await document.webkitExitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            await document.mozCancelFullScreen();
                        } else if (document.msExitFullscreen) {
                            await document.msExitFullscreen();
                        }
                        fullscreenEnterIcon.classList.remove('hidden');
                        fullscreenExitIcon.classList.add('hidden');
                        fullscreenText.textContent = 'Enter Fullscreen';
                        fullscreenToggle.classList.remove('active');
                    }
                } catch (error) {
                    console.log('Fullscreen not supported or failed:', error);
                }
            });

            // Listen for fullscreen changes (with vendor prefixes)
            ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(event => {
                document.addEventListener(event, () => {
                    const isFullscreen = document.fullscreenElement ||
                                        document.webkitFullscreenElement ||
                                        document.mozFullScreenElement ||
                                        document.msFullscreenElement;

                    if (!isFullscreen) {
                        fullscreenEnterIcon.classList.remove('hidden');
                        fullscreenExitIcon.classList.add('hidden');
                        fullscreenText.textContent = 'Fullscreen';
                        fullscreenToggle.classList.remove('active');
                    } else {
                        fullscreenEnterIcon.classList.add('hidden');
                        fullscreenExitIcon.classList.remove('hidden');
                        fullscreenText.textContent = 'Exit';
                        fullscreenToggle.classList.add('active');
                    }
                });
            });

            // Theme toggle functionality
            const themeToggle = document.getElementById('theme-toggle');
            const themeLightIcon = document.getElementById('theme-light-icon');
            const themeDarkIcon = document.getElementById('theme-dark-icon');
            const themeText = document.getElementById('theme-text');
            const htmlElement = document.documentElement;

            // Check for saved theme preference or default to dark
            const currentTheme = localStorage.getItem('theme') || 'dark';
            if (currentTheme === 'light') {
                htmlElement.classList.remove('dark');
                themeLightIcon.classList.add('hidden');
                themeDarkIcon.classList.remove('hidden');
                themeText.textContent = 'Dark';
            }

            themeToggle.addEventListener('click', () => {
                if (htmlElement.classList.contains('dark')) {
                    // Switch to light mode
                    htmlElement.classList.remove('dark');
                    themeLightIcon.classList.add('hidden');
                    themeDarkIcon.classList.remove('hidden');
                    themeText.textContent = 'Dark';
                    localStorage.setItem('theme', 'light');
                } else {
                    // Switch to dark mode
                    htmlElement.classList.add('dark');
                    themeLightIcon.classList.remove('hidden');
                    themeDarkIcon.classList.add('hidden');
                    themeText.textContent = 'Light';
                    localStorage.setItem('theme', 'dark');
                }
            });

            // Export Scene button (clean snapshot without selection box)
            const saveImageBtn = document.getElementById('save-image-btn');
            saveImageBtn.addEventListener('click', () => {
                try {
                    const prevSelected = selectedObject;
                    // Hide selection box
                    selectedObject = null;
                    draw();
                    requestAnimationFrame(() => {
                        canvas.toBlob((blob) => {
                            // Restore selection
                            selectedObject = prevSelected;
                            draw();
                            if (!blob) {
                                alert('Failed to create image.');
                                return;
                            }
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                            link.download = `gaze-tracker-image-${timestamp}.png`;
                            link.href = url;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                            saveImageBtn.classList.add('active');
                            setTimeout(()=> saveImageBtn.classList.remove('active'), 900);
                        }, 'image/png', 1.0);
                    });
                } catch (err) {
                    console.error('Save image failed', err);
                    alert('Failed to save image.');
                }
            });
            
            accordionButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const isExpanded = button.getAttribute('aria-expanded') === 'true';
                    button.setAttribute('aria-expanded', !isExpanded);
            
                    // The content is the next sibling of the button's parent header
                    const content = button.parentElement.nextElementSibling;
                    if (content && content.classList.contains('accordion-content')) {
                        if (!isExpanded) {
                            // Expand: use a stable max-height approach
                            content.style.maxHeight = '2000px'; // Large enough for any content
                        } else {
                            // Collapse
                            content.style.maxHeight = '0px';
                        }
                    }
                    // After toggle, refresh indicator lights
                    updateStatusIndicators();
                });
            
                // Set initial state for accordions that are open by default
                if (button.getAttribute('aria-expanded') === 'true') {
                    const content = button.parentElement.nextElementSibling;
                    if (content) {
                       content.style.maxHeight = '2000px'; // Stable initial height
                    }
                }
                // Set initial indicators once
                updateStatusIndicators();
            });

            controlsDrawer.addEventListener('click', e => e.stopPropagation());
            mediaLibrary.addEventListener('click', e => e.stopPropagation());

            // --- Auto Load Settings Panel Logic ---
            const mediaSettingsToggle = document.getElementById('media-settings-toggle');
            const mediaSettingsPanel = document.getElementById('media-settings-panel');
            const autoLoadVisualTargetsChk = document.getElementById('auto-load-visual-targets');
            const autoLoadBackgroundsChk = document.getElementById('auto-load-backgrounds');
            const autoLoadForegroundsChk = document.getElementById('auto-load-foregrounds');
            const pickVTBtn = document.getElementById('pick-vt-folder');
            const pickBGBtn = document.getElementById('pick-bg-folder');
            const pickFGBtn = document.getElementById('pick-fg-folder');
            const clearVTBtn = document.getElementById('clear-vt-folder');
            const clearBGBtn = document.getElementById('clear-bg-folder');
            const clearFGBtn = document.getElementById('clear-fg-folder');
            const runAutoLoadNowBtn = document.getElementById('run-auto-load-now');
            
            // New UI elements (keeping only essential ones)
            
            // File management elements
            const viewAutoLoadedBtn = document.getElementById('view-auto-loaded-files');
            const clearAllAutoLoadedBtn = document.getElementById('clear-all-auto-loaded');
            const autoLoadedInfo = document.getElementById('auto-loaded-info');
            
            // Toast notification elements
            const autoLoadToast = document.getElementById('auto-load-toast');
            const toastIcon = document.getElementById('toast-icon');
            const toastTitle = document.getElementById('toast-title');
            const toastMessage = document.getElementById('toast-message');
            const toastProgressContainer = document.getElementById('toast-progress-container');
            const toastProgressBar = document.getElementById('toast-progress-bar');
            const toastProgressText = document.getElementById('toast-progress-text');
            const toastClose = document.getElementById('toast-close');
            

            const AUTO_LOAD_KEY = 'autoLoadFolders.v1';
            let autoLoadConfig = { visualTargets: null, backgrounds: null, foregrounds: null, enabled: { visualTargets:false, backgrounds:false, foregrounds:false } };

            // TTS Settings Storage -----------------
            const TTS_SETTINGS_KEY = 'ttsSettings.v1';
            const saveTTSSettingsCheckbox = document.getElementById('save-tts-settings');

            function getTTSSettingsEnabled() {
                return saveTTSSettingsCheckbox?.checked || false;
            }

            function saveTTSSettings(filename, settings) {
                if (!getTTSSettingsEnabled() || !filename) return;
                try {
                    const stored = localStorage.getItem(TTS_SETTINGS_KEY);
                    const allSettings = stored ? JSON.parse(stored) : {};
                    allSettings[filename] = settings;
                    localStorage.setItem(TTS_SETTINGS_KEY, JSON.stringify(allSettings));
                } catch(e) {
                    console.warn('Failed to save TTS settings', e);
                }
            }

            function loadTTSSettings(filename) {
                if (!getTTSSettingsEnabled() || !filename) return null;
                try {
                    const stored = localStorage.getItem(TTS_SETTINGS_KEY);
                    if (!stored) return null;
                    const allSettings = JSON.parse(stored);
                    return allSettings[filename] || null;
                } catch(e) {
                    console.warn('Failed to load TTS settings', e);
                    return null;
                }
            }

            function applyTTSSettings(obj, filename) {
                if (!obj || !filename) return;
                const settings = loadTTSSettings(filename);
                if (settings) {
                    obj.speechMode = settings.speechMode || 'none';
                    obj.customSpeechText = settings.customSpeechText || '';
                }
            }

            // Save TTS settings when speech properties change
            function saveTTSSettingsForObject(obj) {
                if (!obj || obj.type !== 'image') return;
                const filename = obj.img?.dataset?.name;
                if (!filename) return;

                const settings = {
                    speechMode: obj.speechMode || 'none',
                    customSpeechText: obj.customSpeechText || '',
                    label: obj.name || filename
                };
                saveTTSSettings(filename, settings);
            }

            // Persistent Directory Handle Storage via IndexedDB -----------------
            const supportsFSAccess = 'showDirectoryPicker' in window && 'indexedDB' in window;
            let handlesDBPromise = null;
            function getHandlesDB(){
                if(!supportsFSAccess) return Promise.resolve(null);
                if(handlesDBPromise) return handlesDBPromise;
                handlesDBPromise = new Promise((resolve, reject)=>{
                    const req = indexedDB.open('autoLoadHandlesDB',1);
                    req.onupgradeneeded = e => {
                        const db = req.result;
                        if(!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
                    };
                    req.onsuccess = ()=> resolve(req.result);
                    req.onerror = ()=> reject(req.error);
                });
                return handlesDBPromise;
            }
            async function saveHandlePersistent(key, handle){
                const db = await getHandlesDB(); if(!db) return;
                return new Promise((resolve,reject)=>{
                    const tx = db.transaction('handles','readwrite');
                    tx.objectStore('handles').put(handle, key);
                    tx.oncomplete = ()=> resolve();
                    tx.onerror = ()=> reject(tx.error);
                });
            }
            async function deleteHandlePersistent(key){
                const db = await getHandlesDB(); if(!db) return;
                return new Promise((resolve,reject)=>{
                    const tx = db.transaction('handles','readwrite');
                    tx.objectStore('handles').delete(key);
                    tx.oncomplete = ()=> resolve();
                    tx.onerror = ()=> reject(tx.error);
                });
            }
            async function loadPersistentHandles(){
                const db = await getHandlesDB(); if(!db) return;
                await Promise.all(['visualTargets','backgrounds','foregrounds'].map(key => new Promise((resolve)=>{
                    const tx = db.transaction('handles','readonly');
                    const req = tx.objectStore('handles').get(key);
                    req.onsuccess = ()=> {
                        const handle = req.result;
                        if(handle){
                            if(!autoLoadConfig[key]) autoLoadConfig[key] = { name: handle.name || (autoLoadConfig[key]?.name)|| 'Folder', handle };
                            else autoLoadConfig[key].handle = handle;
                        }
                        resolve();
                    };
                    req.onerror = ()=> resolve();
                })));
            }
            async function ensurePermission(dirHandle){
                if(!dirHandle) return false;
                try {
                    let perm = await dirHandle.queryPermission({mode:'read'});
                    if(perm === 'granted') return true;
                    if(perm === 'prompt') {
                        perm = await dirHandle.requestPermission({mode:'read'});
                        return perm === 'granted';
                    }
                } catch(e){ console.warn('Permission check failed', e); }
                return false;
            }

            function loadAutoLoadConfig() {
                try {
                    const raw = localStorage.getItem(AUTO_LOAD_KEY);
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        if (parsed && parsed.enabled) autoLoadConfig = parsed;
                    }
                } catch(e) { console.warn('Failed to parse auto load config', e); }
            }
            function saveAutoLoadConfig() {
                localStorage.setItem(AUTO_LOAD_KEY, JSON.stringify(autoLoadConfig));
            }
            function updateAutoLoadUI(skipPermissionChecks = false) {
                const categories = ['visualTargets', 'backgrounds', 'foregrounds'];

                // Check if any enabled folders exist
                let hasEnabledFolders = false;

                categories.forEach(key => {
                    const prefix = key === 'visualTargets' ? 'vt' : key === 'backgrounds' ? 'bg' : 'fg';
                    const checkbox = document.getElementById(`auto-load-${key.replace('Targets', '-targets')}`);
                    const indicator = document.getElementById(`${prefix}-status-indicator`);
                    const fileCount = document.getElementById(`${prefix}-file-count`);
                    const folderInfo = document.getElementById(`${prefix}-folder-info`);
                    const clearBtn = document.getElementById(`clear-${prefix}-folder`);

                    const config = autoLoadConfig[key];
                    const enabled = autoLoadConfig.enabled[key];

                    // Check if this folder is enabled and has a handle
                    if (enabled && config && config.handle) {
                        hasEnabledFolders = true;
                    }

                    // Update checkbox
                    if (checkbox) checkbox.checked = enabled && !!config;

                    // Update status indicator
                    if (indicator) {
                        indicator.className = 'w-3 h-3 rounded-full';
                        if (config && config.handle) {
                            indicator.classList.add('bg-green-500');
                            indicator.title = 'Folder connected';
                        } else {
                            indicator.classList.add('bg-slate-500');
                            indicator.title = 'No folder selected';
                        }
                    }

                    // Update folder info
                    if (folderInfo) {
                        if (config && config.name) {
                            folderInfo.textContent = ` ${config.name}`;
                            folderInfo.classList.remove('text-slate-400');
                            folderInfo.classList.add('text-slate-300');
                        } else {
                            folderInfo.textContent = 'No folder selected';
                            folderInfo.classList.remove('text-slate-300');
                            folderInfo.classList.add('text-slate-400');
                        }
                    }

                    // Show/hide file count
                    if (fileCount) {
                        if (config && config.handle) {
                            // Update file counts, optionally skipping permission checks
                            updateFileCount(key, prefix, skipPermissionChecks);
                        } else {
                            fileCount.classList.add('hidden');
                        }
                    }

                    // Update clear button
                    if (clearBtn) {
                        clearBtn.classList.toggle('inactive', !config);
                    }
                });

                // Show/hide the quick auto-load button at the top of Media Library
                const quickBtn = document.getElementById('auto-load-quick-btn');
                if (quickBtn) {
                    if (hasEnabledFolders) {
                        quickBtn.classList.remove('hidden');
                    } else {
                        quickBtn.classList.add('hidden');
                    }
                }
            }
            
            async function updateFileCount(key, prefix, skipPermissionCheck = false) {
                const config = autoLoadConfig[key];
                const fileCountEl = document.getElementById(`${prefix}-file-count`);
                const indicator = document.getElementById(`${prefix}-status-indicator`);
                
                if (!config || !config.handle || !fileCountEl) return;
                
                try {
                    // Skip permission checks on startup to avoid prompts
                    if (!skipPermissionCheck) {
                        const hasPermission = await ensurePermission(config.handle);
                        if (!hasPermission) {
                            // Update indicator to show permission needed
                            if (indicator) {
                                indicator.className = 'w-3 h-3 rounded-full bg-yellow-500';
                                indicator.title = 'Permission needed - click to load files';
                            }
                            const folderInfo = document.getElementById(`${prefix}-folder-info`);
                            if (folderInfo) {
                                folderInfo.textContent = ` ${config.name} (click to grant permission)`;
                                folderInfo.classList.remove('text-slate-300');
                                folderInfo.classList.add('text-yellow-400');
                            }
                            return;
                        }
                    }
                    
                    // If skipping permission check, just show folder as connected
                    if (skipPermissionCheck) {
                        if (indicator) {
                            indicator.className = 'w-3 h-3 rounded-full bg-green-500';
                            indicator.title = 'Folder connected';
                        }
                        fileCountEl.textContent = 'Ready to load';
                        fileCountEl.classList.remove('hidden');
                        return;
                    }
                    
                    // Get file extensions for this category
                    const extensions = getExtensionsForCategory(key);
                    const files = await loadDirectoryEntries(config.handle, extensions);
                    
                    // Update file count
                    fileCountEl.textContent = `${files.length} file${files.length !== 1 ? 's' : ''}`;
                    fileCountEl.classList.remove('hidden');
                    
                    // Update indicator color based on file count
                    if (indicator) {
                        if (files.length > 0) {
                            indicator.className = 'w-3 h-3 rounded-full bg-green-500';
                            indicator.title = `${files.length} files ready`;
                        } else {
                            indicator.className = 'w-3 h-3 rounded-full bg-orange-500';
                            indicator.title = 'No supported files found';
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to count files for ${key}:`, error);
                    if (indicator) {
                        indicator.className = 'w-3 h-3 rounded-full bg-red-500';
                        indicator.title = 'Error accessing folder';
                    }
                }
            }
            
            function getExtensionsForCategory(key) {
                switch (key) {
                    case 'visualTargets':
                        return ['.png','.jpg','.jpeg','.gif','.webp','.mp4','.mov','.avi','.mkv','.webm','.3gp','.wmv','.flv','.m4v'];
                    case 'backgrounds':
                    case 'foregrounds':
                        return ['.png','.jpg','.jpeg','.gif','.webp'];
                    default:
                        return [];
                }
            }
            
            // Toast notification system
            function showToast(title, message, type = 'info', showProgress = false) {
                if (!autoLoadToast) return;
                
                // Set icon based on type
                const iconSvg = {
                    'info': '<svg class="w-5 h-5 text-blue-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>',
                    'success': '<svg class="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>',
                    'error': '<svg class="w-5 h-5 text-red-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>',
                    'warning': '<svg class="w-5 h-5 text-yellow-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>'
                };
                
                toastIcon.innerHTML = iconSvg[type] || iconSvg['info'];
                toastTitle.textContent = title;
                toastMessage.textContent = message;
                
                if (showProgress) {
                    toastProgressContainer.classList.remove('hidden');
                    toastProgressBar.style.width = '0%';
                    toastProgressText.textContent = '';
                } else {
                    toastProgressContainer.classList.add('hidden');
                }
                
                autoLoadToast.classList.remove('hidden');
                
                // Auto-hide for success and info messages (unless showing progress)
                if (!showProgress && (type === 'success' || type === 'info')) {
                    setTimeout(() => hideToast(), 5000);
                }
            }
            
            function updateToastProgress(progress, text = '') {
                if (toastProgressBar && toastProgressText) {
                    toastProgressBar.style.width = `${Math.max(0, Math.min(100, progress))}%`;
                    toastProgressText.textContent = text;
                }
            }
            
            function hideToast() {
                if (autoLoadToast) {
                    autoLoadToast.classList.add('hidden');
                    toastProgressContainer.classList.add('hidden');
                }
            }
            
            // File management functions
            function showAutoLoadedFilesInfo() {
                const allAutoLoaded = MediaLibrary.getAllAutoLoadedFiles();
                
                if (allAutoLoaded.length === 0) {
                    autoLoadedInfo.textContent = 'No auto-loaded files found.';
                    autoLoadedInfo.classList.remove('hidden');
                    return;
                }
                
                const categoryCount = {};
                allAutoLoaded.forEach(item => {
                    if (!categoryCount[item.category]) {
                        categoryCount[item.category] = 0;
                    }
                    categoryCount[item.category]++;
                });
                
                const infoText = Object.entries(categoryCount)
                    .map(([category, count]) => {
                        const categoryName = category === 'visualTargets' ? 'Visual Targets' : 
                                           category === 'backgrounds' ? 'Backgrounds' : 'Foregrounds';
                        return `${categoryName}: ${count}`;
                    })
                    .join(' | ');
                
                autoLoadedInfo.textContent = `Auto-loaded files: ${infoText} (Total: ${allAutoLoaded.length})`;
                autoLoadedInfo.classList.remove('hidden');
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    autoLoadedInfo.classList.add('hidden');
                }, 10000);
            }
            
            function clearAllAutoLoadedFiles() {
                const allAutoLoaded = MediaLibrary.getAllAutoLoadedFiles();
                
                if (allAutoLoaded.length === 0) {
                    showToast('No Files to Clear', 'No auto-loaded files found.', 'info');
                    return;
                }
                
                if (!confirm(`This will remove ${allAutoLoaded.length} auto-loaded files from the media library. Continue?`)) {
                    return;
                }
                
                let totalCleared = 0;
                Object.keys(MediaLibrary.assets).forEach(category => {
                    const cleared = MediaLibrary.clearAutoLoadedFiles(category);
                    totalCleared += cleared;
                });
                
                // Update media library display
                MediaLibrary.updateView();
                
                showToast('Files Cleared', `Removed ${totalCleared} auto-loaded files from the media library.`, 'success');
                
                // Update file counts
                setTimeout(() => {
                    updateAutoLoadUI();
                }, 500);
            }
            async function refreshPermissionStates(){
                // Update status indicators and folder info based on permissions
                for (const key of ['visualTargets','backgrounds','foregrounds']){
                    const entry = autoLoadConfig[key];
                    if(entry && entry.handle){
                        const granted = await ensurePermission(entry.handle);
                        const prefix = key === 'visualTargets' ? 'vt' : key === 'backgrounds' ? 'bg' : 'fg';
                        const indicator = document.getElementById(`${prefix}-status-indicator`);
                        const folderInfo = document.getElementById(`${prefix}-folder-info`);
                        
                        if(!granted){
                            if (indicator) {
                                indicator.className = 'w-3 h-3 rounded-full bg-yellow-500';
                                indicator.title = 'Permission needed';
                            }
                            if (folderInfo) {
                                folderInfo.textContent = ` ${entry.name || 'Folder'} (permission needed)`;
                                folderInfo.classList.remove('text-slate-300');
                                folderInfo.classList.add('text-yellow-400');
                            }
                        }
                    }
                }
                updateAutoLoadUI();
            }
            async function pickDirectoryFor(key) {
                if (!window.showDirectoryPicker) {
                    showToast('Browser Not Supported', 'Your browser does not support directory access. Use a Chromium-based browser.', 'error');
                    return;
                }
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    autoLoadConfig[key] = { name: dirHandle.name, handle: dirHandle }; // Persist handle in IndexedDB
                    autoLoadConfig.enabled[key] = true; // Always enable when user picks a folder
                    
                    // Save and update UI
                    saveHandlePersistent(key, dirHandle).catch(()=>{});
                    saveAutoLoadConfig();
                    updateAutoLoadUI(); // Check permissions now since user actively selected folder
                    
                    // Show success feedback
                    const categoryName = key === 'visualTargets' ? 'Visual Targets' : 
                                       key === 'backgrounds' ? 'Backgrounds' : 'Foregrounds';
                    showToast('Folder Connected', `${categoryName} folder "${dirHandle.name}" has been connected successfully.`, 'success');
                    
                } catch(e) { 
                    if (e.name !== 'AbortError') {
                        console.warn('Folder pick cancelled/failed', e);
                        showToast('Folder Selection Failed', 'Unable to select folder. Please try again.', 'error');
                    }
                }
            }
            // Legacy placeholder retained (no-op)
            function saveHandlesTransient(){ }

            async function loadDirectoryEntries(dirHandle, filters) {
                if (!dirHandle) return [];
                const entries = [];
                try {
                    for await (const [name, handle] of dirHandle.entries()) {
                        if (handle.kind === 'file') {
                            const lower = name.toLowerCase();
                            if (filters.some(f=> lower.endsWith(f))) {
                                const file = await handle.getFile();
                                entries.push(file);
                            }
                        }
                    }
                } catch(e) { console.warn('Directory read failed', e); }
                return entries;
            }
            async function runAutoLoad(isUserInitiated = false) {
                const categories = [
                    { key: 'visualTargets', handle: autoLoadConfig.visualTargets?.handle, enabled: autoLoadConfig.enabled.visualTargets, extensions: ['.png','.jpg','.jpeg','.gif','.webp','.mp4','.mov','.avi','.mkv','.webm','.3gp','.wmv','.flv','.m4v'] },
                    { key: 'backgrounds', handle: autoLoadConfig.backgrounds?.handle, enabled: autoLoadConfig.enabled.backgrounds, extensions: ['.png','.jpg','.jpeg','.gif','.webp'] },
                    { key: 'foregrounds', handle: autoLoadConfig.foregrounds?.handle, enabled: autoLoadConfig.enabled.foregrounds, extensions: ['.png','.jpg','.jpeg','.gif','.webp'] }
                ];

                const enabledCategories = categories.filter(cat => cat.enabled && cat.handle);
                if (enabledCategories.length === 0) {
                    if (isUserInitiated) {
                        showToast('No Folders Selected', 'Please select and enable folders before running auto-load.', 'warning');
                    }
                    return;
                }

                if (isUserInitiated) {
                    showToast('Auto-Loading Files', 'Checking permissions and loading files...', 'info', true);
                }

                // Check for permissions and request if necessary
                let permissionIssues = [];
                for (const cat of enabledCategories) {
                    const hasPermission = await ensurePermission(cat.handle);
                    if (!hasPermission) {
                        if (isUserInitiated) {
                            try {
                                await cat.handle.requestPermission({ mode: 'read' });
                            } catch (e) {
                                permissionIssues.push(cat.key);
                            }
                        } else {
                            permissionIssues.push(cat.key);
                        }
                    }
                }

                if (permissionIssues.length > 0 && isUserInitiated) {
                    const folderNames = permissionIssues.map(key => {
                        switch(key) {
                            case 'visualTargets': return 'Visual Targets';
                            case 'backgrounds': return 'Backgrounds';
                            case 'foregrounds': return 'Foregrounds';
                            default: return key;
                        }
                    }).join(', ');
                    showToast('Permission Required', `Permission needed for: ${folderNames}. Some folders will be skipped.`, 'warning');
                }

                let totalLoaded = 0;
                let processedCategories = 0;
                
                for (const cat of enabledCategories) {
                    try {
                        // Final check, in case permission was just denied
                        if (await ensurePermission(cat.handle)) {
                            const files = await loadDirectoryEntries(cat.handle, cat.extensions);
                            if (files.length > 0) {
                                const folderName = autoLoadConfig[cat.key]?.name || 'Auto-loaded folder';
                                await handleFiles(files, cat.key, true, folderName);
                                totalLoaded += files.length;
                            }
                        }
                    } catch (e) {
                        console.warn(`Failed to load ${cat.key}:`, e);
                        if (isUserInitiated) {
                            const categoryName = cat.key === 'visualTargets' ? 'Visual Targets' : 
                                               cat.key === 'backgrounds' ? 'Backgrounds' : 'Foregrounds';
                            showToast('Load Error', `Failed to load files from ${categoryName} folder.`, 'error');
                        }
                    }
                    
                    processedCategories++;
                    if (isUserInitiated) {
                        updateToastProgress((processedCategories / enabledCategories.length) * 100, 
                                          `Processed ${processedCategories}/${enabledCategories.length} folders`);
                    }
                }

                if (isUserInitiated) {
                    setTimeout(() => {
                        hideToast();
                        if (totalLoaded > 0) {
                            showToast('Loading Complete', `Successfully loaded ${totalLoaded} files!`, 'success');
                        } else {
                            showToast('No Files Loaded', 'Make sure folders contain supported files and permissions are granted.', 'warning');
                        }
                    }, 500);
                }
                
                // Update file counts after loading
                setTimeout(() => {
                    updateAutoLoadUI(); // Don't skip permission checks after user-initiated loading
                }, 1000);
            }

            // mediaSettingsToggle click handler removed - now handled by generic accordion handler
            autoLoadVisualTargetsChk?.addEventListener('change', e => { autoLoadConfig.enabled.visualTargets = e.target.checked; saveAutoLoadConfig(); });
            autoLoadBackgroundsChk?.addEventListener('change', e => { autoLoadConfig.enabled.backgrounds = e.target.checked; saveAutoLoadConfig(); });
            autoLoadForegroundsChk?.addEventListener('change', e => { autoLoadConfig.enabled.foregrounds = e.target.checked; saveAutoLoadConfig(); });
            pickVTBtn?.addEventListener('click', () => pickDirectoryFor('visualTargets'));
            pickBGBtn?.addEventListener('click', () => pickDirectoryFor('backgrounds'));
            pickFGBtn?.addEventListener('click', () => pickDirectoryFor('foregrounds'));
            clearVTBtn?.addEventListener('click', () => { 
                autoLoadConfig.visualTargets=null; 
                autoLoadConfig.enabled.visualTargets=false; 
                deleteHandlePersistent('visualTargets').catch(()=>{}); 
                saveAutoLoadConfig(); 
                updateAutoLoadUI(); 
            });
            clearBGBtn?.addEventListener('click', () => { 
                autoLoadConfig.backgrounds=null; 
                autoLoadConfig.enabled.backgrounds=false; 
                deleteHandlePersistent('backgrounds').catch(()=>{}); 
                saveAutoLoadConfig(); 
                updateAutoLoadUI(); 
            });
            clearFGBtn?.addEventListener('click', () => { 
                autoLoadConfig.foregrounds=null; 
                autoLoadConfig.enabled.foregrounds=false; 
                deleteHandlePersistent('foregrounds').catch(()=>{}); 
                saveAutoLoadConfig(); 
                updateAutoLoadUI(); 
            });
            runAutoLoadNowBtn?.addEventListener('click', () => runAutoLoad(true));

            // Quick auto-load button at top of Media Library
            const autoLoadQuickBtn = document.getElementById('auto-load-quick-btn');
            autoLoadQuickBtn?.addEventListener('click', () => runAutoLoad(true));

            // File management event listeners
            viewAutoLoadedBtn?.addEventListener('click', showAutoLoadedFilesInfo);
            clearAllAutoLoadedBtn?.addEventListener('click', clearAllAutoLoadedFiles);
            
            // Toast notification close button
            toastClose?.addEventListener('click', hideToast);

            function updateImportButtonVisibility(){
                // This function is no longer needed but kept to avoid breaking other parts of the code
            }

            loadAutoLoadConfig();
            updateAutoLoadUI(true); // Skip permission checks on startup
            // Load any persisted handles and update UI without auto-running
            loadPersistentHandles().then(()=> {
                // Don't check permissions or auto-run on startup to avoid annoying prompts
                // refreshPermissionStates(); // Commented out to prevent startup permission prompts
                updateAutoLoadUI(true); // Just update the UI without permission checks
            });

            // Load TTS settings checkbox state
            const TTS_CHECKBOX_KEY = 'saveTTSSettingsEnabled';
            if (saveTTSSettingsCheckbox) {
                const savedState = localStorage.getItem(TTS_CHECKBOX_KEY);
                if (savedState !== null) {
                    saveTTSSettingsCheckbox.checked = savedState === 'true';
                }
                // Save checkbox state when changed
                saveTTSSettingsCheckbox.addEventListener('change', (e) => {
                    localStorage.setItem(TTS_CHECKBOX_KEY, e.target.checked);
                });
            }

            // --- Cache Management ---
            const clearAppCacheBtn = document.getElementById('clear-app-cache');
            const checkAppVersionBtn = document.getElementById('check-app-version');
            const versionInfo = document.getElementById('version-info');
            
            clearAppCacheBtn?.addEventListener('click', async () => {
                const button = clearAppCacheBtn;
                const originalText = button.textContent;
                
                try {
                    button.textContent = 'Clearing...';
                    button.disabled = true;
                    
                    // Clear all caches
                    if ('caches' in window) {
                        const cacheNames = await caches.keys();
                        await Promise.all(cacheNames.map(name => caches.delete(name)));
                    }
                    
                    // Clear service worker cache via message
                    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                        const messageChannel = new MessageChannel();
                        messageChannel.port1.onmessage = (event) => {
                            if (event.data.success) {
                                console.log('Service worker cache cleared');
                            }
                        };
                        navigator.serviceWorker.controller.postMessage(
                            { type: 'CLEAR_CACHE' }, 
                            [messageChannel.port2]
                        );
                    }
                    
                    // Show success message
                    button.textContent = 'Cache Cleared!';
                    button.classList.remove('upload-button');
                    button.classList.add('delete-button');
                    
                    // Reload after brief delay
                    setTimeout(() => {
                        window.location.reload(true);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Cache clearing failed:', error);
                    button.textContent = 'Error - Try Ctrl+Shift+R';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 3000);
                }
            });
            
            checkAppVersionBtn?.addEventListener('click', async () => {
                const currentVersion = APP_VERSION;
                const storedVersion = localStorage.getItem(VERSION_KEY) || 'unknown';
                const lastUpdate = localStorage.getItem('lastForceReload');
                
                let serviceWorkerVersion = 'not available';
                
                // Try to get service worker version
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    try {
                        const messageChannel = new MessageChannel();
                        messageChannel.port1.onmessage = (event) => {
                            serviceWorkerVersion = event.data.version || 'unknown';
                            updateVersionDisplay();
                        };
                        navigator.serviceWorker.controller.postMessage(
                            { type: 'GET_VERSION' }, 
                            [messageChannel.port2]
                        );
                        
                        // Fallback timeout
                        setTimeout(updateVersionDisplay, 1000);
                    } catch (e) {
                        updateVersionDisplay();
                    }
                } else {
                    updateVersionDisplay();
                }
                
                function updateVersionDisplay() {
                    versionInfo.classList.remove('hidden');
                    const lastUpdateDate = lastUpdate ? new Date(parseInt(lastUpdate)).toLocaleDateString() : 'Never';
                    const statusIcon = storedVersion === currentVersion ? '' : '';
                    const statusText = storedVersion === currentVersion ? 'Up to date' : 'Version mismatch';
                    
                    versionInfo.innerHTML = `
                        <div class="font-medium mb-1" style="color: var(--md-primary);"> Version Status</div>
                        <div class="grid grid-cols-2 gap-1 text-xs">
                            <div style="color: var(--md-on-surface-variant);">Current:</div><div style="color: var(--md-on-surface);">${currentVersion}</div>
                            <div style="color: var(--md-on-surface-variant);">Stored:</div><div style="color: var(--md-on-surface);">${storedVersion}</div>
                            <div style="color: var(--md-on-surface-variant);">SW:</div><div style="color: var(--md-on-surface);">${serviceWorkerVersion}</div>
                            <div style="color: var(--md-on-surface-variant);">Last Clear:</div><div style="color: var(--md-on-surface);">${lastUpdateDate}</div>
                        </div>
                        <div class="mt-2 text-xs font-medium" style="color: ${storedVersion === currentVersion ? 'var(--md-primary)' : '#f59e0b'};">
                            ${statusIcon} ${statusText}
                        </div>
                    `;
                }
            });

            // --- Grid System ---
            const gridsToggle = document.getElementById('grids-toggle');
            const gridsPanel = document.getElementById('grids-panel');
            const showGuidesChk = document.getElementById('show-position-guides');
            const enableAutoSnapChk = document.getElementById('enable-auto-snap');
            const arrangeTargetsBtn = document.getElementById('arrange-all-targets');
            const turnOffGridBtn = document.getElementById('turn-off-grid');

            // Grid calculation functions
            function calculateGridFrames(frameCount) {
                if (!frameCount) return [];
                
                const frames = [];
                let cols, rows;
                
                // Determine grid layout
                switch (frameCount) {
                    case 2:
                        cols = 2; rows = 1;
                        break;
                    case 4:
                        cols = 2; rows = 2;
                        break;
                    case 6:
                        cols = 3; rows = 2;
                        break;
                    case 9:
                        cols = 3; rows = 3;
                        break;
                    case 12:
                        cols = 4; rows = 3;
                        break;
                    default:
                        return [];
                }
                
                const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                const frameWidth = canvasWidth / cols;
                const frameHeight = canvasHeight / rows;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        frames.push({
                            x: col * frameWidth + frameWidth / 2,
                            y: row * frameHeight + frameHeight / 2,
                            width: frameWidth,
                            height: frameHeight,
                            col,
                            row,
                            occupied: false // Simplified occupancy tracking
                        });
                    }
                }
                
                return frames;
            }
            
        function findNearestGridFrame(x, y) {
                if (!currentGrid || gridFrames.length === 0) return null;
                
                let nearestFrame = null;
                let minDistance = snapStrength;
                
                gridFrames.forEach(frame => {
                    const distance = Math.sqrt((x - frame.x) ** 2 + (y - frame.y) ** 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestFrame = frame;
                    }
                });
                
                return nearestFrame;
            }
            
            function snapToGrid(x, y, isShiftHeld = false) {
                if (!currentGrid || !enableAutoSnap || isShiftHeld) return { x, y };
                
                // Ensure grid frames are calculated for current canvas size
                if (gridFrames.length === 0 && currentGrid) {
                    gridFrames = calculateGridFrames(currentGrid);
                }
                
                const nearestFrame = findNearestGridFrame(x, y);
                if (nearestFrame) {
                    const dx = nearestFrame.x - x;
                    const dy = nearestFrame.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= snapStrength) {
                        // Always use smooth magnetic falloff for natural feel
                        const normalizedDist = distance / snapStrength; // 0 to 1
                        const strength = Math.max(0.3, 1 - (normalizedDist * normalizedDist)); // Quadratic falloff with minimum
                        const snapX = x + dx * strength;
                        const snapY = y + dy * strength;
                        return { x: snapX, y: snapY };
                    }
                }
                
                return { x, y };
            }
            
            // Helper functions to get object center and convert between center and position
            function getObjectCenter(obj) {
                if (!obj) return { x: 0, y: 0 };
                
                let centerX, centerY;
                
                if (obj.type === 'circle') {
                    centerX = obj.x;
                    centerY = obj.y;
                } else if (obj.type === 'text') {
                    // For text, x,y is top-left; compute center from width/height
                    centerX = obj.x + (obj.width || 0) / 2;
                    centerY = obj.y + (obj.height || 0) / 2;
                } else {
                    // For rectangles, images, videos - position is top-left, so calculate center
                    centerX = obj.x + obj.width / 2;
                    centerY = obj.y + obj.height / 2;
                }
                
                return { x: centerX, y: centerY };
            }
            
            function setObjectCenterPosition(obj, centerX, centerY) {
                if (!obj) return;
                
                if (obj.type === 'circle') {
                    obj.x = centerX;
                    obj.y = centerY;
                } else if (obj.type === 'text') {
                    // Place top-left so the visual center aligns with the target
                    obj.x = centerX - (obj.width || 0) / 2;
                    obj.y = centerY - (obj.height || 0) / 2;
                } else {
                    // For rectangles, images, videos - set position so center is at target
                    obj.x = centerX - obj.width / 2;
                    obj.y = centerY - obj.height / 2;
                }
            }
            
            function snapObjectCenterToGrid(obj, isShiftHeld = false) {
                if (!obj || !currentGrid || isShiftHeld) return;
                
                const center = getObjectCenter(obj);
                const snappedCenter = snapToGrid(center.x, center.y, isShiftHeld);
                
                // Only update if snapping actually occurred
                if (snappedCenter.x !== center.x || snappedCenter.y !== center.y) {
                    setObjectCenterPosition(obj, snappedCenter.x, snappedCenter.y);
                    return true;
                }
                return false;
            }
            
            function animateSnapToGrid(object, targetCenterX, targetCenterY, startCenterX, startCenterY, duration = 200) {
                if (isSnapping) return; // Prevent multiple animations
                
                isSnapping = true;
                const startTime = performance.now();
                
                // If no start center provided, get current center
                if (startCenterX === undefined || startCenterY === undefined) {
                    const currentCenter = getObjectCenter(object);
                    startCenterX = currentCenter.x;
                    startCenterY = currentCenter.y;
                }
                
                // Ensure render loop is active
                ensureRenderLoop();
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Smooth easing function (ease-out)
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    const currentCenterX = startCenterX + (targetCenterX - startCenterX) * easeOut;
                    const currentCenterY = startCenterY + (targetCenterY - startCenterY) * easeOut;
                    
                    setObjectCenterPosition(object, currentCenterX, currentCenterY);
                    
                    draw();
                    
                    if (progress < 1) {
                        snapAnimation = requestAnimationFrame(animate);
                    } else {
                        isSnapping = false;
                        snapAnimation = null;
                        // Recompute occupancy after snap animation completes
                        if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                            recomputeGridOccupancy();
                        }
                    }
                }
                
                snapAnimation = requestAnimationFrame(animate);
            }
            
            function drawGridOverlay() {
                if (!currentGrid || !showGuides || gridFrames.length === 0) return;
                
                ctx.save();
                
                // Draw position guides with elegant styling
                gridFrames.forEach((frame, index) => {
                    const left = frame.x - frame.width / 2 + 30;
                    const top = frame.y - frame.height / 2 + 30;
                    const width = frame.width - 60;
                    const height = frame.height - 60;
                    const radius = 20; // Smooth rounded corners
                    
                    // Create smooth rounded rectangle path
                    ctx.beginPath();
                    ctx.moveTo(left + radius, top);
                    ctx.lineTo(left + width - radius, top);
                    ctx.arcTo(left + width, top, left + width, top + radius, radius);
                    ctx.lineTo(left + width, top + height - radius);
                    ctx.arcTo(left + width, top + height, left + width - radius, top + height, radius);
                    ctx.lineTo(left + radius, top + height);
                    ctx.arcTo(left, top + height, left, top + height - radius, radius);
                    ctx.lineTo(left, top + radius);
                    ctx.arcTo(left, top, left + radius, top, radius);
                    ctx.closePath();
                    
                    // Subtle outer glow
                    ctx.strokeStyle = 'rgba(8, 145, 178, 0.12)'; // Cyan from app theme
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    
                    // Main frame stroke with app's primary color
                    ctx.strokeStyle = 'rgba(8, 145, 178, 0.3)'; // Cyan from app theme
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Inner highlight for depth
                    ctx.strokeStyle = 'rgba(8, 145, 178, 0.15)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Draw position dot with app-integrated colors
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Subtle outer glow
                    const outerGlow = ctx.createRadialGradient(frame.x, frame.y, 5, frame.x, frame.y, 18);
                    outerGlow.addColorStop(0, 'rgba(8, 145, 178, 0.15)');
                    outerGlow.addColorStop(1, 'rgba(8, 145, 178, 0)');
                    ctx.fillStyle = outerGlow;
                    ctx.beginPath();
                    ctx.arc(frame.x, frame.y, 18, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw occupancy indicator based on frame.occupied status
                    if (frame.occupied) {
                        // Occupied - filled dot with clean styling
                        // Outer glow ring
                        ctx.strokeStyle = 'rgba(34, 197, 94, 0.25)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 11, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Main filled circle with gradient
                        const fillGradient = ctx.createRadialGradient(
                            frame.x - 2, frame.y - 2, 0,
                            frame.x, frame.y, 10
                        );
                        fillGradient.addColorStop(0, 'rgba(134, 239, 172, 1)');
                        fillGradient.addColorStop(0.6, 'rgba(34, 197, 94, 1)');
                        fillGradient.addColorStop(1, 'rgba(22, 163, 74, 1)');
                        
                        ctx.fillStyle = fillGradient;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Crisp border
                        ctx.strokeStyle = 'rgba(21, 128, 61, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Subtle highlight
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(frame.x - 2, frame.y - 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Empty - hollow ring with app theme colors
                        // Outer soft ring
                        ctx.strokeStyle = 'rgba(8, 145, 178, 0.2)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 11, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Main ring
                        ctx.strokeStyle = 'rgba(8, 145, 178, 0.5)';
                        ctx.lineWidth = 2.5;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 9, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner fill
                        const innerFill = ctx.createRadialGradient(
                            frame.x, frame.y, 0,
                            frame.x, frame.y, 7
                        );
                        innerFill.addColorStop(0, 'rgba(236, 254, 255, 0.15)');
                        innerFill.addColorStop(1, 'rgba(207, 250, 254, 0.05)');
                        ctx.fillStyle = innerFill;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 7, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Subtle highlight arc
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 9, Math.PI * 1.2, Math.PI * 1.8);
                        ctx.stroke();
                    }
                });
                
                ctx.restore();
            }

            // Draw active drag indicator on top layer (above objects)
            function drawGridDragIndicator() {
                if (!currentGrid || !showGuides || gridFrames.length === 0) return;
                if (!isDragging || !selectedObject) return;
                
                ctx.save();
                
                const center = getObjectCenter(selectedObject);
                const nearest = findNearestGridFrame(center.x, center.y);
                if (nearest) {
                    const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                    if (distance <= snapStrength) {
                        // Smooth animated highlight with app colors
                        const time = Date.now() * 0.003;
                        const pulse1 = (Math.sin(time) * 0.3 + 0.7);
                        const pulse2 = (Math.sin(time + Math.PI * 0.5) * 0.2 + 0.8);
                        
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        // Outer expanding ring
                        ctx.strokeStyle = `rgba(34, 197, 94, ${pulse1 * 0.35})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(nearest.x, nearest.y, 28 + pulse2 * 5, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Middle ring
                        ctx.strokeStyle = `rgba(34, 197, 94, ${pulse2 * 0.6})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(nearest.x, nearest.y, 18, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Center glow
                        const snapGradient = ctx.createRadialGradient(nearest.x, nearest.y, 0, nearest.x, nearest.y, 20);
                        snapGradient.addColorStop(0, `rgba(134, 239, 172, ${pulse2 * 0.4})`);
                        snapGradient.addColorStop(0.5, `rgba(34, 197, 94, ${pulse2 * 0.25})`);
                        snapGradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                        ctx.fillStyle = snapGradient;
                        ctx.beginPath();
                        ctx.arc(nearest.x, nearest.y, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
            
        function setGrid(frameCount) {
                // Remove selection from all grid buttons
                document.querySelectorAll('.grid-button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                
                if (frameCount === currentGrid) {
                    // Deselect current grid
                    currentGrid = null;
            gridFrames = [];
                    turnOffGridBtn.style.display = 'none';
                } else {
                    // Select new grid
                    currentGrid = frameCount;
            gridFrames = calculateGridFrames(frameCount);
                    
                    // Add selection to clicked button
                    const button = document.getElementById(`grid-${frameCount}`);
                    if (button) {
                        button.classList.add('selected');
                    }
                    
                    turnOffGridBtn.style.display = 'block';
                }
                
                recomputeGridOccupancy?.();
                requestAnimationFrame(draw);
            }
            
            // gridsToggle click handler removed - now handled by generic accordion handler
            
            // Grid button event listeners
            [2, 4, 6, 9, 12].forEach(count => {
                const button = document.getElementById(`grid-${count}`);
                button?.addEventListener('click', () => setGrid(count));
            });
            
            // Simplified grid controls
            showGuidesChk?.addEventListener('change', () => {
                showGuides = showGuidesChk.checked;
                
                // Recompute occupancy when guides are shown to ensure accurate display
                if (showGuides && currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
                
                requestAnimationFrame(draw);
            });
            
            enableAutoSnapChk?.addEventListener('change', () => {
                enableAutoSnap = enableAutoSnapChk.checked;
            });
            
            // Function to handle arrange button click
            function handleArrangeClick() {
                if (!currentGrid) {
                    showToast('No Grid Selected', 'Please select a grid layout first.', 'warning');
                    return;
                }

                // Get the checkbox states
                const arrangeTextBoxes = document.getElementById('arrange-text-boxes')?.checked ?? true;
                const arrangeShapes = document.getElementById('arrange-shapes')?.checked ?? true;

                // Filter visible objects based on arrange options
                const visibleObjects = objects.filter(o => {
                    if (!o.visible) return false;
                    
                    // Check if this is a text box and if text boxes should be arranged
                    if (o.type === 'text' && !arrangeTextBoxes) return false;
                    
                    // Check if this is a shape and if shapes should be arranged
                    if ((o.type === 'shape' || o.type === 'circle') && !arrangeShapes) return false;
                    
                    return true;
                });

                if (visibleObjects.length === 0) {
                    showToast('No Objects', 'No objects to arrange.', 'info');
                    return;
                }

                // Smart arrangement algorithm:
                // 1. Identify which objects are already well-positioned on grid
                // 2. Arrange un-positioned objects to remaining slots

                const threshold = 50; // Distance threshold for considering an object "on grid"
                const occupiedFrames = new Set();
                const wellPositionedObjects = new Set();

                // First pass: Find objects that are already close to grid positions
                // We need a version of findNearestGridFrame that doesn't use snapStrength limit
                visibleObjects.forEach(obj => {
                    const center = getObjectCenter(obj);

                    // Find nearest grid frame without distance limit
                    let nearestFrame = null;
                    let minDistance = Infinity;

                    gridFrames.forEach(frame => {
                        const distance = Math.sqrt((center.x - frame.x) ** 2 + (center.y - frame.y) ** 2);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestFrame = frame;
                        }
                    });

                    if (nearestFrame && minDistance <= threshold) {
                        // Create unique key for this frame position
                        const frameKey = `${nearestFrame.x},${nearestFrame.y}`;
                        if (!occupiedFrames.has(frameKey)) {
                            occupiedFrames.add(frameKey);
                            wellPositionedObjects.add(obj.id);
                        }
                    }
                });

                // Get objects that need to be arranged (not well-positioned)
                const objectsToArrange = visibleObjects.filter(obj => !wellPositionedObjects.has(obj.id));

                // Get available frames (not occupied by well-positioned objects)
                const availableFrames = gridFrames.filter(frame => {
                    const frameKey = `${frame.x},${frame.y}`;
                    return !occupiedFrames.has(frameKey);
                });

                if (objectsToArrange.length === 0) {
                    showToast('Already Arranged', 'All objects are already positioned on the grid!', 'success');
                    return;
                }

                // Calculate how many objects we can actually arrange
                const canArrange = Math.min(objectsToArrange.length, availableFrames.length);
                const objectsWeWillArrange = objectsToArrange.slice(0, canArrange);
                const leftOver = objectsToArrange.length - canArrange;

                // Arrange as many objects as we have space for
                objectsWeWillArrange.forEach((obj, i) => {
                    const frame = availableFrames[i];
                    setObjectCenterPosition(obj, frame.x, frame.y);
                });

                // Show appropriate feedback
                if (leftOver > 0) {
                    showToast('Partially Arranged', `Arranged ${canArrange} object${canArrange > 1 ? 's' : ''}. ${leftOver} object${leftOver > 1 ? 's' : ''} couldn't fit (grid full). Consider using a larger grid.`, 'warning');
                } else {
                    showToast('Arrangement Complete', `Arranged ${canArrange} object${canArrange > 1 ? 's' : ''}. ${wellPositionedObjects.size} already positioned.`, 'success');
                }

                recomputeGridOccupancy();
                requestAnimationFrame(draw);
            }

            // Attach the event listener
            arrangeTargetsBtn?.addEventListener('click', handleArrangeClick);

            // Also try attaching after a delay in case of timing issues
            setTimeout(() => {
                const btn = document.getElementById('arrange-all-targets');
                if (btn && !btn.onclick) {
                    btn.addEventListener('click', handleArrangeClick);
                }
            }, 500);

            turnOffGridBtn?.addEventListener('click', () => {
                setGrid(null);
            });

            // Simple grid helpers
            function clearGridOccupancy() {
                gridFrames.forEach(f => f.occupied = false);
            }
            
            function recomputeGridOccupancy() {
                clearGridOccupancy();
                // Mark frames as occupied based on object proximity
                objects.forEach(obj => {
                    if (!obj.visible) return;
                    const center = getObjectCenter(obj);
                    const nearest = findNearestGridFrame(center.x, center.y);
                    if (nearest) {
                        const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                        // Use a reasonable threshold for occupancy detection
                        // Objects that are snapped should be very close, but account for small positioning variations
                        if (distance <= 20) { // Reasonable threshold for detecting snapped objects
                            nearest.occupied = true;
                            // Debug: uncomment the line below to see occupancy detection in console
                            // console.log(`Object at (${center.x.toFixed(1)}, ${center.y.toFixed(1)}) occupies grid point at (${nearest.x}, ${nearest.y}), distance: ${distance.toFixed(2)}`);
                        }
                    }
                });
                
                // Force a redraw to update occupancy indicators
                requestAnimationFrame(draw);
            }

            // --- Media Handling ---
            function showProgress() {
                progressContainer.style.display = 'block';
            }
            
            function hideProgress() {
                progressContainer.style.display = 'none';
            }
            
            function updateProgress(current, total) {
                const percentage = Math.round((current / total) * 100);
                progressFill.style.width = percentage + '%';
                progressDetail.textContent = `${current} of ${total} files processed`;
            }
            
            async function handleFiles(files, categoryOverride = 'visualTargets', isAutoLoad = false, sourceFolderName = null) { 
                const mediaFiles = Array.from(files).filter(file => 
                    file.type.startsWith('image/') || 
                    file.type.startsWith('video/') ||
                    file.name.toLowerCase().endsWith('.gif')
                );
                
                if (mediaFiles.length === 0) return;
                
                // Store fullscreen state before loading
                const wasFullscreen = !!document.fullscreenElement;
                
                if (mediaFiles.length > 1) {
                    showProgress();
                    updateProgress(0, mediaFiles.length);
                }
                
                for (let i = 0; i < mediaFiles.length; i++) {
                    const file = mediaFiles[i];
                    
                    await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = e => {
                            if (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mp4') || 
                                file.name.toLowerCase().endsWith('.mov') || file.name.toLowerCase().endsWith('.avi') ||
                                file.name.toLowerCase().endsWith('.mkv') || file.name.toLowerCase().endsWith('.webm') ||
                                file.name.toLowerCase().endsWith('.3gp') || file.name.toLowerCase().endsWith('.wmv') ||
                                file.name.toLowerCase().endsWith('.flv') || file.name.toLowerCase().endsWith('.m4v')) {
                                // Handle video files
                                const video = document.createElement('video');
                                video.src = e.target.result;
                                video.dataset.name = file.name;
                                video.loop = true;
                                video.muted = true;
                                video.playsInline = true;
                                video.onloadedmetadata = () => {
                                    addMediaItem(video, categoryOverride, isAutoLoad, sourceFolderName);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                                video.onerror = () => {
                                    console.error('Error loading video:', file.name);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                            } else {
                                // Handle image files (including GIFs)
                                const img = new Image();
                                img.src = e.target.result;
                                img.dataset.name = file.name;
                                img.onload = () => {
                                    addMediaItem(img, categoryOverride, isAutoLoad, sourceFolderName);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                                img.onerror = () => {
                                    console.error('Error loading image:', file.name);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                            }
                        };
                        reader.readAsDataURL(file);
                    });
                    
                    // Small delay to allow UI to update
                    if (mediaFiles.length > 10) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                if (mediaFiles.length > 1) {
                    // Hide progress bar after a short delay
                    setTimeout(hideProgress, 500);
                }
                
                // Restore fullscreen state if it was active before loading
                if (wasFullscreen && !document.fullscreenElement) {
                    try {
                        await document.documentElement.requestFullscreen();
                    } catch (error) {
                        console.log('Could not restore fullscreen after image loading:', error);
                    }
                }
            }
            function addMediaItem(mediaElement, category = 'visualTargets', isAutoLoad = false, sourceFolderName = null) { 
                // Add to specified category with auto-load metadata
                const metadata = isAutoLoad ? {
                    autoLoaded: true,
                    sourceFolderName: sourceFolderName,
                    category: category
                } : {};
                addToMediaLibrary(mediaElement, category, metadata);
            }
            
            function addToMediaLibrary(mediaElement, category, metadata = {}) {
                // Add to memory via abstraction
                MediaLibrary.add(category, mediaElement, metadata);
                
                // Add to UI
                const targetGrid = getGridForCategory(category);
                const emptyState = getEmptyStateForCategory(category);
                
                if (targetGrid && emptyState) {
                    emptyState.style.display = 'none';
                    targetGrid.style.display = 'grid';
                }
                
                createMediaItemElement(mediaElement, category, targetGrid);
                
                // Update accordion height for the category
                updateAccordionHeightForCategory(category);
            }
            
            function getGridForCategory(category) {
                switch(category) {
                    case 'backgrounds': return backgroundsGrid;
                    case 'foregrounds': return foregroundsGrid;
                    case 'visualTargets': return visualTargetsGrid;
                    default: return null;
                }
            }
            
            function getEmptyStateForCategory(category) {
                switch(category) {
                    case 'backgrounds': return backgroundsEmptyState;
                    case 'foregrounds': return foregroundsEmptyState;
                    case 'visualTargets': return visualTargetsEmptyState;
                    default: return null;
                }
            }
            
            function createMediaItemElement(mediaElement, category, targetGrid) {
                const div = document.createElement('div'); 
                div.className = 'media-item relative cursor-pointer'; 
                
                const isVideo = mediaElement.tagName === 'VIDEO';
                const displayElement = document.createElement(isVideo ? 'video' : 'img');
                
                if (isVideo) {
                    displayElement.src = mediaElement.src;
                    displayElement.className = 'absolute top-0 left-0 w-full h-full object-cover';
                    displayElement.muted = true;
                    displayElement.loop = true;
                    displayElement.playsInline = true;
                    displayElement.dataset.name = mediaElement.dataset.name;
                    displayElement.dataset.category = category;
                    
                    // Auto-play video on hover for preview
                    div.addEventListener('mouseenter', () => {
                        displayElement.play().catch(e => console.log('Video play failed:', e));
                    });
                    div.addEventListener('mouseleave', () => {
                        displayElement.pause();
                        displayElement.currentTime = 0;
                    });
                } else {
                    displayElement.src = mediaElement.src;
                    displayElement.className = 'absolute top-0 left-0 w-full h-full object-cover';
                    displayElement.draggable = true;
                    displayElement.dataset.name = mediaElement.dataset.name;
                    displayElement.dataset.category = category;
                }
                
                const overlay = document.createElement('div');
                overlay.className = 'absolute inset-0 bg-black bg-opacity-0 hover:bg-opacity-30 transition-all duration-300 flex items-center justify-center';
                
                // Add video indicator icon for videos
                if (isVideo) {
                    const videoIndicator = document.createElement('div');
                    videoIndicator.className = 'absolute top-2 right-2 bg-black bg-opacity-70 rounded-full p-1';
                    videoIndicator.innerHTML = `
                        <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    `;
                    div.appendChild(videoIndicator);
                }
                
                if (category === 'backgrounds') {
                    overlay.innerHTML = `
                        <div class="text-white opacity-0 hover:opacity-100 transition-opacity duration-300">
                            <svg class="w-6 h-6 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            <p class="text-xs font-medium">Set Background</p>
                        </div>
                    `;
                } else if (category === 'foregrounds') {
                    overlay.innerHTML = `
                        <div class="text-white opacity-0 hover:opacity-100 transition-opacity duration-300">
                            <svg class="w-6 h-6 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                            </svg>
                            <p class="text-xs font-medium">Set Foreground</p>
                        </div>
                    `;
                } else {
                    overlay.innerHTML = `
                        <div class="text-white opacity-0 hover:opacity-100 transition-opacity duration-300">
                            <svg class="w-6 h-6 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <circle cx="12" cy="12" r="10"></circle>
                                <circle cx="12" cy="12" r="6"></circle>
                                <circle cx="12" cy="12" r="2"></circle>
                            </svg>
                            <p class="text-xs font-medium">Add to Canvas</p>
                        </div>
                    `;
                }
                
                div.appendChild(displayElement); 
                // Remove button (red X)
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.setAttribute('aria-label', 'Remove asset');
                removeBtn.className = 'remove-media-btn';
                removeBtn.innerHTML = '&times;';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeMediaItem(mediaElement, category, div);
                });
                div.appendChild(removeBtn);
                div.appendChild(overlay);
                targetGrid.appendChild(div); 
                
                if (!isVideo) {
                    displayElement.addEventListener('dragstart', (e) => { 
                        e.dataTransfer.setData('text/plain', mediaElement.src); 
                        e.dataTransfer.setData('name', mediaElement.dataset.name); 
                        e.dataTransfer.setData('category', category);
                        e.dataTransfer.setData('mediaType', isVideo ? 'video' : 'image');
                    }); 
                }
                
                div.addEventListener('click', () => { 
                    if (category === 'backgrounds') {
                        setBackgroundImage(mediaElement);
                    } else if (category === 'foregrounds') {
                        setForegroundImage(mediaElement);
                    } else {
                        if (isVideo) {
                            addVideoToCanvas(mediaElement.src, mediaElement.dataset.name);
                        } else {
                            addImageToCanvas(mediaElement.src, mediaElement.dataset.name); 
                        }
                        // Removed auto-close behavior - let users manually close drawer after selecting multiple items
                    }
                }); 
                
                // Add context menu for moving between categories
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMediaContextMenu(e.clientX, e.clientY, mediaElement, category, div);
                });
            }

            function removeMediaItem(mediaElement, category, elementDiv) {
                // Remove from data structure via abstraction
                MediaLibrary.remove(category, mediaElement);
                // If currently set as background or foreground, clear it
                if (category === 'backgrounds' && backgroundImage && backgroundImage.img === mediaElement) {
                    backgroundImage = null;
                    // keep button visible but inactive state handled below
                }
                if (category === 'foregrounds' && foregroundImage && foregroundImage.img === mediaElement) {
                    foregroundImage = null;
                    // keep button visible but inactive state handled below
                }
                // Remove DOM element
                if (elementDiv && elementDiv.parentNode) {
                    elementDiv.parentNode.removeChild(elementDiv);
                }
                // Update empty state
                updateEmptyStates();
                // Redraw if needed
                updateBgFgDeleteStates();
                draw();
            }
            
            function setBackgroundImage(img) {
                backgroundImage = { img: img };
                updateBgFgDeleteStates();
                draw();
            }
            
            function setForegroundImage(img) {
                foregroundImage = { img: img };
                updateBgFgDeleteStates();
                draw();
            }

            function updateBgFgDeleteStates() {
                if (backgroundImage) {
                    deleteBgBtn.classList.remove('inactive');
                } else {
                    deleteBgBtn.classList.add('inactive');
                }
                if (foregroundImage) {
                    deleteFgBtn.classList.remove('inactive');
                } else {
                    deleteFgBtn.classList.add('inactive');
                }
            }
            
            function showMediaContextMenu(x, y, img, currentCategory, element) {
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.display = 'block';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                
                const categories = [
                    { key: 'backgrounds', label: 'Move to Backgrounds' },
                    { key: 'foregrounds', label: 'Move to Foregrounds' },
                    { key: 'visualTargets', label: 'Move to Visual Targets' }
                ];
                
                categories.forEach(cat => {
                    if (cat.key !== currentCategory) {
                        const button = document.createElement('button');
                        button.textContent = cat.label;
                        button.addEventListener('click', () => {
                            moveMediaItem(img, currentCategory, cat.key, element);
                            document.body.removeChild(menu);
                        });
                        menu.appendChild(button);
                    }
                });
                
                document.body.appendChild(menu);
                
                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                        document.removeEventListener('click', closeMenu);
                    });
                }, 100);
            }
            
            function moveMediaItem(img, fromCategory, toCategory, element) {
                // Move using abstraction
                MediaLibrary.move(fromCategory, toCategory, img);
                
                // Remove from old grid
                element.parentNode.removeChild(element);
                
                // Add to new grid
                const targetGrid = getGridForCategory(toCategory);
                const emptyState = getEmptyStateForCategory(toCategory);
                
                if (targetGrid && emptyState) {
                    emptyState.style.display = 'none';
                    targetGrid.style.display = 'grid';
                }
                
                createMediaItemElement(img, toCategory, targetGrid);
                
                // Update accordion heights for both categories
                updateAccordionHeightForCategory(fromCategory);
                updateAccordionHeightForCategory(toCategory);
                
                // Update empty states
                updateEmptyStates();
            }
            
            function updateEmptyStates() {
                Object.keys(mediaAssets).forEach(category => {
                    const grid = getGridForCategory(category);
                    const emptyState = getEmptyStateForCategory(category);
                    if (!grid || !emptyState) return;
                    if (MediaLibrary.isEmpty(category)) {
                        emptyState.style.display = 'block';
                        grid.style.display = 'none';
                    } else {
                        emptyState.style.display = 'none';
                        grid.style.display = 'grid';
                    }
                });
            }
            imageUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'visualTargets'));
            folderUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'visualTargets'));

            const bgFolderUpload = document.getElementById('bg-folder-upload');
            if (bgFolderUpload) {
                bgFolderUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'backgrounds'));
            }
            const fgFolderUpload = document.getElementById('fg-folder-upload');
            if (fgFolderUpload) {
                fgFolderUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'foregrounds'));
            }

            // --- Canvas Drag & Drop ---
            function addImageToCanvas(imgSrc, name, x, y) {
                const img = new Image();
                img.src = imgSrc;
                img.dataset.name = name;
                img.onload = () => {
                    const w = 150;
                    const h = (img.height / img.width) * w;
                    const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                    const finalX = (x === undefined) ? (canvasWidth / 2) - (w / 2) : x - (w/2);
                    const finalY = (y === undefined) ? (canvasHeight / 2) - (h / 2) : y - (h/2);
                    const newObj = new ImageObject(img, finalX, finalY, w, h, getNextZIndex());

                    // Apply saved TTS settings if available
                    applyTTSSettings(newObj, name);

                    objects.push(newObj);
                    setSelectedObject(newObj);
                    updateAnimationTriggerPanel();

                    // Recompute grid occupancy after adding new object
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                };
            }
            
            function addVideoToCanvas(videoSrc, name, x, y) { 
                const video = document.createElement('video'); 
                video.src = videoSrc; 
                video.dataset.name = name; 
                video.muted = true;
                video.loop = true;
                video.playsInline = true;
                video.onloadedmetadata = () => { 
                    const w = 150; 
                    const h = (video.videoHeight / video.videoWidth) * w; 
                    const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                    const finalX = (x === undefined) ? (canvasWidth / 2) - (w / 2) : x - (w/2); 
                    const finalY = (y === undefined) ? (canvasHeight / 2) - (h / 2) : y - (h/2); 
                    const newObj = new VideoObject(video, finalX, finalY, w, h, getNextZIndex()); 
                    objects.push(newObj); 
                    setSelectedObject(newObj); 
                    updateAnimationTriggerPanel(); 
                    video.play().catch(e => console.log('Video autoplay failed:', e));
                    ensureRenderLoop();
                    
                    // Recompute grid occupancy after adding new video object
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                }; 
            }
            canvas.addEventListener('dragover', (e) => e.preventDefault());
            canvas.addEventListener('drop', (e) => { 
                e.preventDefault(); 
                const mediaSrc = e.dataTransfer.getData('text/plain'); 
                const name = e.dataTransfer.getData('name'); 
                const mediaType = e.dataTransfer.getData('mediaType') || 'image';
                if (!mediaSrc) return; 
                const rect = canvas.getBoundingClientRect(); 
                const x = e.clientX - rect.left; 
                const y = e.clientY - rect.top; 
                if (mediaType === 'video') {
                    addVideoToCanvas(mediaSrc, name, x, y);
                } else {
                    addImageToCanvas(mediaSrc, name, x, y); 
                }
            });

            // --- Tool Selection & Mouse Events ---
            function setActiveTool(tool) { currentTool = tool; document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active')); const activeBtn = document.getElementById(`${tool}-tool`); if(activeBtn) activeBtn.classList.add('active'); }

            // --- Animation Helper Mapping ---
            const friendlyToInternal = {
                'gentle-shake': 'gentle-shake', // Micro Jiggle
                'pendum': 'pendum',             // Soft Sway
                'circular': 'circular'          // Orbit Loop
            };

            function applyAnimationSettings(obj) {
                if(!obj) return;
                // animationType is now set directly by button clicks, not from dropdown
                obj.animationDuration = parseFloat(animationDuration.value) || 1;
                obj.animationCycles = parseInt(animationCycles.value) || 1;
                obj.animationIntensity = parseInt(animationIntensity.value) || 5;
                obj.animationEasing = 'ease-in-out';  // Always use smooth easing
                obj.animationIteration = 'infinite';  // Always loop
                // NOTE: Do NOT start the animation here. Only store settings.
                // Animation starts when user presses the Start Motion button or numeric trigger.
            }

            function updateAnimationUIVisibility() {
                const selectedAnimation = document.querySelector('.animation-type-btn.active');
                const animationType = selectedAnimation ? selectedAnimation.dataset.animation : '';
                if(animationType) {
                    animationSettings.classList.remove('hidden');
                } else {
                    animationSettings.classList.add('hidden');
                }
            }

            // Animation type button handlers
            const animationButtons = document.querySelectorAll('.animation-type-btn');
            animationButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active from all buttons
                    animationButtons.forEach(b => b.classList.remove('active'));
                    // Add active to clicked button
                    btn.classList.add('active');

                    if(selectedObject) {
                        selectedObject.animationType = btn.dataset.animation;
                        applyAnimationSettings(selectedObject);
                        updateAnimationControlButton();
                        updateAnimationTriggerPanel();

                        // If "path" animation is selected, automatically start path drawing
                        if (btn.dataset.animation === 'path') {
                            // Show path animation settings and controls
                            if (pathAnimationSettings) {
                                pathAnimationSettings.classList.remove('hidden');
                            }
                            // Show path controls in main settings, hide standard controls
                            if (standardAnimationControls) standardAnimationControls.classList.add('hidden');
                            if (pathAnimationControls) pathAnimationControls.classList.remove('hidden');
                            // Start drawing path if object doesn't have one yet
                            if (!selectedObject.animationPath) {
                                startDrawingPath(selectedObject);
                            }
                        } else {
                            // Hide path animation settings for other animation types
                            if (pathAnimationSettings) {
                                pathAnimationSettings.classList.add('hidden');
                            }
                            // Show standard controls, hide path controls
                            if (standardAnimationControls) standardAnimationControls.classList.remove('hidden');
                            if (pathAnimationControls) pathAnimationControls.classList.add('hidden');
                        }
                    }
                    updateAnimationUIVisibility();
                });
            });

            // Legacy support - remove old dropdown listener
            if(animationSelect) {
                // Dropdown replaced with buttons - this code can be removed
            }

            [animationDuration, animationCycles, animationIntensity].forEach(ctrl => {
                if(ctrl) ctrl.addEventListener('input', () => {
                    if(ctrl === animationDuration) {
                        const val = parseFloat(animationDuration.value);
                        durationValue.textContent = val <= 0.7 ? 'Fast' : val >= 2 ? 'Slow' : 'Medium';
                    }
                    if(ctrl === animationCycles) {
                        const val = parseInt(animationCycles.value) || 1;
                        cyclesValue.textContent = val + ' cycle' + (val === 1 ? '' : 's');
                    }
                    if(ctrl === animationIntensity) {
                        const val = parseInt(animationIntensity.value);
                        intensityValue.textContent = val <= 3 ? 'Small' : val >= 7 ? 'Large' : 'Medium';
                    }
                    if(selectedObject) {
                        applyAnimationSettings(selectedObject);
                        updateAnimationControlButton();
                        updateAnimationTriggerPanel();
                    }
                });
            });

            function updateAnimationControlButton() {
                if(!selectedObject || !selectedObject.animationType) {
                    if(animationControlBtn) {
                        animationControlBtn.style.display = 'none';
                    }
                    return;
                }
                
                if(animationControlBtn) {
                    animationControlBtn.style.display = 'block';
                    const isRunning = !!selectedObject.isAnimating;
                    
                    if(isRunning) {
                        playIcon.classList.add('hidden');
                        stopIcon.classList.remove('hidden');
                        controlText.textContent = 'Stop Motion';
                    } else {
                        playIcon.classList.remove('hidden');
                        stopIcon.classList.add('hidden');
                        controlText.textContent = 'Start Motion';
                    }
                }
            }

            if(animationControlBtn) {
                animationControlBtn.addEventListener('click', () => {
                    if(!selectedObject) return;
                    const isRunning = !!selectedObject.isAnimating;
                    if(isRunning) {
                        selectedObject.isAnimating = false;
                        selectedObject.animationStartTime = 0;
                        selectedObject.cycleCount = 0;
                    } else {
                        // Ensure settings exist then start
                        if(!selectedObject.animationType) applyAnimationSettings(selectedObject);
                        selectedObject.isAnimating = true;
                        selectedObject.animationStartTime = performance.now();
                        selectedObject.cycleCount = 0;
                        ensureRenderLoop();
                    }
                    updateAnimationControlButton();
                    draw(); // Refresh display
                });

                // Animation trigger handlers
                triggerOnPressChk.addEventListener('change', (e) => {
                    if (selectedObject) {
                        selectedObject.triggerOnPress = e.target.checked;
                    }
                });

                triggerOnKeyChk.addEventListener('change', (e) => {
                    if (selectedObject) {
                        selectedObject.triggerOnKey = e.target.checked;
                        // Show/hide key selection dropdown
                        if (e.target.checked) {
                            keySelectionContainer.classList.remove('hidden');
                        } else {
                            keySelectionContainer.classList.add('hidden');
                        }
                    }
                });

                triggerKeySelect.addEventListener('change', (e) => {
                    if (selectedObject) {
                        selectedObject.triggerKey = e.target.value;
                    }
                });
            }
            function addCanvasObject(type) { 
                const { width: cWidth, height: cHeight } = getCanvasDimensions();
                const centerX = cWidth / 2; 
                const centerY = cHeight / 2; 
                let newObj; 
                
                if(type === 'text') { 
                    // Add slight offset for text objects too
                    const textX = centerX + shapeOffsetX;
                    const textY = centerY + shapeOffsetY;
                    newObj = new TextObject("Text", textX, textY, getNextZIndex()); 
                } else { 
                    // Get next harmonious color
                    const color = getNextHarmoniousColor();
                    
                    // Calculate offset position
                    const shapeX = centerX + shapeOffsetX;
                    const shapeY = centerY + shapeOffsetY;
                    
                    newObj = new ShapeObject(type, shapeX, shapeY, getNextZIndex(), color); 
                } 
                
                // Update offset for next object (spiral pattern)
                const offsetAmount = 40;
                const angle = objects.length * 0.5; // Spiral angle
                shapeOffsetX = Math.cos(angle) * offsetAmount * (1 + objects.length * 0.2);
                shapeOffsetY = Math.sin(angle) * offsetAmount * (1 + objects.length * 0.2);
                
                // Keep offset within reasonable bounds
                const { width: cWidth2, height: cHeight2 } = getCanvasDimensions();
                const maxOffset = Math.min(cWidth2, cHeight2) / 3;
                shapeOffsetX = Math.max(-maxOffset, Math.min(maxOffset, shapeOffsetX));
                shapeOffsetY = Math.max(-maxOffset, Math.min(maxOffset, shapeOffsetY));
                
                objects.push(newObj); 
                setActiveTool('select'); 
                setSelectedObject(newObj); 
                updateAnimationTriggerPanel(); 
                
                // Recompute grid occupancy after adding new canvas object
                if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
            }

            // --- Path Helper Functions ---
            function startDrawingPath(obj) {
                if (!obj) return;

                isDrawingPath = true;
                pathDrawingObject = obj;

                // Create a new path starting from the object's center
                const center = obj.getCenterPoint();
                obj.animationPath = new AnimationPath(`${obj.name} Path`, obj);
                obj.animationPath.addNode(center.x, center.y);

                // Update UI
                const clearPathBtn = document.getElementById('clear-path-btn');
                if (clearPathBtn) clearPathBtn.classList.remove('hidden');

                draw();
                console.log('Path drawing mode: Click to add nodes. Press Escape to finish, Backspace to undo, C to close path');
            }

            function finishDrawingPath() {
                if (!pathDrawingObject) return;

                if (pathDrawingObject.animationPath && pathDrawingObject.animationPath.nodes.length < 2) {
                    // Remove path if it has less than 2 nodes
                    pathDrawingObject.animationPath = null;
                }

                isDrawingPath = false;
                pathDrawingObject = null;

                draw();
            }

            function clearObjectPath(obj) {
                if (!obj) return;
                obj.animationPath = null;
                obj.animationType = null;
                isDrawingPath = false;
                pathDrawingObject = null;

                // Update UI
                const drawPathBtnText = document.getElementById('draw-path-btn-text');
                const clearPathBtn = document.getElementById('clear-path-btn');
                const reversePathBtn = document.getElementById('reverse-path-btn');

                if (drawPathBtnText) drawPathBtnText.textContent = 'Draw Path';
                if (clearPathBtn) clearPathBtn.classList.add('hidden');
                if (reversePathBtn) reversePathBtn.classList.add('hidden');

                draw();
            }

            selectTool.addEventListener('click', () => setActiveTool('select'));
            textTool.addEventListener('click', () => addCanvasObject('text'));
            rectTool.addEventListener('click', () => addCanvasObject('rect'));
            squareTool.addEventListener('click', () => addCanvasObject('square'));
            circleTool.addEventListener('click', () => addCanvasObject('circle'));
            triangleTool.addEventListener('click', () => addCanvasObject('triangle'));
            starTool.addEventListener('click', () => addCanvasObject('star'));
            octagonTool.addEventListener('click', () => addCanvasObject('octagon'));

            // Path animation button handlers
            clearPathBtn?.addEventListener('click', () => {
                if (selectedObject) {
                    clearObjectPath(selectedObject);
                }
            });

            // Path animation mode radio buttons
            const pathModeRadios = document.querySelectorAll('input[name="path-mode"]');
            pathModeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    if (selectedObject) {
                        selectedObject.pathAnimationMode = e.target.value;
                    }
                });
            });

            // Path speed slider in main controls
            pathSpeedMain?.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (pathSpeedValueMain) {
                    if (val === 1) {
                        pathSpeedValueMain.textContent = 'Normal';
                    } else if (val < 1) {
                        pathSpeedValueMain.textContent = val.toFixed(2) + 'x (Slower)';
                    } else {
                        pathSpeedValueMain.textContent = val.toFixed(2) + 'x (Faster)';
                    }
                }
                if (selectedObject) {
                    selectedObject.pathAnimationSpeed = val;
                }
            });

            // Path cycles slider in main controls
            pathCyclesMain?.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (pathCyclesValueMain) {
                    pathCyclesValueMain.textContent = val + (val === 1 ? ' cycle' : ' cycles');
                }
                if (selectedObject) {
                    selectedObject.animationCycles = val;
                }
            });
            function getMousePos(e) { const rect = canvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; }
            function getObjectAt(x, y) { const sorted = [...objects].sort((a, b) => b.zIndex - a.zIndex); for (const obj of sorted) { if (obj.visible && obj.isPointInside(x, y)) { return obj; } } return null; }
            // Upgrade to Pointer Events (covers mouse + touch + pen)
            canvas.addEventListener('pointerdown', (e) => {
                canvas.setPointerCapture(e.pointerId);
                const { x, y } = getMousePos(e);
                activePointers.set(e.pointerId, { x, y });

                // In Play Mode, only allow clicking objects (no editing)
                if (interactionMode === 'play') {
                    // No long press, no context menu, no dragging in play mode
                    return;
                }

                // --- EDIT MODE ONLY below this point ---
                // Long press detection for context menu (only primary & touch/pen)
                if (e.isPrimary) {
                    longPressStart = { x: e.clientX, y: e.clientY };
                    clearTimeout(longPressTimer);
                    longPressTimer = setTimeout(() => {
                        if (!isDragging && !isResizing) {
                            const obj = getObjectAt(x, y);
                            if (obj) { setSelectedObject(obj); showContextMenu(longPressStart.x, longPressStart.y); }
                        }
                    }, LONG_PRESS_MS);
                }
                if (e.button === 2) { const obj = getObjectAt(x, y); if (obj) { setSelectedObject(obj); e.preventDefault(); showContextMenu(e.clientX, e.clientY); } return; }
                hideContextMenu();

                // Path drawing/editing mode
                if (isDrawingPath && pathDrawingObject && pathDrawingObject.animationPath) {
                    // Check if clicking on an existing node to edit it
                    const nodeIndex = pathDrawingObject.animationPath.getNodeAt(x, y);
                    if (nodeIndex !== -1) {
                        // Select the node for dragging
                        selectedPathNode = { path: pathDrawingObject.animationPath, nodeIndex: nodeIndex };
                        isDraggingPathNode = true;
                        draw();
                        return;
                    }

                    // Check if Ctrl+clicking on path line to insert node
                    if (e.ctrlKey) {
                        const segmentIndex = pathDrawingObject.animationPath.getPathSegmentAt(x, y);
                        if (segmentIndex !== -1) {
                            pathDrawingObject.animationPath.insertNodeAt(x, y, segmentIndex);
                            draw();
                            return;
                        }
                    }

                    // Otherwise add a new node at the end
                    pathDrawingObject.animationPath.addNode(x, y);
                    draw();
                    return;
                }

                // Check if clicking on a path node when path exists (even if not in drawing mode)
                if (selectedObject && selectedObject.animationPath && selectedObject.animationType === 'path' && !isDrawingPath) {
                    const nodeIndex = selectedObject.animationPath.getNodeAt(x, y);
                    if (nodeIndex !== -1) {
                        selectedPathNode = { path: selectedObject.animationPath, nodeIndex: nodeIndex };
                        isDraggingPathNode = true;
                        draw();
                        return;
                    }

                    // Ctrl+click on path line to insert node
                    if (e.ctrlKey) {
                        const segmentIndex = selectedObject.animationPath.getPathSegmentAt(x, y);
                        if (segmentIndex !== -1) {
                            selectedObject.animationPath.insertNodeAt(x, y, segmentIndex);
                            draw();
                            return;
                        }
                    }
                }

                // Allow dragging even when not explicitly in select tool for touch convenience
                const allowDirectDrag = currentTool === 'select' || e.pointerType !== 'mouse';
                if (!allowDirectDrag) return;
                isDragging = false; isResizing = false;
                const handle = getResizeHandleAt(x, y);
                if (handle) {
                    isResizing = true; resizeHandle = handle.position; setSelectedObject(handle.object);
                    selectedObject.original = { x: selectedObject.x, y: selectedObject.y, width: selectedObject.width, height: selectedObject.height, size: selectedObject.size };
                } else {
                    const obj = getObjectAt(x, y); setSelectedObject(obj);
                    if (obj) {
                        isDragging = true;
                        dragStartX = x - obj.x;
                        dragStartY = y - obj.y;

                        // Show grid temporarily during drag if a grid is enabled but hidden
                        if (currentGrid && !showGuides) {
                            showGuides = true;
                            tempGridVisibility = true; // Flag to remember we temporarily enabled it
                            if (showGuidesChk) showGuidesChk.checked = true;
                        }
                    }
                }
                startPinchIfPossible();
            });
            canvas.addEventListener('pointermove', (e) => {
                const { x, y } = getMousePos(e);
                if (activePointers.has(e.pointerId)) { activePointers.set(e.pointerId, { x, y }); }

                // In Play Mode, show pointer cursor when over objects
                if (interactionMode === 'play') {
                    const obj = getObjectAt(x, y);
                    canvas.style.cursor = obj ? 'pointer' : 'default';
                    return;
                }

                // --- EDIT MODE ONLY below this point ---

                // Path node dragging
                if (isDraggingPathNode && selectedPathNode) {
                    selectedPathNode.path.updateNode(selectedPathNode.nodeIndex, x, y);
                    draw();
                    return;
                }

                if (activePointers.size === 2 && pinchStartInfo && selectedObject) { 
                    // Pinch to uniformly scale (text -> size; shapes/images -> width/height)
                    const pts = Array.from(activePointers.values()); 
                    const dist = pointerDistance(pts[0], pts[1]); 
                    const scale = Math.max(0.2, dist / pinchStartInfo.distance); 
                    if (selectedObject.type === 'text') { 
                        selectedObject.size = pinchStartInfo.objOrig.size * scale; 
                        selectedObject.updateMetrics(); 
                        // Keep center consistent
                        selectedObject.x = pinchStartInfo.objOrig.x + (pinchStartInfo.objOrig.width - selectedObject.width) / 2; 
                        selectedObject.y = pinchStartInfo.objOrig.y + (pinchStartInfo.objOrig.height - selectedObject.height) / 2; 
                    } else { 
                        selectedObject.width = pinchStartInfo.objOrig.width * scale; 
                        selectedObject.height = pinchStartInfo.objOrig.height * scale; 
                    }
                    
                    // Recompute grid occupancy after pinch scaling
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                    
                    ensureRenderLoop();
                    draw(); 
                    return; 
                }
                if (isResizing) { resizeObject(x, y); return; } 
                if (isDragging && selectedObject) { 
                    // First, move object to follow mouse normally
                    const newX = x - dragStartX; 
                    const newY = y - dragStartY;
                    selectedObject.x = newX;
                    selectedObject.y = newY;
                    
                    // Then check if center should snap to grid
                    const center = getObjectCenter(selectedObject);
                    const snappedCenter = snapToGrid(center.x, center.y, e.shiftKey);
                    
                    // If snapping occurred, adjust object position so center is at snap point
                    if (snappedCenter.x !== center.x || snappedCenter.y !== center.y) {
                        setObjectCenterPosition(selectedObject, snappedCenter.x, snappedCenter.y);
                    }
                    
                    draw(); 
                    return; 
                } 
                const handle = getResizeHandleAt(x, y); 
                if (handle) { canvas.style.cursor = handle.cursor; } else if (getObjectAt(x, y)) { canvas.style.cursor = 'move'; } else { canvas.style.cursor = 'default'; }
            });
            function cancelLongPress() { clearTimeout(longPressTimer); longPressTimer = null; }
            canvas.addEventListener('pointerup', (e) => {
                cancelLongPress();

                // End path node dragging
                if (isDraggingPathNode) {
                    isDraggingPathNode = false;
                    // Keep node selected for potential deletion
                    draw();
                }

                // Final snap when releasing a dragged object
                if (isDragging && selectedObject && currentGrid && !e.shiftKey) {
                    const center = getObjectCenter(selectedObject);
                    const nearest = findNearestGridFrame(center.x, center.y);
                    if (nearest) {
                        const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                        if (distance <= snapStrength) {
                            // Use smooth animation for final snap - animate center to grid point
                            const currentCenter = getObjectCenter(selectedObject);
                            animateSnapToGrid(selectedObject, nearest.x, nearest.y, currentCenter.x, currentCenter.y);
                        }
                    }
                }
                
                if (isResizing && selectedObject) { 
                    selectedObject.initialX = selectedObject.x; 
                    selectedObject.initialY = selectedObject.y; 
                    // Recompute grid occupancy after resize is complete
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                }
                
                // Recompute grid occupancy after any dragging ends (in case object moved)
                if (isDragging && currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
                
                // Hide grid if it was temporarily shown during drag
                if (isDragging && tempGridVisibility) {
                    showGuides = false;
                    tempGridVisibility = false;
                    if (showGuidesChk) showGuidesChk.checked = false;
                    requestAnimationFrame(draw); // Force redraw to hide grid
                }

                // Trigger speech and animation in PLAY MODE ONLY
                if (interactionMode === 'play') {
                    const { x, y } = getMousePos(e);
                    const clickedObj = getObjectAt(x, y);
                    if (clickedObj) {
                        speakObjectName(clickedObj);

                        // Trigger animation if press trigger is enabled
                        if (clickedObj.triggerOnPress && clickedObj.animationType) {
                            // Stop current animation if running
                            if (clickedObj.isAnimating) {
                                clickedObj.isAnimating = false;
                                clickedObj.animationStartTime = 0;
                                clickedObj.cycleCount = 0;
                            }
                            // Start animation
                            clickedObj.isAnimating = true;
                            clickedObj.animationStartTime = performance.now();
                            clickedObj.cycleCount = 0;
                            ensureRenderLoop();
                        }
                    }
                    activePointers.delete(e.pointerId);
                    if (activePointers.size < 2) pinchStartInfo = null;
                    return;
                }

                // --- EDIT MODE ONLY below this point ---
                const wasDragging = isDragging;
                const wasResizing = isResizing;

                activePointers.delete(e.pointerId);
                if (activePointers.size < 2) pinchStartInfo = null;
                isDragging = false; isResizing = false; resizeHandle = null; 
                // Double-tap detection for quick select/deselect
                if (e.pointerType !== 'mouse') {
                    const now = performance.now();
                    const { x, y } = getMousePos(e);
                    if (now - lastTapTime < DOUBLE_TAP_MS && lastTapPos && Math.hypot(lastTapPos.x - x, lastTapPos.y - y) < DOUBLE_TAP_DIST) {
                        const obj = getObjectAt(x, y);
                        if (obj) {
                            if (selectedObject && selectedObject.id === obj.id) {
                                // Deselect
                                setSelectedObject(null);
                            } else {
                                setSelectedObject(obj);
                            }
                        }
                        lastTapTime = 0; lastTapPos = null;
                    } else {
                        lastTapTime = now; lastTapPos = { x, y };
                    }
                }
            });
            canvas.addEventListener('pointercancel', (e) => { activePointers.delete(e.pointerId); pinchStartInfo = null; cancelLongPress(); });
            canvas.addEventListener('pointerleave', (e) => { if (!canvas.hasPointerCapture?.(e.pointerId)) { activePointers.delete(e.pointerId); } });
            
            // --- Properties Panel Listeners ---
            textContentInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'text') {
                    // Store current center position before changing text
                    const currentCenterX = selectedObject.x + selectedObject.width / 2;
                    const currentCenterY = selectedObject.y + selectedObject.height / 2;
                    
                    selectedObject.text = e.target.value; 
                    selectedObject.isResizing = true; 
                    selectedObject.updateMetrics(); 
                    selectedObject.isResizing = false; 
                    
                    // Restore center position after text change
                    selectedObject.x = currentCenterX - selectedObject.width / 2;
                    selectedObject.y = currentCenterY - selectedObject.height / 2;
                    
                    // Recompute grid occupancy after text content change
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                    
                    draw(); 
                    updateLayerList(); 
                } 
            });
            textColorInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'text') { 
                    selectedObject.color = e.target.value; 
                    draw(); 
                } 
            });
            textSizeInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'text') {
                    // Store current center position before changing size
                    const currentCenterX = selectedObject.x + selectedObject.width / 2;
                    const currentCenterY = selectedObject.y + selectedObject.height / 2;
                    
                    selectedObject.size = parseInt(e.target.value); 
                    selectedObject.isResizing = true; 
                    selectedObject.updateMetrics(); 
                    selectedObject.isResizing = false; 
                    
                    // Restore center position after size change
                    selectedObject.x = currentCenterX - selectedObject.width / 2;
                    selectedObject.y = currentCenterY - selectedObject.height / 2;
                    
                    // Recompute grid occupancy after size change
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                    
                    draw(); 
                } 
            });
            // Style toggles
            textBoldToggle.addEventListener('click', () => {
                if (selectedObject?.type === 'text') {
                    const isBold = (selectedObject.fontWeight || 400) >= 600;
                    selectedObject.fontWeight = isBold ? 400 : 700;
                    textBoldToggle.classList.toggle('active', !isBold);
                    textBoldToggle.setAttribute('aria-pressed', (!isBold).toString());
                    selectedObject.updateMetrics();
                    draw();
                } else {
                    textBoldToggle.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => textBoldToggle.style.animation = '', 300);
                }
            });
            textItalicToggle.addEventListener('click', () => {
                if (selectedObject?.type === 'text') {
                    const isItalic = (selectedObject.fontStyle || 'normal') === 'italic';
                    selectedObject.fontStyle = isItalic ? 'normal' : 'italic';
                    textItalicToggle.classList.toggle('active', !isItalic);
                    textItalicToggle.setAttribute('aria-pressed', (!isItalic).toString());
                    selectedObject.updateMetrics();
                    draw();
                } else {
                    textItalicToggle.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => textItalicToggle.style.animation = '', 300);
                }
            });
            shapeColorInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'shape') { 
                    selectedObject.color = e.target.value; 
                    draw(); 
                } 
            });
            
            // Flip functionality
            flipHorizontalBtn.addEventListener('click', () => {
                if(selectedObject?.type === 'image') {
                    selectedObject.flipHorizontal = !selectedObject.flipHorizontal;
                    flipHorizontalBtn.classList.toggle('active', selectedObject.flipHorizontal);
                    draw();
                } else {
                    // Show feedback if no image selected
                    flipHorizontalBtn.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => flipHorizontalBtn.style.animation = '', 300);
                }
            });
            
            flipVerticalBtn.addEventListener('click', () => {
                if(selectedObject?.type === 'image') {
                    selectedObject.flipVertical = !selectedObject.flipVertical;
                    flipVerticalBtn.classList.toggle('active', selectedObject.flipVertical);
                    draw();
                } else {
                    // Show feedback if no image selected
                    flipVerticalBtn.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => flipVerticalBtn.style.animation = '', 300);
                }
            });

            // Rotate 90 degrees functionality
            rotate90Btn.addEventListener('click', () => {
                if(selectedObject && selectedObject.type !== 'text') {
                    // Initialize rotation if it doesn't exist
                    if (!selectedObject.rotation) {
                        selectedObject.rotation = 0;
                    }
                    // Add 90 degrees (converted to radians)
                    selectedObject.rotation += (90 * Math.PI) / 180;
                    // Keep rotation between 0-2 radians
                    if (selectedObject.rotation >= 2 * Math.PI) {
                        selectedObject.rotation -= 2 * Math.PI;
                    }
                    draw();
                } else {
                    // Show feedback if no object selected
                    rotate90Btn.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => rotate90Btn.style.animation = '', 300);
                }
            });

            // Speech mode radio button handlers
            speechModeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    if (selectedObject) {
                        selectedObject.speechMode = e.target.value;
                        // Show/hide custom input based on selection
                        if (e.target.value === 'custom') {
                            customSpeechInputContainer.classList.remove('hidden');
                            customSpeechText.focus();
                        } else {
                            customSpeechInputContainer.classList.add('hidden');
                        }
                        // Save TTS settings
                        saveTTSSettingsForObject(selectedObject);
                    }
                });
            });

            // Custom speech text input handler
            customSpeechText.addEventListener('input', (e) => {
                if (selectedObject && selectedObject.speechMode === 'custom') {
                    selectedObject.customSpeechText = e.target.value;
                    // Save TTS settings
                    saveTTSSettingsForObject(selectedObject);
                }
            });

            // Mode toggle button handler
            modeToggleBtn.addEventListener('click', () => {
                const newMode = interactionMode === 'edit' ? 'play' : 'edit';
                setInteractionMode(newMode);
            });

            // --- Speech Functions ---
            function getDefaultSpeechText(obj) {
                if (!obj) return '';

                switch(obj.type) {
                    case 'text':
                        // For text objects, read the text content
                        return obj.text || '';

                    case 'shape':
                        // For shapes, read the shape type
                        const shapeNames = {
                            'rect': 'rectangle',
                            'square': 'square',
                            'circle': 'circle',
                            'triangle': 'triangle',
                            'star': 'star',
                            'octagon': 'octagon'
                        };
                        return shapeNames[obj.shapeType] || obj.shapeType || 'shape';

                    case 'image':
                    case 'foreground':
                        // For images, extract filename without extension
                        if (obj.name) {
                            // Remove [FG] prefix if present
                            let name = obj.name.replace(/^\[FG\]\s*/, '');
                            // Remove file extension
                            name = name.replace(/\.[^/.]+$/, '');
                            return name;
                        }
                        return 'image';

                    case 'video':
                        // For videos, extract filename without extension
                        if (obj.name) {
                            let name = obj.name.replace(/\.[^/.]+$/, '');
                            return name;
                        }
                        return 'video';

                    default:
                        return '';
                }
            }

            function speakObjectName(obj) {
                if (!obj || obj.speechMode === 'none') return;

                let textToSpeak = '';

                if (obj.speechMode === 'custom') {
                    textToSpeak = obj.customSpeechText || '';
                } else if (obj.speechMode === 'default') {
                    textToSpeak = getDefaultSpeechText(obj);
                }

                if (textToSpeak && 'speechSynthesis' in window) {
                    // Cancel any ongoing speech
                    window.speechSynthesis.cancel();

                    const utterance = new SpeechSynthesisUtterance(textToSpeak);
                    window.speechSynthesis.speak(utterance);
                }
            }

            // --- Mode Switching Functions ---
            function setInteractionMode(mode) {
                interactionMode = mode;

                if (mode === 'play') {
                    // Currently in Play Mode
                    // Update current mode display (green for Play)
                    currentModeName.textContent = 'PLAY MODE';
                    currentModeDescription.textContent = 'Interact with targets';
                    currentModeIconEdit.classList.add('hidden');
                    currentModeIconPlay.classList.remove('hidden');
                    modeDescription.style.background = '#4caf50'; // Green for Play Mode
                    modeDescription.style.borderColor = '#4caf50';

                    // Update switch button (blue for Edit)
                    modeToggleText.textContent = 'EDIT MODE';
                    switchIconEdit.classList.remove('hidden');
                    switchIconPlay.classList.add('hidden');
                    modeToggleBtn.style.background = '#1976d2'; // Blue for Edit Mode
                    modeToggleBtn.style.color = 'white';
                    modeToggleBtn.style.borderColor = '#1976d2';

                    // Hide editing tools and properties
                    editModeTools.style.display = 'none';
                    propertiesPanel.style.display = 'none';

                    // Deselect any selected object
                    setSelectedObject(null);

                    // Clear any path drawing and editing state
                    isDrawingPath = false;
                    pathDrawingObject = null;
                    selectedPathNode = null;
                    isDraggingPathNode = false;

                    // Change cursor to default
                    canvas.style.cursor = 'default';
                } else {
                    // Currently in Edit Mode
                    // Update current mode display (blue for Edit)
                    currentModeName.textContent = 'EDIT MODE';
                    currentModeDescription.textContent = 'Create and modify targets';
                    currentModeIconEdit.classList.remove('hidden');
                    currentModeIconPlay.classList.add('hidden');
                    modeDescription.style.background = '#1976d2'; // Blue for Edit Mode
                    modeDescription.style.borderColor = '#1976d2';

                    // Update switch button (green for Play)
                    modeToggleText.textContent = 'PLAY MODE';
                    switchIconEdit.classList.add('hidden');
                    switchIconPlay.classList.remove('hidden');
                    modeToggleBtn.style.background = '#4caf50'; // Green for Play Mode
                    modeToggleBtn.style.color = 'white';
                    modeToggleBtn.style.borderColor = '#4caf50';

                    // Show editing tools and properties
                    editModeTools.style.display = 'block';
                    propertiesPanel.style.display = 'block';

                    // Reset to select tool to ensure targets can be selected
                    setActiveTool('select');

                    // Clear any path drawing and editing state
                    isDrawingPath = false;
                    pathDrawingObject = null;
                    selectedPathNode = null;
                    isDraggingPathNode = false;
                }

                draw();
            }

            // --- Other functions (BG/FG controls, Resizing, Animation, etc.) ---
            function moveObject(objectId, direction) { 
                const sorted = [...objects].sort((a, b) => a.zIndex - b.zIndex); 
                const currentIndex = sorted.findIndex(o => o.id === objectId); 
                let swapIndex; 
                if (direction === 'up') { 
                    swapIndex = currentIndex + 1; 
                } else { 
                    swapIndex = currentIndex - 1; 
                } 
                if (swapIndex >= 0 && swapIndex < sorted.length) { 
                    let tempZ = sorted[currentIndex].zIndex; 
                    sorted[currentIndex].zIndex = sorted[swapIndex].zIndex; 
                    sorted[swapIndex].zIndex = tempZ; 
                } 
                draw(); 
                updateLayerList(); 
            }
            
            function getNextZIndex() { 
                const maxZ = objects.reduce((max, obj) => (obj.zIndex > max ? obj.zIndex : max), 0); 
                return maxZ + 1; 
            }
            
            // Background color handling
            bgColorSlider.addEventListener('input', (e) => { 
                backgroundColor = e.target.value; 
                backgroundImage = null; 
                deleteBgBtn.classList.add('hidden'); 
                bgImageInput.value = ''; 
                
                // Update selected state on preset buttons
                presetColorBtns.forEach(btn => {
                    if (btn.dataset.color === e.target.value) {
                        btn.classList.add('selected');
                    } else {
                        btn.classList.remove('selected');
                    }
                });
                
                draw(); 
            });
            
            presetColorBtns.forEach(btn => { 
                btn.addEventListener('click', (e) => { 
                    // Remove selected class from all buttons
                    presetColorBtns.forEach(b => b.classList.remove('selected'));
                    // Add selected class to clicked button
                    e.target.classList.add('selected');
                    
                    backgroundColor = e.target.dataset.color; 
                    bgColorSlider.value = backgroundColor; 
                    backgroundImage = null; 
                    deleteBgBtn.classList.add('hidden'); 
                    bgImageInput.value = ''; 
                    draw(); 
                }); 
            });
            bgImageInput.addEventListener('change', (e) => { 
                const file = e.target.files[0]; 
                if (file) { 
                    // Store fullscreen state before loading
                    const wasFullscreen = !!document.fullscreenElement;
                    
                    const reader = new FileReader(); 
                    reader.onload = (event) => { 
                        const img = new Image(); 
                        img.onload = async () => { 
                            img.dataset.name = file.name;
                            backgroundImage = { img: img, name: 'Background Image' }; 
                            updateBgFgDeleteStates(); 
                            // Add to media library
                            addToMediaLibrary(img, 'backgrounds');
                            draw(); 
                            
                            // Restore fullscreen state if it was active before loading
                            if (wasFullscreen && !document.fullscreenElement) {
                                try {
                                    await document.documentElement.requestFullscreen();
                                } catch (error) {
                                    console.log('Could not restore fullscreen after background image loading:', error);
                                }
                            }
                        }; 
                        img.src = event.target.result; 
                    }; 
                    reader.readAsDataURL(file); 
                } 
            });
            
            deleteBgBtn.addEventListener('click', () => { 
                if (!backgroundImage) return; 
                backgroundImage = null; 
                bgImageInput.value = ''; 
                updateBgFgDeleteStates();
                draw(); 
            });
            
            fgImageInput.addEventListener('change', (e) => { 
                const file = e.target.files[0]; 
                if (file) { 
                    // Store fullscreen state before loading
                    const wasFullscreen = !!document.fullscreenElement;
                    
                    const reader = new FileReader(); 
                    reader.onload = (event) => { 
                        const img = new Image(); 
                        img.onload = async () => { 
                            img.dataset.name = file.name;
                            foregroundImage = { img: img, name: 'Foreground Image' }; 
                            updateBgFgDeleteStates(); 
                            // Add to media library
                            addToMediaLibrary(img, 'foregrounds');
                            draw(); 
                            
                            // Restore fullscreen state if it was active before loading
                            if (wasFullscreen && !document.fullscreenElement) {
                                try {
                                    await document.documentElement.requestFullscreen();
                                } catch (error) {
                                    console.log('Could not restore fullscreen after foreground image loading:', error);
                                }
                            }
                        }; 
                        img.src = event.target.result; 
                    }; 
                    reader.readAsDataURL(file); 
                } 
            });
            
            deleteFgBtn.addEventListener('click', () => { 
                if (!foregroundImage) return; 
                foregroundImage = null; 
                fgImageInput.value = ''; 
                updateBgFgDeleteStates();
                draw(); 
            });
            
            // --- Resize Handle Functions ---
            function getResizeHandles(obj) { 
                const s = handleSize; 
                return [ 
                    { position: 'tl', x: obj.x - s/2, y: obj.y - s/2, size: s, cursor: 'nwse-resize' }, 
                    { position: 'tr', x: obj.x + obj.width - s/2, y: obj.y - s/2, size: s, cursor: 'nesw-resize' }, 
                    { position: 'bl', x: obj.x - s/2, y: obj.y + obj.height - s/2, size: s, cursor: 'nesw-resize' }, 
                    { position: 'br', x: obj.x + obj.width - s/2, y: obj.y + obj.height - s/2, size: s, cursor: 'nwse-resize' }, 
                ]; 
            }
            function pointerDistance(p1, p2) { const dx = p1.x - p2.x; const dy = p1.y - p2.y; return Math.hypot(dx, dy); }
            function startPinchIfPossible() { 
                if (activePointers.size === 2 && selectedObject) { 
                    const pts = Array.from(activePointers.values()); 
                    pinchStartInfo = { distance: pointerDistance(pts[0], pts[1]), objOrig: { x: selectedObject.x, y: selectedObject.y, width: selectedObject.width, height: selectedObject.height, size: selectedObject.size } }; 
                } 
            }
            
            function getResizeHandleAt(x, y) { 
                if (!selectedObject) return null; 
                for (const handle of getResizeHandles(selectedObject)) { 
                    if (x >= handle.x && x <= handle.x + handle.size && y >= handle.y && y <= handle.y + handle.size) { 
                        return { object: selectedObject, position: handle.position, cursor: handle.cursor }; 
                    } 
                } 
                return null; 
            }
            
            function resizeObject(mouseX, mouseY) { 
                if (!selectedObject || !selectedObject.original) return; 
                const obj = selectedObject; 
                const orig = obj.original; 
                
                // Check if object is pinned to a grid point
                let pinnedGridPoint = null;
                if (currentGrid && gridFrames.length > 0) {
                    const center = getObjectCenter(obj);
                    const nearest = findNearestGridFrame(center.x, center.y);
                    if (nearest) {
                        const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                        if (distance <= 20) { // Use same threshold as occupancy detection
                            pinnedGridPoint = nearest;
                        }
                    }
                }
                
                if (obj.type === 'text') { 
                    // Store the original center position (from when resize started or grid point if pinned)
                    let centerX, centerY;
                    if (pinnedGridPoint) {
                        centerX = pinnedGridPoint.x;
                        centerY = pinnedGridPoint.y;
                    } else {
                        centerX = orig.x + orig.width / 2; 
                        centerY = orig.y + orig.height / 2;
                    }
                    
                    // Calculate scale based on the resize handle being dragged
                    let scale = 1;
                    switch (resizeHandle) {
                        case 'br': // Bottom-right handle
                            const deltaX = mouseX - (orig.x + orig.width);
                            const deltaY = mouseY - (orig.y + orig.height);
                            const avgDelta = (deltaX + deltaY) / 2;
                            scale = Math.max(0.2, 1 + avgDelta / 100); // Adjust sensitivity
                            break;
                        case 'tl': // Top-left handle  
                            const deltaX2 = orig.x - mouseX;
                            const deltaY2 = orig.y - mouseY;
                            const avgDelta2 = (deltaX2 + deltaY2) / 2;
                            scale = Math.max(0.2, 1 + avgDelta2 / 100);
                            break;
                        default:
                            // For other handles, use distance from center
                            const dist = Math.hypot(mouseX - centerX, mouseY - centerY);
                            const baseDist = Math.max(orig.width, orig.height) / 2;
                            scale = Math.max(0.2, dist / baseDist);
                    }
                    
                    obj.size = Math.max(10, orig.size * scale); 
                    obj.isResizing = true; 
                    obj.updateMetrics(); 
                    obj.isResizing = false;
                    
                    // Keep text centered at pinned grid point or original position
                    obj.x = centerX - obj.width / 2; 
                    obj.y = centerY - obj.height / 2; 
                } else { 
                    const aspectRatio = orig.width / orig.height; 
                    let newWidth, newHeight; 
                    
                    if (pinnedGridPoint) {
                        // For grid-pinned objects, resize from center
                        const originalCenterX = pinnedGridPoint.x;
                        const originalCenterY = pinnedGridPoint.y;
                        
                        // Calculate distance from mouse to center to determine scale
                        const mouseDist = Math.hypot(mouseX - originalCenterX, mouseY - originalCenterY);
                        const originalDist = Math.hypot(orig.width / 2, orig.height / 2);
                        const scale = Math.max(0.2, mouseDist / originalDist);
                        
                        newWidth = Math.max(10, orig.width * scale);
                        newHeight = Math.max(10, orig.height * scale);
                        
                        // Position object so its center stays at the grid point
                        obj.x = originalCenterX - newWidth / 2;
                        obj.y = originalCenterY - newHeight / 2;
                    } else {
                        // Original corner-based resizing for non-pinned objects
                        switch (resizeHandle) { 
                            case 'br': 
                                newWidth = mouseX - orig.x; 
                                newHeight = mouseY - orig.y; 
                                obj.x = orig.x; 
                                obj.y = orig.y; 
                                break; 
                            case 'bl': 
                                newWidth = (orig.x + orig.width) - mouseX; 
                                newHeight = mouseY - orig.y; 
                                obj.x = mouseX; 
                                obj.y = orig.y; 
                                break; 
                            case 'tr': 
                                newWidth = mouseX - orig.x; 
                                newHeight = (orig.y + orig.height) - mouseY; 
                                obj.x = orig.x; 
                                obj.y = (orig.y + orig.height) - newHeight; 
                                break; 
                            case 'tl': 
                                newWidth = (orig.x + orig.width) - mouseX; 
                                newHeight = (orig.y + orig.height) - mouseY; 
                                obj.x = mouseX; 
                                obj.y = (orig.y + orig.height) - newHeight; 
                                break; 
                        }
                    }
                    
                    // For rectangles, allow deformation but snap to square when close
                    if (obj.shapeType === 'rect') {
                        const snapThreshold = 20; // Snap when within 20 pixels
                        const sizeDifference = Math.abs(newWidth - newHeight);
                        
                        if (sizeDifference < snapThreshold) {
                            // Snap to square - use the average size
                            const avgSize = (newWidth + newHeight) / 2;
                            newWidth = avgSize;
                            newHeight = avgSize;
                        }
                    } else if (obj.shapeType === 'square') {
                        // Always enforce square aspect ratio
                        const avgSize = Math.max(10, Math.min(Math.max(newWidth, 10), Math.max(newHeight, 10)));
                        newWidth = avgSize;
                        newHeight = avgSize;
                    } else {
                        // For other shapes (circles, triangles), maintain aspect ratio
                        newHeight = newWidth / aspectRatio;
                    }
                    
                    obj.width = newWidth > 10 ? newWidth : 10; 
                    obj.height = newHeight > 10 ? newHeight : 10; 
                } 
                
                // Recompute grid occupancy after resize since object center may have changed
                if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
                
                draw(); 
            }
            
            // --- Context Menu Functions ---
            function showContextMenu(x, y) { 
                // Determine if selection supports animation (text, shape, image only)
                const animateBtn = document.getElementById('ctx-animate');
                const animatableTypes = ['text','shape','image'];
                const canAnimate = selectedObject && animatableTypes.includes(selectedObject.type);
                animateBtn.style.display = canAnimate ? 'flex' : 'none';
                contextMenu.style.display = 'block'; 
                contextMenu.style.left = `${x}px`; 
                contextMenu.style.top = `${y}px`; 
            }
            
            function hideContextMenu() { 
                contextMenu.style.display = 'none'; 
            }
            
            function deleteObject(obj) { 
                objects = objects.filter(o => o.id !== obj.id); 
                setSelectedObject(null); 
                hideContextMenu(); 
                updateAnimationTriggerPanel(); // Update animation panel when object is deleted
                
                // Recompute grid occupancy after object deletion
                if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
            }
            
            // --- Event Listeners ---
            document.addEventListener('click', hideContextMenu);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            
            document.getElementById('ctx-delete').addEventListener('click', () => { 
                if (selectedObject) deleteObject(selectedObject); 
            });
            
            document.getElementById('ctx-bring-to-front').addEventListener('click', () => { 
                if(selectedObject) { 
                    selectedObject.zIndex = getNextZIndex(); 
                    draw(); 
                    updateLayerList(); 
                }
            });
            
            document.getElementById('ctx-send-to-back').addEventListener('click', () => { 
                if(selectedObject) { 
                    const minZ = Math.min(...objects.map(o => o.zIndex).filter(z => z > 0)); 
                    selectedObject.zIndex = minZ - 1; 
                    draw(); 
                    updateLayerList(); 
                }
            });
            
            // Legacy context menu animate removed in favor of drawer controls.
            
            animationDuration.addEventListener('input', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                if (selectedObject) {
                    selectedObject.animationDuration = parseFloat(e.target.value);
                    durationValue.textContent = parseFloat(e.target.value).toFixed(1) + 's';
                }
            });

            // Font selection for text objects
        textFontSelect.addEventListener('change', (e) => {
                e.stopPropagation();
                if (selectedObject && selectedObject.type === 'text') {
                    const val = e.target.value;
                    let ff = 'Luciole, "Atkinson Hyperlegible", Inter, system-ui, sans-serif';
                    if (val === 'atkinson') ff = '"Atkinson Hyperlegible", Luciole, Inter, system-ui, sans-serif';
            else if (val === 'andika') ff = 'Andika, Inter, system-ui, sans-serif';
                    else if (val === 'serif') ff = '"Noto Serif", Georgia, serif';
                    else if (val === 'inter') ff = 'Inter, system-ui, sans-serif';
                    else if (val === 'system') ff = 'system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
                    selectedObject.fontFamily = ff;
                    // Recalculate metrics and redraw
                    selectedObject.updateMetrics();
                    draw();
                }
            });
            
            animationIntensity.addEventListener('input', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                if (selectedObject) {
                    selectedObject.animationIntensity = parseInt(e.target.value);
                    intensityValue.textContent = e.target.value;
                }
            });
            
            // Preview button removed in simplified UI; retained logic not needed.
            
            // Keyboard shortcuts for animation triggers (works in both Edit and Play modes)
            document.addEventListener('keydown', (e) => {
                // Only trigger if no input is focused
                if (document.activeElement.tagName === 'INPUT' ||
                    document.activeElement.tagName === 'TEXTAREA' ||
                    document.activeElement.tagName === 'SELECT') {
                    return;
                }

                // Find objects that have keyboard triggers matching the pressed key
                const key = e.key.toLowerCase();
                objects.forEach(obj => {
                    if (obj.triggerOnKey && obj.triggerKey && obj.triggerKey.toLowerCase() === key && obj.animationType) {
                        e.preventDefault();
                        // Stop current animation if running
                        if (obj.isAnimating) {
                            obj.isAnimating = false;
                            obj.animationStartTime = 0;
                            obj.cycleCount = 0;
                        }
                        // Start animation
                        obj.isAnimating = true;
                        obj.animationStartTime = performance.now();
                        obj.cycleCount = 0;
                        ensureRenderLoop();
                    }
                });
            });
            
            // --- Keyboard Events ---
            window.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

                // Path drawing shortcuts
                if (isDrawingPath && pathDrawingObject && pathDrawingObject.animationPath) {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        finishDrawingPath();
                        return;
                    }
                    if (e.key === 'Backspace' || e.key === 'Delete') {
                        e.preventDefault();
                        // If a node is selected, delete it; otherwise remove last node
                        if (selectedPathNode && selectedPathNode.path === pathDrawingObject.animationPath) {
                            pathDrawingObject.animationPath.removeNode(selectedPathNode.nodeIndex);
                            selectedPathNode = null;
                        } else {
                            pathDrawingObject.animationPath.removeLastNode();
                        }
                        draw();
                        return;
                    }
                    if (e.key.toLowerCase() === 'c') {
                        e.preventDefault();
                        if (pathDrawingObject.animationPath.nodes.length >= 3) {
                            pathDrawingObject.animationPath.closePath();
                            draw();
                        }
                        return;
                    }
                }

                // Path editing shortcuts (when path exists but not in drawing mode)
                if (selectedObject && selectedObject.animationPath && selectedObject.animationType === 'path' && !isDrawingPath) {
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        e.preventDefault();
                        if (selectedPathNode && selectedPathNode.path === selectedObject.animationPath) {
                            selectedObject.animationPath.removeNode(selectedPathNode.nodeIndex);
                            selectedPathNode = null;
                            draw();
                        }
                        return;
                    }
                }

                // Drawer Toggles
                if (e.ctrlKey && e.key === 'l') {
                    e.preventDefault();
                    toggleControlsBtn.click();
                }
                if (e.ctrlKey && e.key === 'm') {
                    e.preventDefault();
                    toggleLibraryBtn.click();
                }

                // Grid shortcuts
                if (e.key === 'g' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    // Toggle guide visibility
                    showGuidesChk.checked = !showGuidesChk.checked;
                    showGuides = showGuidesChk.checked;
                    requestAnimationFrame(draw);
                }
                
                // Grid layout shortcuts (Ctrl + 2/4/6/9/1 for 2/4/6/9/12)
                if (e.ctrlKey && ['2', '4', '6', '9', '1'].includes(e.key)) {
                    e.preventDefault();
                    let gridCount;
                    switch(e.key) {
                        case '2': gridCount = 2; break;
                        case '4': gridCount = 4; break;
                        case '6': gridCount = 6; break;
                        case '9': gridCount = 9; break;
                        case '1': gridCount = 12; break; // Ctrl+1 for 12-grid
                    }
                    setGrid(gridCount);
                }
                
                // Arrange targets (Ctrl+Shift+G)
                if (e.ctrlKey && e.shiftKey && e.key === 'G') {
                    e.preventDefault();
                    if (currentGrid && arrangeTargetsBtn) {
                        arrangeTargetsBtn.click();
                    }
                }

                if (e.key === 'v') setActiveTool('select'); 
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedObject) { 
                    deleteObject(selectedObject); 
                } 
            });

            // --- Data Loss Warning ---
            let hasUnsavedChanges = false;
            
            // Track changes when objects are added
            const trackObjectChanges = () => {
                hasUnsavedChanges = true;
            };
            
            // Override objects.push to track changes
            const originalPush = objects.push;
            objects.push = function(...items) {
                trackObjectChanges();
                return originalPush.apply(this, items);
            };
            
            // Track deletions
            const originalDeleteObject = deleteObject;
            window.deleteObject = (obj) => {
                originalDeleteObject(obj);
                trackObjectChanges();
            };
            
            // Warn before page unload
            window.addEventListener('beforeunload', (e) => {
                if (hasUnsavedChanges && objects.length > 0) {
                    const message = 'You have unsaved work. Are you sure you want to leave? All canvas objects will be lost.';
                    e.preventDefault();
                    e.returnValue = message;
                    return message;
                }
            });

            // PWA and Service Worker initialization now handled by external modules
            // See js/pwa.js and js/service-worker-manager.js
        });
    </script>

    <!-- PWA and Service Worker Modules -->
    <script type="module">
        import { initPWA } from './js/pwa.js';
        import { initServiceWorker } from './js/service-worker-manager.js';

        // Initialize PWA functionality
        initPWA();
        initServiceWorker();
    </script>
</body>
</html>
