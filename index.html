<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaze Tracking Canvas - Cortical Visual Impairment Therapy</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Visual Target Management System for Cortical Visual Impairment Therapy by Niall Brown - ECVC">
    <meta name="keywords" content="gaze tracking, visual therapy, cortical visual impairment, CVI, eye tracking, visual targets">
    <meta name="author" content="Niall Brown - Early Childhood Vision Consultant">
    <meta name="theme-color" content="#3b82f6">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Gaze Tracker">
    <meta name="msapplication-TileColor" content="#1e293b">
    <meta name="msapplication-config" content="browserconfig.xml">
    
    <!-- Manifest and Icons -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="gazetracker.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-72x72.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
    <link rel="mask-icon" href="gazetracker.svg" color="#3b82f6">
    
    <!-- Stylesheets -->
    <link rel="stylesheet" href="./dist/output.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Andika:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <link rel="preload" as="font" href="./fonts/Luciole_webfonts/Luciole-Regular/Luciole-Regular.woff2" type="font/woff2" crossorigin>
    <style>
        /* Luciole webfonts (self-hosted) */
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-Regular/Luciole-Regular.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-Regular/Luciole-Regular.woff') format('woff');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-Italic/Luciole-Italic.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-Italic/Luciole-Italic.woff') format('woff');
            font-weight: 400;
            font-style: italic;
            font-display: swap;
        }
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-Bold/Luciole-Bold.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-Bold/Luciole-Bold.woff') format('woff');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Luciole';
            src: url('./fonts/Luciole_webfonts/Luciole-BoldItalic/Luciole-BoldItalic.woff2') format('woff2'),
                 url('./fonts/Luciole_webfonts/Luciole-BoldItalic/Luciole-BoldItalic.woff') format('woff');
            font-weight: 700;
            font-style: italic;
            font-display: swap;
        }
        :root {
            /* Material Design 3 tokens (light) */
            --md-primary: #3b82f6;
            --md-on-primary: #ffffff;
            --md-primary-container: #dbeafe;
            --md-on-primary-container: #0b3a82;
            --md-surface: #ffffff;
            --md-surface-variant: #f2f4f7;
            --md-on-surface: #1f2937;
            --md-on-surface-variant: #475569;
            --md-outline: #d0d5dd;
            --md-outline-variant: #e5e7eb;
            --md-error: #ef4444;
            --md-on-error: #ffffff;
            /* Elevations */
            --md-elev-0: none;
            --md-elev-1: 0 1px 2px rgba(16, 24, 40, 0.06), 0 1px 3px rgba(16, 24, 40, 0.10);
            --md-elev-2: 0 2px 4px rgba(16, 24, 40, 0.08), 0 4px 8px rgba(16, 24, 40, 0.08);
            --md-elev-3: 0 8px 12px rgba(16, 24, 40, 0.10), 0 2px 6px rgba(16, 24, 40, 0.08);

            /* Back-compat variables mapped to MD tokens */
            --primary-color: var(--md-primary);
            --primary-hover: #2563eb;
            --text-primary: var(--md-on-surface);
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;
            --border-color: var(--md-outline);
            --bg-primary: var(--md-surface);
            --bg-secondary: var(--md-surface-variant);
            --bg-tertiary: #eef2f6;
            --glass-bg: var(--md-surface);
            --glass-border: var(--md-outline-variant);
            --shadow-sm: var(--md-elev-1);
            --shadow-md: var(--md-elev-1);
            --shadow-lg: var(--md-elev-2);
            --shadow-xl: var(--md-elev-3);
            --shadow-2xl: var(--md-elev-3);
            --shadow-glow: none;
            --shadow-inner: inset 0 1px 2px rgba(16,24,40,0.04);

            /* Scrollbar (light) */
            --scrollbar-track: var(--bg-secondary);
            --scrollbar-thumb: #cbd5e1; /* slate-300 */
            --scrollbar-thumb-hover: var(--primary-color);
        }
        
        .dark {
            /* Material Design 3 tokens (dark) */
            --md-primary: #5fa8ff;
            --md-on-primary: #0b1220;
            --md-primary-container: #0b1220;
            --md-on-primary-container: #cfe3ff;
            --md-surface: #0d141c;
            --md-surface-variant: #151c26;
            --md-on-surface: #e6edf3;
            --md-on-surface-variant: #b5c2cf;
            --md-outline: #253242;
            --md-outline-variant: #1b2633;
            --md-error: #ffb4ab;
            --md-on-error: #690005;
            --md-elev-0: none;
            --md-elev-1: 0 1px 2px rgba(0, 0, 0, 0.35), 0 1px 3px rgba(0, 0, 0, 0.30);
            --md-elev-2: 0 2px 4px rgba(0, 0, 0, 0.45), 0 4px 8px rgba(0, 0, 0, 0.35);
            --md-elev-3: 0 8px 12px rgba(0, 0, 0, 0.50), 0 2px 6px rgba(0, 0, 0, 0.40);

            /* Back-compat mappings */
            --primary-color: var(--md-primary);
            --primary-hover: #428fe8;
            --text-primary: var(--md-on-surface);
            --text-secondary: #b5c2cf;
            --text-muted: #6e7b89;
            --border-color: var(--md-outline);
            --bg-primary: var(--md-surface);
            --bg-secondary: var(--md-surface-variant);
            --bg-tertiary: #101722;
            --glass-bg: var(--md-surface);
            --glass-border: var(--md-outline-variant);
            --shadow-sm: var(--md-elev-1);
            --shadow-md: var(--md-elev-1);
            --shadow-lg: var(--md-elev-2);
            --shadow-xl: var(--md-elev-3);
            --shadow-2xl: var(--md-elev-3);
            --shadow-glow: none;
            --shadow-inner: inset 0 1px 2px rgba(0,0,0,0.25);

            /* Scrollbar (dark) */
            --scrollbar-track: var(--md-surface-variant);
            --scrollbar-thumb: var(--text-muted);
            --scrollbar-thumb-hover: var(--primary-color);
        }
        
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            font-feature-settings: 'cv01', 'cv03', 'cv04', 'cv11';
            overscroll-behavior: none;
            background: var(--bg-primary);
            background-image: none;
            color: var(--text-primary);
            /* Limit transitions to avoid paint glitches on text */
            transition: background-color 0.4s cubic-bezier(0.4, 0, 0.2, 1), color 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 100vh;
        }
        .drawer {
            /* Avoid transitioning "all" to prevent text paint issues during open/close */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.4s cubic-bezier(0.4, 0, 0.2, 1), background 0.4s cubic-bezier(0.4, 0, 0.2, 1), border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: fixed;
            top: 0;
            height: 100vh;
            max-height: 100vh;
            background: var(--md-surface);
            box-shadow: var(--md-elev-2);
            z-index: 50;
            border: 1px solid var(--md-outline-variant);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .drawer::before { content: none; }
        
        .drawer-toggle {
            position: fixed;
            top: 20%;
            transform: translateY(-50%);
            background: var(--md-surface-variant);
            border: 1px solid var(--md-outline);
            padding: 12px;
            z-index: 60; /* above .drawer (50) */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 0;
            transition: background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            box-shadow: var(--md-elev-2);
            border-radius: 12px;
        }
        .drawer-right {
            right: 0;
            transform: translateX(100%);
        }
        
        .drawer-right.open {
            transform: translateX(0);
        }
        /* Re-add left drawer closed/open states */
        .drawer-left {
            left: 0;
            transform: translateX(-100%);
            border-right: 1px solid var(--border-color);
        }
        .drawer-left.open {
            transform: translateX(0);
        }
        
        
    .drawer-toggle::before { content: none; }
        
        .drawer-toggle:hover {
            background: var(--bg-secondary);
            box-shadow: var(--md-elev-3);
            transform: translateY(-50%) scale(1.03);
        }
        
        .drawer-toggle-left {
            left: 0;
            border-top-right-radius: 12px;
            border-bottom-right-radius: 12px;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-left: none;
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .drawer-left.open ~ .drawer-toggle-left {
            left: 320px;
        }
        
        .drawer-toggle-right {
            right: 0;
            border-top-left-radius: 12px;
            border-bottom-left-radius: 12px;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: none;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .drawer-right.open ~ .drawer-toggle-right {
            right: 320px;
        }
        
        .drawer-toggle svg {
            color: var(--primary-color);
            transition: color 0.2s ease;
            width: 20px;
            height: 20px;
        }
        
        .drawer-toggle:hover svg {
            color: var(--primary-hover);
        }
        /* Tool button base */
        .tool-button {
            transition: background 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease, color 0.15s ease;
            background: var(--bg-secondary);
            border: 1px solid var(--md-outline);
            border-radius: 12px;
            color: var(--text-secondary);
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
            font-weight: 500;
        }
        
    .tool-button::before { content: none; }
        
        .tool-button:hover {
            background: var(--bg-tertiary);
            box-shadow: var(--shadow-md);
            color: var(--text-primary);
            border-color: var(--md-outline);
        }
        
        .tool-button:hover::before {
            opacity: 1;
        }
        
        .tool-button.active {
            background: var(--md-primary);
            color: var(--md-on-primary);
            font-weight: 600;
            box-shadow: var(--shadow-md);
            border-color: var(--md-primary);
        }
        
        .tool-button.active::before {
            opacity: 0;
        }
        
        .tool-button svg {
            transition: transform 0.2s ease;
        }
        
        .tool-button:hover svg {
            transform: scale(1.1);
        }

        /* Enhanced styling for shape tool icons */
        .tool-button svg defs {
            pointer-events: none;
        }
        
        .tool-button:hover svg stop[offset="0%"] {
            stop-opacity: 0.9;
        }
        
        .tool-button.active svg stop[offset="0%"] {
            stop-color: white;
            stop-opacity: 1;
        }
        
        .tool-button.active svg stop[offset="100%"] {
            stop-color: white;
            stop-opacity: 0.7;
        }

        /* Accessible focus states */
        .tool-button:focus-visible,
        .upload-button:focus-visible,
        .delete-button:focus-visible,
        .layer-item-button:focus-visible,
        .preset-color-bg:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        /* Move accordion focus outline to the outer card to avoid double border */
        .accordion-button:focus-visible { outline: none; }
        .section-header:focus-within {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
            border-radius: 12px;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: var(--bg-primary);
            background-image: none;
            overflow: hidden;
        }
        
    #canvas-container::before { content: none; }
        
        canvas {
            display: block;
            border-radius: 0;
            position: relative;
            z-index: 2;
            touch-action: none; /* Enable custom gesture handling for touch */
        }
        
        .context-menu {
            display: none;
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--md-outline-variant);
            border-radius: 12px;
            box-shadow: var(--shadow-xl);
            z-index: 1000;
            overflow: hidden;
            min-width: 200px;
        }
        
    .context-menu::before { content: none; }
        
        .context-menu button {
            display: block;
            width: 100%;
            padding: 14px 18px;
            text-align: left;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            transition: background 0.2s ease, color 0.2s ease;
            position: relative;
            z-index: 1;
        }
        
        .context-menu button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .context-menu button.danger {
            color: var(--danger-color);
        }
        
        .context-menu button.danger:hover {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger-color);
        }
        
        .context-menu hr {
            margin: 8px 0;
            border: none;
            border-top: 1px solid var(--md-outline-variant);
            opacity: 0.6;
        }
        .accordion-button {
            font-weight: 600;
            color: var(--text-secondary);
            border-radius: inherit; /* match outer card radius to avoid double contour */
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            background: transparent; /* let section-header own the glass look */
            backdrop-filter: none;
            border: none; /* avoid double border: header draws the border */
            letter-spacing: .3px;
            box-shadow: none; /* avoid double edge with header shadow */
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            will-change: background, border-color;
        }
        
    .accordion-button:hover { color: var(--text-primary); }
        
        .accordion-button svg.arrow-icon {
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--primary-color);
            filter: none;
            transform: rotate(0deg); /* Expanded (default open) points down */
        }

        /* Collapsed state: rotate to point right */
        .accordion-button[aria-expanded="false"] svg.arrow-icon {
            transform: rotate(-90deg);
        }
        
        .section-header {
            background: var(--bg-secondary);
            border-radius: 12px;
            margin-bottom: 8px;
            border: 1px solid var(--md-outline-variant);
            box-shadow: none;
            transition: border-color 0.2s ease, background 0.2s ease;
            contain: paint;
            background-clip: padding-box;
        }
        
    .section-header:hover { box-shadow: none; transform: none; border-color: var(--md-outline-variant); }
        
        .section-content {
            background: var(--bg-primary);
            border-radius: 12px;
            border: 1px solid var(--md-outline-variant);
            box-shadow: var(--shadow-sm);
            transition: border-color 0.2s ease, background 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
    .section-content::before { content: none; }
        .layer-item-button {
            background: transparent;
            border: none;
            padding: 2px;
            border-radius: 3px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 9px;
            position: relative;
            overflow: hidden;
            min-width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        
    .layer-item-button::before { content: none; }
        
        .layer-item-button:hover {
            background: var(--bg-secondary);
            color: var(--primary-color);
            transform: scale(1.06);
            box-shadow: var(--shadow-md);
        }
        
        .layer-item-button:hover::before {
            opacity: 0.1;
        }
        
        .layer-item-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .layer-item-button.layer-visibility-hidden {
            opacity: 0.3;
            color: var(--text-muted);
        }
        
        .layer-item-button.layer-visibility-hidden:hover {
            opacity: 0.6;
            color: var(--text-secondary);
        }
        
        .layer-item {
            background: var(--bg-primary);
            border: 1px solid var(--md-outline-variant);
            border-radius: 8px;
            transition: border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        
        #layer-list {
            overflow-x: hidden !important;
            width: 100%;
        }
        
    .layer-item::before { content: none; }
        
        .layer-item:hover {
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-color);
        }
        
        .layer-item.selected {
            background: var(--bg-secondary);
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }
        
        .upload-button {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            padding: 10px 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
            box-shadow: none;
            position: relative;
            overflow: hidden;
            font-size: 14px;
            text-transform: none;
            letter-spacing: 0.2px;
        }
        
    .upload-button::before { content: none; }
        
    .upload-button:hover { background: var(--bg-tertiary); }
        
        .upload-button:hover::before {
            left: 100%;
        }
        
        .delete-button {
            background: var(--bg-secondary);
            color: var(--md-error);
            border: 1px solid var(--md-error);
            border-radius: 8px;
            padding: 10px 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            min-height: 42px; /* approximate height of upload-button */
        }
    .delete-button::before { content: none; }
        .delete-button:hover {
            background: var(--md-error);
            color: var(--md-on-error);
        }
        .delete-button.inactive {
            opacity: 0.45;
            cursor: default;
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-color: var(--md-outline-variant);
        }
        .delete-button.inactive:hover {
            background: var(--bg-secondary);
            color: var(--text-muted);
        }
        
        .preset-color {
            border-radius: 12px;
            border: 2px solid var(--md-outline-variant);
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }
        
    .preset-color::before { content: none; }
        
        .preset-color:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-lg);
            transform: scale(1.03);
        }
        
    .preset-color:hover::before { content: none; }

        .preset-color-bg {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid var(--md-outline-variant);
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
            margin: 4px; /* spacing between circles */
        }

        /* Ensure parent rows allow wrapping with consistent gap */
        .preset-row, .neutral-row {
            display: flex;
            flex-wrap: wrap;
            gap: 4px; /* extra insurance with margin */
            justify-content: flex-start;
        }

        .preset-color-bg.selected {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-lg), 0 0 0 2px var(--primary-color);
            transform: scale(1.06);
        }

        .preset-color-bg:hover {
            transform: scale(1.08);
            box-shadow: var(--shadow-xl);
        }

        /* Grid Button Styles */
        .grid-button {
            position: relative;
            transition: all 0.2s ease;
        }
        
        .grid-button.selected {
            border-color: var(--primary-color) !important;
            background-color: rgb(30, 58, 138) !important;
            box-shadow: 0 0 0 2px var(--primary-color), 0 4px 12px rgba(59, 130, 246, 0.3);
            transform: scale(1.02);
        }

        .grid-button:hover:not(.selected) {
            border-color: rgba(148, 163, 184, 0.6);
            background-color: rgb(51, 65, 85);
            transform: translateY(-1px);
        }

        .grid-button:active {
            transform: scale(0.98);
        }
        
        .grid-preview div {
            background: #94a3b8 !important;
            border-radius: 1px;
        }
        
        .grid-button.selected .grid-preview div {
            background: #e2e8f0 !important;
        }
        
        /* Grid overlay visuals */
        @keyframes gridPulse {
            0% { transform: scale(0.9); opacity: .7; }
            70% { transform: scale(1.15); opacity: .2; }
            100% { transform: scale(1.25); opacity: 0; }
        }
        .grid-legend {
            position: absolute; right: 10px; top: 10px; color: #a3e635; font-size: 11px; background: rgba(2,6,23,.6);
            padding: 4px 8px; border: 1px solid rgba(163,230,53,.35); border-radius: 8px; backdrop-filter: blur(6px);
        }
        
        .form-input {
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            background: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: none;
            position: relative;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }
        
        .form-input::placeholder {
            color: var(--text-muted);
            font-weight: 400;
        }
        
        /* Enhanced select dropdown styling */
        select.form-input {
            background: var(--bg-primary) !important;
            color: var(--text-primary) !important;
            cursor: pointer !important;
            border: 1px solid var(--md-outline) !important;
            border-radius: 8px !important;
            padding: 12px 40px 12px 16px !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
            transition: border-color 0.15s ease !important;
            position: relative !important;
            
            /* Remove all native appearances */
            appearance: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            
            /* Custom arrow */
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
            background-position: right 12px center !important;
            background-repeat: no-repeat !important;
            background-size: 16px 12px !important;
        }
        
        /* Specific fix for animation select */
        #animation-select {
            background: var(--bg-primary) !important;
            color: var(--text-primary) !important;
            cursor: pointer !important;
            border: 1px solid var(--md-outline) !important;
            border-radius: 8px !important;
            padding: 12px 40px 12px 16px !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
            transition: border-color 0.15s ease !important;
            position: relative !important;
            
            /* Remove all native appearances */
            appearance: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            
            /* Single custom arrow only */
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
            background-position: right 12px center !important;
            background-repeat: no-repeat !important;
            background-size: 16px 12px !important;
        }
        
        /* Remove any pseudo-elements that might be adding arrows */
        #animation-select::before,
        #animation-select::after {
            display: none !important;
            content: none !important;
        }
        
        .dark select.form-input {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e") !important;
        }
        
        /* Completely remove all native dropdown arrows */
        select.form-input::-ms-expand {
            display: none !important;
        }
        
        select.form-input::-webkit-inner-spin-button,
        select.form-input::-webkit-outer-spin-button {
            display: none !important;
            -webkit-appearance: none !important;
        }
        
        /* Firefox specific fixes */
        @-moz-document url-prefix() {
            select.form-input {
                text-indent: 0.01px !important;
                text-overflow: '' !important;
            }
        }
        
        select.form-input option {
            background: var(--bg-primary) !important;
            color: var(--text-primary) !important;
            padding: 8px 12px !important;
            border: none !important;
        }
        
        .form-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .media-item {
            background: var(--bg-primary);
            border: 1px solid var(--md-outline-variant);
            border-radius: 12px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            aspect-ratio: 1;
            position: relative;
        }
        
    .media-item::before { content: none; }
        
        .media-item:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-xl);
            transform: scale(1.02);
        }

        .media-item .remove-media-btn {
            position:absolute;
            top:4px;
            right:4px;
            width:22px;
            height:22px;
            background:rgba(220,53,69,0.9);
            border:none;
            color:#fff;
            font-weight:700;
            font-size:12px;
            line-height:1;
            border-radius:50%;
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            opacity:0;
            transition:opacity .2s ease, transform .2s ease, background .2s ease;
            z-index:5;
        }
        .media-item:hover .remove-media-btn,
        .media-item:focus-within .remove-media-btn {
            opacity:1;
        }
        .media-item .remove-media-btn:hover {
            background:rgba(200,40,55,1);
            transform:scale(1.08);
        }
        
        .media-item img {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 2;
        }
        
        .media-item:hover img {
            transform: scale(1.1) rotate(1deg);
        }
        /* Always keep properties panel rendered; internal states manage visibility */
        #properties-panel-content {
            display: block;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-active {
            background: var(--success-color);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        
        .status-inactive {
            background: var(--text-muted);
        }
        
        .status-drawer-closed {
            background: var(--text-muted);
            box-shadow: 0 0 0 2px rgba(156, 163, 175, 0.2);
        }
        
        .professional-badge {
            display: inline-flex;
            align-items: center;
            background: var(--primary-color);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .drawer-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            /* Isolate layer to prevent text pop-in due to parent transitions */
            contain: paint;
            will-change: auto;
        }
        
        .drawer-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
            /* Avoid opacity/visibility animation on titles */
            transition: color 0.2s ease;
            backface-visibility: hidden;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
        }
        
        .drawer-subtitle {
            font-size: 11px;
            color: var(--text-secondary);
            margin: 2px 0 0 0;
        }
        
        .drawer-author {
            font-size: 10px;
            color: var(--text-muted);
            margin: 2px 0 0 0;
            font-weight: 500;
        }
        
        /* Scrollbar styling (theme-aware, Material flat) */
        .drawer,
        .drawer * {
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
            scrollbar-width: thin;
        }
        .drawer::-webkit-scrollbar,
        .drawer *::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .drawer::-webkit-scrollbar-track,
        .drawer *::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 10px;
        }
        .drawer::-webkit-scrollbar-thumb,
        .drawer *::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 10px;
            border: 1px solid var(--md-outline-variant);
        }
        .drawer::-webkit-scrollbar-thumb:hover,
        .drawer *::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }
        
        /* Animation for elements */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .animate-fade-in {
            animation: fadeInUp 0.3s ease-out;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .drawer {
                width: 280px;
            }
            
            .drawer-toggle {
                padding: 10px;
            }
        }
        
        /* Splash Screen - Enhanced Modern Design */
        #splash-screen-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(16, 185, 129, 0.1)), rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px) saturate(1.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #splash-screen-overlay.fade-out { opacity: 0; pointer-events: none; transform: scale(0.95); }
        #splash-screen {
            width: min(420px, 85vw);
            max-width: 420px;
            background: linear-gradient(145deg, var(--md-surface), var(--md-surface-variant));
            border: 1px solid var(--md-outline-variant);
            border-radius: 24px;
            padding: 36px 32px 32px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 0 8px 32px rgba(59, 130, 246, 0.15), var(--md-elev-3);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: splashIn 0.8s cubic-bezier(.4,0,.2,1);
        }
        #splash-screen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.03) 0%, transparent 70%);
            animation: glow 4s ease-in-out infinite alternate;
        }
        #splash-screen .logo {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            filter: drop-shadow(0 4px 12px rgba(59, 130, 246, 0.2));
            animation: logoFloat 3s ease-in-out infinite;
        }
        #splash-screen .title {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 6px;
            letter-spacing: -0.02em;
            line-height: 1.2;
            background: linear-gradient(135deg, var(--text-primary), var(--md-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        #splash-screen .subtitle {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-bottom: 3px;
            font-weight: 500;
            letter-spacing: 0.02em;
        }
        #splash-screen .author {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 24px;
            font-weight: 400;
            letter-spacing: 0.01em;
        }
        #splash-screen .start-btn {
            background: linear-gradient(135deg, var(--md-primary), var(--primary-hover));
            color: var(--md-on-primary);
            border: none;
            border-radius: 999px;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: .4px;
            padding: 12px 28px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3), 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: all .3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        #splash-screen .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        #splash-screen .start-btn:hover::before {
            left: 100%;
        }
        #splash-screen .start-btn:focus-visible { 
            outline: 3px solid var(--md-primary); 
            outline-offset: 4px; 
        }
        #splash-screen .start-btn:hover { 
            background: linear-gradient(135deg, var(--primary-hover), var(--md-primary));
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 32px rgba(59, 130, 246, 0.4), 0 6px 16px rgba(0, 0, 0, 0.2);
        }
        #splash-screen .start-btn:active { 
            transform: translateY(0) scale(0.98); 
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3), 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        #splash-screen .about-btn {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--md-outline);
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 500;
            letter-spacing: .2px;
            padding: 10px 20px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: all .25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        #splash-screen .about-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--md-outline-variant);
            transform: translateY(-1px);
        }
        #splash-screen .about-btn:active {
            transform: translateY(0);
        }
        @keyframes splashIn { 
            from { 
                transform: translateY(32px) scale(.92); 
                opacity: 0;
                filter: blur(4px);
            } 
            to { 
                transform: translateY(0) scale(1); 
                opacity: 1;
                filter: blur(0);
            } 
        }
        @keyframes glow {
            from { opacity: 0.3; }
            to { opacity: 0.7; }
        }
        @keyframes logoFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        /* Export Info Dialog */
        #export-info-dialog-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
        }
        #export-info-dialog-overlay.show {
            display: flex;
            opacity: 1;
        }
        #export-info-dialog {
            width: min(520px, 92vw);
            max-width: 520px;
            max-height: 85vh;
            background: var(--md-surface);
            border: 1px solid var(--md-outline-variant);
            border-radius: 20px;
            box-shadow: 0 24px 64px rgba(0, 0, 0, 0.4), var(--md-elev-3);
            overflow: hidden;
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #export-info-dialog-overlay.show #export-info-dialog {
            transform: scale(1) translateY(0);
        }
        #export-info-dialog-header {
            padding: 24px 28px 20px;
            border-bottom: 1px solid var(--md-outline-variant);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(145deg, var(--md-surface), var(--md-surface-variant));
        }
        #export-info-dialog-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        #export-info-dialog-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        #export-info-dialog-close:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        #export-info-dialog-content {
            padding: 28px;
            overflow-y: auto;
            max-height: calc(85vh - 100px);
        }
        .export-info-section {
            text-align: center;
        }
        .export-info-image {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 16px;
            margin: 0 auto 24px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--md-outline-variant);
        }
        .export-info-description {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-secondary);
            margin: 0;
            text-align: left;
            padding: 20px 24px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--md-outline-variant);
        }
        
    #splash-screen::before { content: none; }
        
    #splash-screen.fade-out { opacity: 0; }
        
        #splash-screen .logo {
            width: 80px;
            height: 80px;
            margin-bottom: 24px;
            filter: none;
            position: relative;
            z-index: 2;
            animation: gentlePulse 2s ease-in-out infinite;
        }
        
        #splash-screen .title {
            color: var(--text-primary);
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            text-align: center;
            position: relative;
            z-index: 2;
            letter-spacing: -0.5px;
        }
        
        #splash-screen .subtitle {
            color: var(--text-secondary);
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            margin-bottom: 16px;
            position: relative;
            z-index: 2;
        }
        
        #splash-screen .author {
            color: var(--text-muted);
            font-size: 13px;
            text-align: center;
            font-weight: 500;
            padding: 8px 20px;
            background: var(--bg-secondary);
            border-radius: 20px;
            border: 1px solid var(--md-outline-variant);
            position: relative;
            z-index: 2;
        }
        
        @keyframes gentlePulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.02); 
                opacity: 0.95; 
            }
        }
        
        @keyframes pulse {
            0%, 100% { 
                transform: scale(1) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.08) rotate(2deg); 
                opacity: 0.9; 
            }
        }
        
        @keyframes float {
            0%, 100% { 
                transform: translate(0, 0) rotate(0deg); 
            }
            33% { 
                transform: translate(30px, -30px) rotate(1deg); 
            }
            66% { 
                transform: translate(-20px, 20px) rotate(-1deg); 
            }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .app-logo {
            width: 48px;
            height: 48px;
            margin-right: 16px;
            flex-shrink: 0;
        }
        
        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-primary);
            border: 1px solid var(--md-outline-variant);
            border-radius: 12px;
            padding: 24px;
            box-shadow: var(--shadow-xl);
            z-index: 10000;
            min-width: 300px;
            text-align: center;
            color: var(--text-primary);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin: 12px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .progress-detail {
            color: var(--text-secondary);
            font-size: 12px;
        }
        
        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 24px 12px;
            color: var(--text-muted);
        }
        
        .empty-state svg {
            margin: 0 auto 12px;
            opacity: 0.6;
        }
        
        .empty-state .title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-secondary);
        }
        
        .empty-state .subtitle {
            font-size: 12px;
            line-height: 1.4;
        }
        
    /* Media Grid Improvements: unified styling now defined earlier; duplicate removed */
        
        
        
        /* Animation Trigger Panel */
        .animation-trigger-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--md-outline-variant);
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: .5px;
            color: var(--text-muted);
            cursor: pointer;
            transition: background .18s ease, transform .18s ease, opacity .25s ease;
            display: inline-flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 18px; /* slimmer */
            position: relative;
            box-shadow: none;
            opacity: 0.6; /* subtle */
        }
        
        .animation-trigger-btn:hover {
            background: var(--bg-tertiary);
            opacity: 0.55;
            transform: translateY(-1px);
        }
        
        .animation-trigger-btn:active {
            transform: translateY(0);
        }
        
        .animation-trigger-btn.triggering {
            background: rgba(56,189,248,0.3);
            color: var(--text-secondary);
            opacity: 0.7;
            transform: scale(1.05);
        }
        
        .animation-trigger-btn .key-indicator {
            background: rgba(148,163,184,0.25);
            color: var(--text-secondary);
            border-radius: 2px;
            padding: 0 2px;
            width: auto;
            height: 14px;
            font-size: 9px;
            font-weight: 600;
            line-height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(148,163,184,0.35);
            margin-right: 2px;
        }
        
        .animation-trigger-btn .animation-icon {
            font-size: 8px;
            line-height: 1;
            color: var(--text-muted);
            margin-left: 1px;
        }
        
        .animation-trigger-btn.triggering .animation-icon {
            color: var(--text-secondary);
        }
        
        .animation-trigger-btn .object-name { /* hide for low profile */
            display: none;
        }
        
        .animation-trigger-btn.gentle-shake .animation-icon {
            animation: gentle-shake 0.5s ease-in-out;
        }
        
        .animation-trigger-btn.pendum .animation-icon {
            animation: pendum 0.5s ease-in-out;
        }
        
        .animation-trigger-btn.circular .animation-icon {
            animation: circular 0.5s ease-in-out;
        }
        
        /* Animation Keyframes */
        @keyframes gentle-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        
        @keyframes pendum {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-6deg); }
            75% { transform: rotate(6deg); }
        }
        
        @keyframes circular {
            0% { transform: rotate(0deg) translateX(2px) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(2px) rotate(-360deg); }
        }
        
        /* Object Animations */
        .canvas-object-shake {
            animation: object-shake var(--animation-duration, 1s) ease-in-out;
        }
        
        .canvas-object-pendum {
            animation: object-pendum var(--animation-duration, 1s) ease-in-out;
        }
        
        .canvas-object-circular {
            animation: object-circular var(--animation-duration, 1s) ease-in-out;
        }
        
        @keyframes object-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(calc(-1px * var(--animation-intensity, 5))); }
            75% { transform: translateX(calc(1px * var(--animation-intensity, 5))); }
        }
        
        @keyframes object-pendum {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(calc(-1.5deg * var(--animation-intensity, 5))); }
            75% { transform: rotate(calc(1.5deg * var(--animation-intensity, 5))); }
        }
        
        @keyframes object-circular {
            0% { transform: rotate(0deg) translateX(calc(1px * var(--animation-intensity, 5))) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(calc(1px * var(--animation-intensity, 5))) rotate(-360deg); }
        }
    /* About links */
    .about-link { color: #93c5fd; text-decoration: underline; text-underline-offset: 2px; }
    /* Text style toggle buttons */
    .btn-toggle { display: inline-flex; align-items: center; justify-content: center; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(148,163,184,0.25); background: rgba(255,255,255,0.04); color: #e2e8f0; font-weight: 600; min-width: 36px; }
    .btn-toggle:hover { background: rgba(255,255,255,0.08); }
    .btn-toggle.active { background: rgba(59,130,246,0.15); border-color: rgba(59,130,246,0.45); color: #bfdbfe; }
    
    /* Animation type buttons */
    .animation-type-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 12px 10px;
        border: 1px solid rgba(148,163,184,0.25);
        border-radius: 10px;
        background: rgba(255,255,255,0.04);
        color: #e2e8f0;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    .animation-type-btn:hover {
        background: rgba(255,255,255,0.08);
        border-color: rgba(148,163,184,0.4);
    }
    .animation-type-btn.active {
        background: linear-gradient(135deg, rgba(79, 70, 229, 0.25), rgba(99, 102, 241, 0.15));
        border-color: rgba(99, 102, 241, 0.7);
        color: #e0e7ff;
        box-shadow: 0 4px 12px rgba(79, 70, 229, 0.25);
    }
    .animation-type-btn.active .anim-label {
        color: #f0f4ff;
        font-weight: 600;
    }
    .animation-type-btn.active .anim-preview {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(79, 70, 229, 0.15));
        border-color: rgba(129, 140, 248, 0.4);
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.1), 0 2px 8px rgba(79, 70, 229, 0.2);
    }
    
    /* Enhanced preview visuals */
    .anim-preview { position: relative; width: 56px; height: 36px; border-radius: 10px; background: linear-gradient(135deg, rgba(148,163,184,0.08), rgba(100,116,139,0.12)); overflow: hidden; border: 1px solid rgba(255,255,255,0.08); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: inset 0 1px 0 rgba(255,255,255,0.05); }
    .animation-type-btn:hover .anim-preview { background: linear-gradient(135deg, rgba(148,163,184,0.15), rgba(100,116,139,0.18)); transform: scale(1.05); }
    .anim-label { font-size: 12px; color: #94a3b8; transition: all 0.2s; font-weight: 500; }
    
    /* Static "No Motion" preview */
    .preview-none .no-motion-icon { 
        position: absolute; top: 50%; left: 50%; 
        width: 16px; height: 16px; 
        border: 2px solid rgba(203,213,225,0.6); 
        border-radius: 3px; 
        transform: translate(-50%, -50%); 
        background: rgba(203,213,225,0.1);
    }
    
    /* Wiggle: Simple left-right shake */
    .preview-wiggle .dot { 
        width: 10px; height: 10px; 
        background: linear-gradient(135deg, #f1f5f9, #cbd5e1); 
        border-radius: 50%; 
        position: absolute; top: 50%; left: 50%; 
        transform: translate(-50%, -50%); 
        box-shadow: 0 2px 4px rgba(0,0,0,0.1), 0 0 0 1px rgba(255,255,255,0.2);
        animation: preview-wiggle 0.6s ease-in-out infinite; 
    }
    @keyframes preview-wiggle {
        0%, 100% { transform: translate(-50%, -50%); }
        50% { transform: translate(calc(-50% - 8px), -50%); }
    }
    
    /* Pendum: Pivot swing from top */
    .preview-pendum .arm { 
        position: absolute; top: 6px; left: 50%; 
        width: 1px; height: 24px; 
        transform-origin: top center; 
        animation: preview-pendum 1.2s ease-in-out infinite; 
    }
    .preview-pendum .rod { 
        position: absolute; top: 0; left: -0.5px; 
        width: 1px; height: 18px; 
        background: linear-gradient(to bottom, rgba(229,231,235,0.8), rgba(203,213,225,0.6)); 
        border-radius: 0.5px; 
    }
    .preview-pendum .bob { 
        position: absolute; bottom: 0; left: -5px; 
        width: 10px; height: 10px; 
        background: radial-gradient(circle at 30% 30%, #f1f5f9, #cbd5e1); 
        border-radius: 50%; 
        box-shadow: 0 2px 4px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.3);
    }
    @keyframes preview-pendum {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(-15deg); }
        75% { transform: rotate(15deg); }
    }
    
    /* Circular: Simple circular orbit */
    .preview-circular .bob { 
        position: absolute; top: 50%; left: 50%; 
        width: 10px; height: 10px; 
        background: radial-gradient(circle at 30% 30%, #f1f5f9, #cbd5e1); 
        border-radius: 50%; 
        transform-origin: -12px 0px;
        animation: preview-circle 1.5s linear infinite; 
        box-shadow: 0 2px 4px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.3);
    }
    @keyframes preview-circle {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Remove duplicated legacy previews */
    .wiggle-preview, .sway-preview, .circle-preview { animation: none; }
    @keyframes wiggle-preview {}
    @keyframes sway-preview {}
    @keyframes circle-preview {}
    </style>
</head>
<body class="overflow-hidden">

    <!-- Splash Screen -->
    <div id="splash-screen-overlay">
        <div id="splash-screen">
            <img src="gazetracker.svg" alt="Gaze Tracker Logo" class="logo">
            <h1 class="title">Gaze Tracking Canvas</h1>
            <p class="subtitle">Visual Target Management System</p>
            <p class="author">by Niall Brown - Early Childhood Vision Consultant (ECVC)</p>
            <div class="flex gap-3 mt-4">
                <button id="splash-close-btn" class="start-btn" type="button" aria-label="Start using the application">
                    <span>Start</span>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"></path><path d="M12 5l7 7-7 7"></path></svg>
                </button>
                <button id="about-btn" class="about-btn" type="button" aria-label="About and licensing information">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></svg>
                    <span>About & Licensing</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Export Info Dialog -->
    <div id="export-info-dialog-overlay">
        <div id="export-info-dialog">
            <div id="export-info-dialog-header">
                <div id="export-info-dialog-title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="16" x2="12" y2="12"/>
                        <circle cx="12" cy="8" r="0.5" fill="currentColor"/>
                    </svg>
                    Export Information
                </div>
                <button id="export-info-dialog-close" onclick="hideExportInfoDialog()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div id="export-info-dialog-content">
                <div class="export-info-section">
                    <img src="complexitypicture.png" alt="Complexity Scene Example" class="export-info-image">
                    <p class="export-info-description">
                        This tool allows you to create and export complex visual scenes for 2D image assessment. Combine various visual targets, backgrounds, and foregrounds to create scenes for 2D image assessment.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="relative w-screen h-screen">
        <!-- Canvas Area -->
        <main id="canvas-container" class="w-full h-full">
            <canvas id="main-canvas"></canvas>
        </main>

        <!-- Left Controls Drawer -->
        <aside id="controls-drawer" class="drawer drawer-left w-80 overflow-y-auto">
            <div class="flex-1 overflow-y-auto p-3">
                <div class="drawer-header">
                    <div class="flex items-center">
                        <img src="gazetracker.svg" alt="Gaze Tracker Logo" class="app-logo">
                        <div class="flex-1">
                            <div class="flex items-center justify-between">
                                <h1 class="drawer-title">Gaze Tracking Canvas</h1>
                            </div>
                            <p class="drawer-subtitle">Visual Target Management</p>
                            <p class="drawer-author">by Niall Brown - ECVC</p>
                        </div>
                    </div>
                </div>
                
                <div id="left-panel-accordion" class="space-y-2">
                <!-- Tools Panel -->
                <div class="section-header">
                    <button class="accordion-button w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700" aria-expanded="true">
                        <span class="flex items-center">
                            <span id="tools-status" class="status-indicator status-active"></span>
                            Tools
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div class="accordion-content section-content p-3">
                    <!-- Fullscreen Toggle Button -->
                    <div class="mb-4">
                        <button id="fullscreen-toggle" class="tool-button w-full flex items-center justify-center space-x-2 p-3 rounded-md">
                            <svg id="fullscreen-enter-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                            </svg>
                            <svg id="fullscreen-exit-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                            <span id="fullscreen-text">Fullscreen</span>
                        </button>
                    </div>

                    <!-- (Moved Save Image button to persistent footer) -->
                    
                    <div class="grid grid-cols-2 gap-3 mb-4">
                        <button id="select-tool" class="tool-button active flex items-center justify-center space-x-2 p-3 rounded-md" title="Select Tool (V)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path></svg>
                            <span class="font-medium">Select</span>
                        </button>
                        <button id="text-tool" class="tool-button flex items-center justify-center space-x-2 p-3 rounded-md" title="Add Text">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 12a4 4 0 0 0 0-8H6v8"></path><path d="M15 20a4 4 0 0 0 0-8H6v8Z"></path></svg>
                            <span class="font-medium">Text</span>
                        </button>
                    </div>
                    <div id="shape-tools" class="grid grid-cols-3 gap-3 mt-2">
                        <button id="rect-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Rectangle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <defs>
                                    <linearGradient id="rect-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:currentColor;stop-opacity:0.8" />
                                        <stop offset="100%" style="stop-color:currentColor;stop-opacity:0.4" />
                                    </linearGradient>
                                </defs>
                                <rect x="4" y="6" width="16" height="12" rx="2" fill="url(#rect-gradient)" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                        </button>
                        <button id="square-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Square">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <defs>
                                    <linearGradient id="square-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:currentColor;stop-opacity:0.8" />
                                        <stop offset="100%" style="stop-color:currentColor;stop-opacity:0.4" />
                                    </linearGradient>
                                </defs>
                                <rect x="6" y="6" width="12" height="12" rx="2" fill="url(#square-gradient)" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                        </button>
                        <button id="circle-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Circle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <defs>
                                    <radialGradient id="circle-gradient" cx="30%" cy="30%">
                                        <stop offset="0%" style="stop-color:currentColor;stop-opacity:0.8" />
                                        <stop offset="100%" style="stop-color:currentColor;stop-opacity:0.3" />
                                    </radialGradient>
                                </defs>
                                <circle cx="12" cy="12" r="8" fill="url(#circle-gradient)" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                        </button>
                        <button id="triangle-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Triangle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <defs>
                                    <linearGradient id="triangle-gradient" x1="50%" y1="0%" x2="50%" y2="100%">
                                        <stop offset="0%" style="stop-color:currentColor;stop-opacity:0.8" />
                                        <stop offset="100%" style="stop-color:currentColor;stop-opacity:0.4" />
                                    </linearGradient>
                                </defs>
                                <path d="M12 4 L20 18 L4 18 Z" fill="url(#triangle-gradient)" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
                            </svg>
                        </button>
                        <button id="star-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Star">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <defs>
                                    <linearGradient id="star-gradient" x1="50%" y1="0%" x2="50%" y2="100%">
                                        <stop offset="0%" style="stop-color:currentColor;stop-opacity:0.8" />
                                        <stop offset="100%" style="stop-color:currentColor;stop-opacity:0.4" />
                                    </linearGradient>
                                </defs>
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" fill="url(#star-gradient)" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
                            </svg>
                        </button>
                        <button id="octagon-tool" class="tool-button flex items-center justify-center p-3 rounded-md" title="Octagon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                                <defs>
                                    <linearGradient id="octagon-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:currentColor;stop-opacity:0.8" />
                                        <stop offset="100%" style="stop-color:currentColor;stop-opacity:0.4" />
                                    </linearGradient>
                                </defs>
                                <path d="M7.86 2h8.28l5.86 5.86v8.28l-5.86 5.86H7.86L2 16.14V7.86L7.86 2z" fill="url(#octagon-gradient)" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <!-- Properties Inspector -->
                <div class="section-header">
                    <button id="properties-accordion-button" class="accordion-button w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700" aria-expanded="true">
                        <span class="flex items-center">
                            <span id="properties-status" class="status-indicator status-active"></span>
                            Properties
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div id="properties-panel-content" class="accordion-content section-content p-3">
                    <!-- Text Properties -->
                    <div id="text-properties" class="hidden space-y-4">
                        <div>
                            <label for="text-content-input" class="form-label block mb-2">Content</label>
                            <textarea id="text-content-input" rows="3" class="form-input w-full resize-none"></textarea>
                        </div>
                        <div>
                            <label for="text-color-input" class="form-label block mb-2">Color</label>
                            <input type="color" id="text-color-input" class="form-input w-full h-10 cursor-pointer">
                        </div>
                        <div>
                            <label for="text-font-select" class="form-label block mb-2">Font</label>
                            <select id="text-font-select" class="form-input w-full">
                                <option value="luciole">Luciole (Low Vision)</option>
                                <option value="atkinson">Atkinson Hyperlegible (Low Vision)</option>
                                <option value="andika">Andika (Printed 'a')</option>
                                <option value="serif">Noto Serif (Serif)</option>
                                <option value="inter">Inter</option>
                                <option value="system">System UI</option>
                            </select>
                            <div class="text-xs text-slate-400 mt-1">Printed 'a' example: <span style="font-family: Andika, Inter, system-ui, sans-serif; font-size: 1.1em;">a</span></div>
                            <!-- Large resize handles are now always enabled for better touch usability -->
                        </div>
                        <div>
                            <label class="form-label block mb-2">Style</label>
                            <div class="flex gap-2">
                                <button id="text-bold-toggle" type="button" class="btn-toggle" title="Bold" aria-pressed="false"><span style="font-weight:700">B</span></button>
                                <button id="text-italic-toggle" type="button" class="btn-toggle" title="Italic" aria-pressed="false"><span style="font-style:italic">I</span></button>
                            </div>
                        </div>
                        <div>
                            <label for="text-size-input" class="form-label block mb-2">Size</label>
                            <input type="range" id="text-size-input" min="10" max="200" class="w-full">
                        </div>
                    </div>
                    <!-- Shape Properties -->
                    <div id="shape-properties" class="hidden space-y-4">
                        <div>
                            <label for="shape-color-input" class="form-label block mb-2">Color</label>
                            <input type="color" id="shape-color-input" class="form-input w-full h-10 cursor-pointer">
                        </div>
                    </div>
                    
                    <!-- Transform Properties (for all objects) -->
                    <div id="transform-properties" class="hidden space-y-4">
                        <div>
                            <label class="form-label block mb-2">Transform</label>
                            <div class="flex space-x-2">
                                <button id="rotate-90-btn" class="upload-button w-full py-2 px-3 text-sm">
                                    Rotate 90°
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Image Properties -->
                    <div id="image-properties" class="hidden space-y-4">
                        <div>
                            <label class="form-label block mb-2">Image Transform</label>
                            <div class="flex space-x-2 mb-3">
                                <button id="flip-horizontal-btn" class="upload-button flex-1 py-2 px-3 text-sm">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path>
                                    </svg>
                                    Flip H
                                </button>
                                <button id="flip-vertical-btn" class="upload-button flex-1 py-2 px-3 text-sm">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"></path>
                                    </svg>
                                    Flip V
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Animation Properties -->
                    <div id="animation-properties" class="space-y-4 hidden">
                        <div class="group-block">
                            <label class="form-label block mb-3">Motion Type</label>
                            <div id="animation-buttons" class="grid grid-cols-2 gap-2">
                                <button type="button" class="animation-type-btn" data-animation="" aria-label="No motion">
                                    <div class="anim-preview preview-none">
                                        <div class="no-motion-icon"></div>
                                    </div>
                                    <span class="anim-label">No Motion</span>
                                </button>
                                <button type="button" class="animation-type-btn" data-animation="gentle-shake" aria-label="Wiggle motion">
                                    <div class="anim-preview preview-wiggle">
                                        <div class="dot"></div>
                                    </div>
                                    <span class="anim-label">Wiggle</span>
                                </button>
                                <button type="button" class="animation-type-btn" data-animation="pendum" aria-label="Sway motion">
                                    <div class="anim-preview preview-pendum">
                                        <div class="arm">
                                            <div class="rod"></div>
                                            <div class="bob"></div>
                                        </div>
                                    </div>
                                    <span class="anim-label">Sway</span>
                                </button>
                                <button type="button" class="animation-type-btn" data-animation="circular" aria-label="Circle motion">
                                    <div class="anim-preview preview-circular">
                                        <div class="bob"></div>
                                    </div>
                                    <span class="anim-label">Circle</span>
                                </button>
                            </div>
                        </div>
                        <div id="animation-settings" class="hidden space-y-3">
                            <div>
                                <label for="animation-cycles" class="form-label block mb-2 flex items-center justify-between">
                                    <span>Number of Cycles</span>
                                    <span id="cycles-value" class="text-[11px] text-slate-400">5 cycles</span>
                                </label>
                                <input type="range" id="animation-cycles" min="1" max="20" step="1" value="5" class="w-full" aria-label="Number of animation cycles">
                                <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                    <span>1 cycle</span>
                                    <span>20 cycles</span>
                                </div>
                            </div>
                            <div>
                                <label for="animation-intensity" class="form-label block mb-2 flex items-center justify-between">
                                    <span>Movement Size</span>
                                    <span id="intensity-value" class="text-[11px] text-slate-400">Medium</span>
                                </label>
                                <input type="range" id="animation-intensity" min="1" max="10" value="5" class="w-full" aria-label="Movement size">
                                <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                    <span>Small</span>
                                    <span>Large</span>
                                </div>
                            </div>
                            <div>
                                <label for="animation-duration" class="form-label block mb-2 flex items-center justify-between">
                                    <span>Cycle Speed</span>
                                    <span id="duration-value" class="text-[11px] text-slate-400">Medium</span>
                                </label>
                                <input type="range" id="animation-duration" min="0.5" max="3" step="0.1" value="1" class="w-full" aria-label="Animation cycle speed">
                                <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                    <span>Fast</span>
                                    <span>Slow</span>
                                </div>
                            </div>
                            <button id="animation-control-btn" class="upload-button w-full py-2 px-3 text-sm" title="Start or stop the animation">
                                <svg id="play-icon" class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.01M15 10h1.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                                <svg id="stop-icon" class="w-4 h-4 inline-block mr-2 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z M9 10h6v4H9z"/></svg>
                                <span id="control-text">Start Motion</span>
                            </button>
                        </div>
                    </div>
                    <div id="no-selection-properties" class="text-center py-8 animate-fade-in">
                        <div class="text-slate-400 mb-2">
                            <svg class="w-12 h-12 mx-auto mb-3 opacity-40" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </div>
                        <p id="no-selection-message" class="text-sm text-slate-300 font-medium">Add a visual target or shape to begin editing its properties.</p>
                        <p class="text-xs text-slate-500 mt-1">Once selected, its color, animation, and transforms appear here.</p>
                    </div>
                </div>
                <!-- Background Color -->
                <div class="section-header">
                    <button class="accordion-button w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700" aria-expanded="true">
                        <span class="flex items-center">
                            <span id="background-status" class="status-indicator status-active"></span>
                            Background Color
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div class="accordion-content section-content p-3">
                    <div class="space-y-3">
                        <div>
                            <label class="form-label block mb-2">Background Colour</label>
                            <input type="color" id="bg-color-slider" value="#000000" class="form-input w-full h-10 cursor-pointer">
                        </div>
                        <div>
                            <label class="form-label block mb-2">Quick Background Colours</label>
                            <!-- Row 1: High Contrast & Greys -->
                            <div class="flex justify-between px-2 mb-8 gap-2">
                                <button class="preset-color-bg" style="background-color: #000000;" data-color="#000000" title="Black"></button>
                                <button class="preset-color-bg" style="background-color: #2a2a2a;" data-color="#2a2a2a" title="Dark Grey"></button>
                                <button class="preset-color-bg" style="background-color: #808080;" data-color="#808080" title="Medium Grey"></button>
                                <button class="preset-color-bg" style="background-color: #c0c0c0;" data-color="#c0c0c0" title="Light Grey"></button>
                            </div>
                            
                            <!-- Row 2: Light Colors & Neutrals -->
                            <div class="flex justify-between px-2 mt-2 gap-2">
                                <button class="preset-color-bg" style="background-color: #ffffff; border-color: #333;" data-color="#ffffff" title="White"></button>
                                <button class="preset-color-bg" style="background-color: #f5f5dc;" data-color="#f5f5dc" title="Beige"></button>
                                <button class="preset-color-bg" style="background-color: #ddd8c7;" data-color="#ddd8c7" title="Cream"></button>
                                <button class="preset-color-bg" style="background-color: #d2b48c;" data-color="#d2b48c" title="Tan"></button>
                            </div>
                        </div>
                    </div>
                </div>
                 <!-- Layer Management -->
                <div class="section-header">
                    <button class="accordion-button w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700" aria-expanded="true">
                        <span class="flex items-center">
                            <span id="layers-status" class="status-indicator status-active"></span>
                            Layers
                        </span>
                        <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                <div class="accordion-content section-content p-2">
                    <div id="layer-list" class="space-y-1 max-h-64 overflow-y-auto mb-2"></div>
                    <div id="layers-empty-state" class="empty-state">
                        <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                        </svg>
                        <div class="title">No Objects Yet</div>
                        <div class="subtitle">Add text, shapes, or images to see them appear here as layers</div>
                    </div>
                    <div class="pt-2 mt-2 border-t border-slate-600/40">
                        <div class="flex gap-2">
                            <button id="save-image-btn" class="tool-button flex-1 flex items-center justify-center space-x-2 p-2 rounded-md text-sm" title="Export Scene to Image (PNG)">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 10v6m0 0l-3-3m3 3 3-3m2 8H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5.586a1 1 0 0 1 .707.293l5.414 5.414a1 1 0 0 1 .293.707V19a2 2 0 0 1-2 2z" />
                                </svg>
                                <span class="font-medium">Export Scene to Image</span>
                            </button>
                            <button id="export-info-btn" class="tool-button p-2 rounded-md text-sm" title="Information about exporting scenes">
                                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <line x1="12" y1="16" x2="12" y2="12"/>
                                    <circle cx="12" cy="8" r="0.5" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                </div>
                <!-- Removed misplaced settings panel (now inside media library) -->
            </div>
        </aside>

        <!-- Right Media Drawer -->
        <div id="media-library" class="drawer drawer-right w-80">
            <div class="p-3 flex-shrink-0">
                <div class="drawer-header">
                    <h2 class="drawer-title">Media Library</h2>
                    <p class="drawer-subtitle">Import and manage media assets</p>
                </div>
            </div>
            
            <div class="flex-1 overflow-y-auto px-3 pb-3">
                <div id="media-library-accordion" class="space-y-2">
                    <!-- Settings panel relocated to bottom for better grouping -->
                    <!-- Visual Targets Section -->
                    <div class="section-header">
                        <button class="accordion-button w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700" aria-expanded="true">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                Visual Targets
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div class="accordion-content section-content p-3">
                        <div class="space-y-3">
                            <label for="image-upload" class="upload-button w-full text-center py-2 px-3 rounded-md cursor-pointer block" title="Add a visual target (image, video, gif)">
                                <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                Add Visual Target
                            </label>
                            <input type="file" id="image-upload" multiple accept="image/*,video/*,.gif,.mp4,.mov,.avi,.mkv,.webm,.3gp,.wmv,.flv,.m4v" class="hidden">
                            <label for="folder-upload" class="upload-button w-full text-center py-2 px-3 rounded-md cursor-pointer block">
                                <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                                </svg>
                                Add Folder
                            </label>
                            <input type="file" id="folder-upload" webkitdirectory directory multiple class="hidden">
                        </div>
                        <div class="mt-4">
                            <div id="visual-targets-grid" class="grid grid-cols-3 gap-2"></div>
                            <div id="visual-targets-empty-state" class="empty-state">
                                <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                <div class="title">No Visual Targets</div>
                                <div class="subtitle">Add images, videos, or GIFs to place as visual targets on the canvas</div>
                            </div>
                        </div>
                    </div>

                    <!-- Backgrounds Section -->
                    <div class="section-header">
                        <button class="accordion-button w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700" aria-expanded="true">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                Backgrounds
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div class="accordion-content section-content p-3">
                        <div class="space-y-3">
                            <div class="flex flex-wrap items-center gap-2">
                                <label for="bg-image-input" class="upload-button flex-grow text-center py-2 px-3 rounded-md cursor-pointer order-1">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                    </svg>
                                    Upload Background
                                </label>
                                <input type="file" id="bg-image-input" class="hidden" accept="image/*">
                                <label for="bg-folder-upload" class="upload-button text-center py-2 px-3 rounded-md cursor-pointer order-2" title="Add Backgrounds Folder">
                                    <svg class="w-4 h-4 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                    </svg>
                                    Folder
                                </label>
                                <input type="file" id="bg-folder-upload" webkitdirectory directory multiple class="hidden" accept="image/*,video/*">
                                <button id="delete-bg-btn" class="delete-button hidden p-2 rounded-md order-3" title="Clear Current Background">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="mt-4">
                            <div id="backgrounds-grid" class="grid grid-cols-2 gap-2"></div>
                            <div id="backgrounds-empty-state" class="empty-state">
                                <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                <div class="title">No Backgrounds</div>
                                <div class="subtitle">Upload images to use as backgrounds. These images will always stay as the bottom layer.</div>
                            </div>
                        </div>
                    </div>

                    <!-- Foregrounds Section -->
                    <div class="section-header">
                        <button class="accordion-button w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700" aria-expanded="true">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                                </svg>
                                Foregrounds
                            </span>
                            <svg class="arrow-icon w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div class="accordion-content section-content p-3">
                        <div class="space-y-3">
                            <div class="flex flex-wrap items-center gap-2">
                                <label for="fg-image-input" class="upload-button flex-grow text-center py-2 px-3 rounded-md cursor-pointer order-1">
                                    <svg class="w-4 h-4 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                    </svg>
                                    Upload Foreground
                                </label>
                                <input type="file" id="fg-image-input" class="hidden" accept="image/*">
                                <label for="fg-folder-upload" class="upload-button text-center py-2 px-3 rounded-md cursor-pointer order-2" title="Add Foregrounds Folder">
                                    <svg class="w-4 h-4 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                    </svg>
                                    Folder
                                </label>
                                <input type="file" id="fg-folder-upload" webkitdirectory directory multiple class="hidden" accept="image/*,video/*">
                                <button id="delete-fg-btn" class="delete-button hidden p-2 rounded-md order-3" title="Clear Current Foreground">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="mt-4">
                            <div id="foregrounds-grid" class="grid grid-cols-2 gap-2"></div>
                            <div id="foregrounds-empty-state" class="empty-state">
                                <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path>
                                </svg>
                                <div class="title">No Foregrounds</div>
                                <div class="subtitle">Upload images to use as foregrounds. These images will always be the top layer and need to have transparent areas to show images behind them.</div>
                            </div>
                        </div>
                    </div>

                    <!-- Import From Saved Folders Button -->
                    

                    <!-- Auto-Load Settings Section -->
                    <div class="section-header mt-4">
                        <button id="media-settings-toggle" class="w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700 transition-colors" aria-expanded="false">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2-2z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5a2 2 0 012-2h4a2 2 0 012 2v2H8V5z" />
                                </svg>
                                Auto-Load Folders
                            </span>
                            <svg class="arrow-icon w-4 h-4 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div id="media-settings-panel" class="accordion-content section-content p-3" style="max-height:0; overflow:hidden;">
                        <div class="text-[10px] text-slate-500 leading-snug mb-3">
                            Save up to 3 directories to automatically load content in future sessions. When loading, you'll need to authorize each folder by clicking "Accept" to grant access permissions.
                        </div>

                        <div class="space-y-3">
                            <!-- Visual Targets Card -->
                            <div id="vt-card" class="auto-load-card border border-slate-600/50 rounded-lg p-3 bg-gradient-to-r from-slate-800/40 to-slate-700/20">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <div id="vt-status-indicator" class="w-3 h-3 rounded-full bg-slate-500"></div>
                                        <h4 class="font-medium text-slate-200 text-sm">Visual Targets</h4>
                                        <div id="vt-file-count" class="text-xs bg-slate-700 px-2 py-0.5 rounded-full text-slate-300 hidden">0 files</div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="auto-load-visual-targets" class="sr-only peer">
                                        <div class="w-9 h-5 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                                    </label>
                                </div>
                                <div id="vt-folder-info" class="text-xs text-slate-400 mb-2">No folder selected</div>
                                <div class="flex gap-2">
                                    <button id="pick-vt-folder" class="flex-1 upload-button py-1.5 px-3 rounded text-xs">Select Folder</button>
                                    <button id="clear-vt-folder" class="delete-button inactive py-1.5 px-2 rounded text-xs" title="Clear folder">×</button>
                                </div>
                            </div>

                            <!-- Backgrounds Card -->
                            <div id="bg-card" class="auto-load-card border border-slate-600/50 rounded-lg p-3 bg-gradient-to-r from-slate-800/40 to-slate-700/20">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <div id="bg-status-indicator" class="w-3 h-3 rounded-full bg-slate-500"></div>
                                        <h4 class="font-medium text-slate-200 text-sm">Backgrounds</h4>
                                        <div id="bg-file-count" class="text-xs bg-slate-700 px-2 py-0.5 rounded-full text-slate-300 hidden">0 files</div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="auto-load-backgrounds" class="sr-only peer">
                                        <div class="w-9 h-5 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                                    </label>
                                </div>
                                <div id="bg-folder-info" class="text-xs text-slate-400 mb-2">No folder selected</div>
                                <div class="flex gap-2">
                                    <button id="pick-bg-folder" class="flex-1 upload-button py-1.5 px-3 rounded text-xs">Select Folder</button>
                                    <button id="clear-bg-folder" class="delete-button inactive py-1.5 px-2 rounded text-xs" title="Clear folder">×</button>
                                </div>
                            </div>

                            <!-- Foregrounds Card -->
                            <div id="fg-card" class="auto-load-card border border-slate-600/50 rounded-lg p-3 bg-gradient-to-r from-slate-800/40 to-slate-700/20">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center gap-2">
                                        <div id="fg-status-indicator" class="w-3 h-3 rounded-full bg-slate-500"></div>
                                        <h4 class="font-medium text-slate-200 text-sm">Foregrounds</h4>
                                        <div id="fg-file-count" class="text-xs bg-slate-700 px-2 py-0.5 rounded-full text-slate-300 hidden">0 files</div>
                                    </div>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="auto-load-foregrounds" class="sr-only peer">
                                        <div class="w-9 h-5 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                                    </label>
                                </div>
                                <div id="fg-folder-info" class="text-xs text-slate-400 mb-2">No folder selected</div>
                                <div class="flex gap-2">
                                    <button id="pick-fg-folder" class="flex-1 upload-button py-1.5 px-3 rounded text-xs">Select Folder</button>
                                    <button id="clear-fg-folder" class="delete-button inactive py-1.5 px-2 rounded text-xs" title="Clear folder">×</button>
                                </div>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex gap-2 mt-4">
                            <button id="run-auto-load-now" class="w-full upload-button py-2 px-3 rounded-md text-sm">Load All Files</button>
                        </div>
                        
                        <!-- File Management Section -->
                        <div class="mt-4 p-3 border border-slate-600/50 rounded-lg bg-slate-800/20">
                            <h4 class="text-sm font-medium text-slate-200 mb-2">Auto-Loaded File Management</h4>
                            <div class="flex gap-2 text-xs">
                                <button id="view-auto-loaded-files" class="upload-button px-3 py-1.5 rounded text-xs">View Auto-Loaded Files</button>
                                <button id="clear-all-auto-loaded" class="delete-button px-3 py-1.5 rounded text-xs">Clear All Auto-Loaded</button>
                            </div>
                            <div id="auto-loaded-info" class="mt-2 text-xs text-slate-400 hidden"></div>
                        </div>
                        
                        <!-- Cache Management Section -->
                        <div class="mt-4 p-3 border border-slate-600/50 rounded-lg bg-slate-800/20">
                            <h4 class="text-sm font-medium text-slate-200 mb-2">App Cache Management</h4>
                            <div class="text-xs text-slate-400 mb-3">
                                If you're seeing an old version after updates, clear the app cache to force a fresh reload.
                            </div>
                            <div class="flex gap-2 text-xs">
                                <button id="clear-app-cache" class="upload-button px-3 py-1.5 rounded text-xs">Clear Cache & Reload</button>
                                <button id="check-app-version" class="tool-button px-3 py-1.5 rounded text-xs border border-slate-600 text-slate-300">Check Version</button>
                            </div>
                            <div id="version-info" class="mt-2 text-xs text-slate-400 hidden p-2 bg-slate-700/30 rounded border border-slate-600/30 max-h-32 overflow-y-auto"></div>
                        </div>
                    </div>

                    <!-- Position Grids Section -->
                    <div class="section-header mt-4">
                        <button id="grids-toggle" class="w-full flex justify-between items-center p-2 font-semibold text-slate-200 rounded-md hover:bg-slate-700 transition-colors" aria-expanded="false">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                                </svg>
                                Position Grids
                            </span>
                            <svg class="arrow-icon w-4 h-4 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                    <div id="grids-panel" class="accordion-content section-content p-3" style="max-height:0; overflow:hidden;">
                        <div class="text-xs text-slate-300 mb-3 p-2 bg-slate-800/30 rounded border border-slate-700/40">
                            <div class="font-semibold text-emerald-400 mb-1">📍 Position Guides</div>
                            <div class="text-[10px] text-slate-400 leading-relaxed">
                                Choose how many positions you want for your targets. They'll snap smoothly into place as you drag them.
                            </div>
                            <div class="text-[10px] text-blue-400 mt-1 flex items-center gap-1">
                                <span class="bg-slate-700 px-1.5 py-0.5 rounded text-[9px] font-mono">G</span>
                                <span>Toggle grid visibility</span>
                            </div>
                        </div>
                        
                        <div class="group-block">
                            <div class="group-label">Choose Positions</div>
                            <div class="grid grid-cols-5 gap-2">
                                <!-- 2 Frame Grid -->
                                <button id="grid-2" class="grid-button flex flex-col items-center justify-center p-2 rounded border-2 border-slate-600 bg-slate-800 hover:bg-slate-700 hover:border-slate-500 transition-colors" data-frames="2">
                                    <div class="grid-preview mb-1" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1px; width: 20px; height: 10px;">
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                    </div>
                                    <span class="text-[10px] text-slate-300">2</span>
                                </button>
                                
                                <!-- 4 Frame Grid -->
                                <button id="grid-4" class="grid-button flex flex-col items-center justify-center p-2 rounded border-2 border-slate-600 bg-slate-800 hover:bg-slate-700 hover:border-slate-500 transition-colors" data-frames="4">
                                    <div class="grid-preview mb-1" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1px; width: 20px; height: 20px;">
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                    </div>
                                    <span class="text-[10px] text-slate-300">4</span>
                                </button>
                                
                                <!-- 6 Frame Grid -->
                                <button id="grid-6" class="grid-button flex flex-col items-center justify-center p-2 rounded border-2 border-slate-600 bg-slate-800 hover:bg-slate-700 hover:border-slate-500 transition-colors" data-frames="6">
                                    <div class="grid-preview mb-1" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1px; width: 24px; height: 16px;">
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                    </div>
                                    <span class="text-[10px] text-slate-300">6</span>
                                </button>
                                
                                <!-- 9 Frame Grid -->
                                <button id="grid-9" class="grid-button flex flex-col items-center justify-center p-2 rounded border-2 border-slate-600 bg-slate-800 hover:bg-slate-700 hover:border-slate-500 transition-colors" data-frames="9">
                                    <div class="grid-preview mb-1" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1px; width: 24px; height: 24px;">
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                    </div>
                                    <span class="text-[10px] text-slate-300">9</span>
                                </button>
                                
                                <!-- 12 Frame Grid -->
                                <button id="grid-12" class="grid-button flex flex-col items-center justify-center p-2 rounded border-2 border-slate-600 bg-slate-800 hover:bg-slate-700 hover:border-slate-500 transition-colors" data-frames="12">
                                    <div class="grid-preview mb-1" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1px; width: 28px; height: 21px;">
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                        <div class="bg-slate-400 rounded-sm"></div>
                                    </div>
                                    <span class="text-[10px] text-slate-300">12</span>
                                </button>
                            </div>
                        </div>

                        <div class="group-block">
                            <div class="group-label">Display Options</div>
                            <div class="space-y-3">
                                <!-- Simple toggle controls -->
                                <label class="flex items-center gap-3 cursor-pointer">
                                    <input type="checkbox" id="show-position-guides" class="cursor-pointer" checked>
                                    <span class="text-sm text-slate-200">Show position guides</span>
                                </label>
                                <label class="flex items-center gap-3 cursor-pointer">
                                    <input type="checkbox" id="enable-auto-snap" class="cursor-pointer" checked>
                                    <span class="text-sm text-slate-200">Snap targets to positions</span>
                                </label>
                                
                                <!-- Quick Actions -->
                                <div class="space-y-2 pt-2 border-t border-slate-700">
                                    <div class="text-xs text-slate-400 font-medium mb-2">Quick Actions</div>
                                    <button id="arrange-all-targets" class="upload-button w-full py-2 px-3 rounded-md text-sm font-medium">
                                        Arrange All Targets
                                    </button>
                                    <button id="turn-off-grid" class="delete-button w-full py-2 px-3 rounded-md text-sm" style="display: none;">
                                        Turn Off Grid
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    
        <!-- Drawer Toggles -->
        <button id="toggle-controls-btn" class="drawer-toggle drawer-toggle-left" title="Toggle Controls (Ctrl+L)">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
            </svg>
        </button>
        <button id="toggle-library-btn" class="drawer-toggle drawer-toggle-right" title="Toggle Media Library (Ctrl+M)">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"></path>
            </svg>
        </button>

        <!-- Progress Bar -->
        <div id="progress-container" class="progress-container" style="display: none;">
            <div class="progress-text">Loading Media...</div>
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
            <div id="progress-detail" class="progress-detail">0 of 0 files processed</div>
        </div>

        <!-- Context Menu -->
        <div id="context-menu" class="context-menu">
            <button id="ctx-animate" class="flex items-center space-x-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.01M15 10h1.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <span>Animate...</span>
            </button>
            <hr class="my-1">
            <button id="ctx-bring-to-front" class="flex items-center space-x-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11l5-5m0 0l5 5m-5-5v12"></path>
                </svg>
                <span>Bring to Front</span>
            </button>
            <button id="ctx-send-to-back" class="flex items-center space-x-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 13l-5 5m0 0l-5-5m5 5V6"></path>
                </svg>
                <span>Send to Back</span>
            </button>
            <hr class="my-1">
            <button id="ctx-delete" class="danger flex items-center space-x-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                </svg>
                <span>Delete</span>
            </button>
        </div>

        <!-- Animation Trigger Panel -->
        <div id="animation-panel" class="fixed bottom-4 left-4 z-40 transition-all duration-300 translate-y-full">
            <div id="animation-triggers" class="flex items-center space-x-1"></div>
        </div>

        <!-- Toast Notification Container -->
        <div id="auto-load-toast" class="hidden fixed top-4 right-4 z-50 bg-slate-800 border border-slate-600 rounded-lg p-4 shadow-lg min-w-[300px] max-w-[400px]">
            <div class="flex items-start gap-3">
                <div id="toast-icon" class="w-5 h-5 mt-0.5 flex-shrink-0"></div>
                <div class="flex-1">
                    <div id="toast-title" class="font-medium text-slate-200 text-sm"></div>
                    <div id="toast-message" class="text-slate-400 text-xs mt-1"></div>
                    <div id="toast-progress-container" class="hidden mt-2">
                        <div class="bg-slate-700 rounded-full h-2">
                            <div id="toast-progress-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                        <div id="toast-progress-text" class="text-xs text-slate-400 mt-1"></div>
                    </div>
                </div>
                <button id="toast-close" class="text-slate-400 hover:text-slate-200 text-lg leading-none">&times;</button>
            </div>
        </div>

    <!-- About section (moved into left drawer bottom) -->

    <script>
    document.addEventListener('DOMContentLoaded', () => {
            // --- Version Management & Cache Busting ---
            const APP_VERSION = '2024.09.14.001'; // Update this when deploying new versions
            const VERSION_KEY = 'eyeTrackingAppVersion';
            const SETTINGS_BACKUP_KEY = 'eyeTrackingAppSettingsBackup';
            
            function checkVersionAndManageCache() {
                const storedVersion = localStorage.getItem(VERSION_KEY);
                const currentVersion = APP_VERSION;
                
                if (storedVersion !== currentVersion) {
                    console.log(`Version update detected: ${storedVersion || 'none'} -> ${currentVersion}`);
                    
                    // Backup current settings before any potential cache clearing
                    backupUserSettings();
                    
                    // Show update notification to user
                    showUpdateNotification(storedVersion, currentVersion);
                    
                    // Update stored version
                    localStorage.setItem(VERSION_KEY, currentVersion);
                    
                    // Optional: Clear specific caches while preserving user data
                    clearApplicationCache();
                }
            }
            
            function backupUserSettings() {
                try {
                    const settingsToBackup = {
                        autoLoadFolders: localStorage.getItem('autoLoadFolders.v1'),
                        timestamp: Date.now()
                    };
                    localStorage.setItem(SETTINGS_BACKUP_KEY, JSON.stringify(settingsToBackup));
                } catch (e) {
                    console.warn('Could not backup settings:', e);
                }
            }
            
            function showUpdateNotification(oldVersion, newVersion) {
                // Create a subtle notification that doesn't interrupt workflow
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                    z-index: 10000;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: 14px;
                    max-width: 300px;
                    animation: slideInRight 0.3s ease-out;
                `;
                
                notification.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 4px;">✨ App Updated!</div>
                    <div style="opacity: 0.9; font-size: 12px;">
                        Version ${newVersion} loaded successfully.<br>
                        Your settings and folders are preserved.
                    </div>
                `;
                
                // Add slide-in animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideInRight {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(notification);
                
                // Auto-remove after 4 seconds
                setTimeout(() => {
                    notification.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => notification.remove(), 300);
                }, 4000);
            }
            
            function clearApplicationCache() {
                // Clear browser cache programmatically where possible
                if ('caches' in window) {
                    caches.keys().then(names => {
                        names.forEach(name => {
                            caches.delete(name);
                        });
                    });
                }
                
                // Add cache-busting to future requests
                addCacheBustingToResources();
            }
            
            function addCacheBustingToResources() {
                // Add cache-busting parameters to dynamically loaded resources
                const timestamp = Date.now();
                
                // Bust cache for any dynamically loaded images/videos
                const originalCreateObjectURL = URL.createObjectURL;
                URL.createObjectURL = function(blob) {
                    const url = originalCreateObjectURL.call(this, blob);
                    return url + '?cb=' + timestamp;
                };
            }
            
            // Force reload if severe cache issues detected
            function forceReloadIfNeeded() {
                const lastReloadTime = localStorage.getItem('lastForceReload');
                const now = Date.now();
                const oneHour = 60 * 60 * 1000;
                
                // Only allow force reload once per hour to prevent reload loops
                if (!lastReloadTime || (now - parseInt(lastReloadTime)) > oneHour) {
                    const urlParams = new URLSearchParams(window.location.search);
                    if (!urlParams.has('nocache')) {
                        localStorage.setItem('lastForceReload', now.toString());
                        window.location.href = window.location.href + '?nocache=' + now;
                        return true;
                    }
                }
                return false;
            }
            
            // Add meta tag to prevent caching of the main HTML file
            function addCacheControlMeta() {
                const metaNoCache = document.createElement('meta');
                metaNoCache.httpEquiv = 'Cache-Control';
                metaNoCache.content = 'no-cache, no-store, must-revalidate';
                document.head.appendChild(metaNoCache);
                
                const metaPragma = document.createElement('meta');
                metaPragma.httpEquiv = 'Pragma';
                metaPragma.content = 'no-cache';
                document.head.appendChild(metaPragma);
                
                const metaExpires = document.createElement('meta');
                metaExpires.httpEquiv = 'Expires';
                metaExpires.content = '0';
                document.head.appendChild(metaExpires);
            }
            
            // Initialize version management
            addCacheControlMeta();
            
            // Check for updates but don't force reload on first load
            const urlParams = new URLSearchParams(window.location.search);
            if (!urlParams.has('nocache')) {
                checkVersionAndManageCache();
            }
            
            // Add keyboard shortcut for manual refresh (Ctrl+Shift+R)
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                    e.preventDefault();
                    if (!forceReloadIfNeeded()) {
                        // If reload was prevented, clear caches and refresh normally
                        if ('caches' in window) {
                            caches.keys().then(names => {
                                Promise.all(names.map(name => caches.delete(name)))
                                    .then(() => window.location.reload(true));
                            });
                        } else {
                            window.location.reload(true);
                        }
                    }
                }
            });
            
            // --- Service Worker for Cache Management ---
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    // Update existing service worker if present
                    registrations.forEach(registration => {
                        registration.update();
                    });
                });
                
                // Register service worker if sw.js exists
                navigator.serviceWorker.register('./sw.js', { updateViaCache: 'none' })
                    .then(registration => {
                        // Check for updates every 30 seconds
                        setInterval(() => {
                            registration.update();
                        }, 30000);
                        
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    showUpdateAvailablePrompt();
                                }
                            });
                        });
                    })
                    .catch(err => {
                        // Service worker not available or failed - not critical
                        console.log('Service worker not available:', err.message);
                    });
            }
            
            function showUpdateAvailablePrompt() {
                const prompt = document.createElement('div');
                prompt.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #2563eb;
                    color: white;
                    padding: 16px 20px;
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
                    z-index: 10001;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: 14px;
                    max-width: 320px;
                    animation: slideInUp 0.3s ease-out;
                `;
                
                prompt.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;">🚀 New Version Available!</div>
                    <div style="opacity: 0.9; font-size: 13px; margin-bottom: 12px;">
                        A newer version is ready. Your settings will be preserved.
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="this.parentElement.parentElement.remove()" style="
                            background: rgba(255,255,255,0.2);
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 6px;
                            font-size: 12px;
                            cursor: pointer;
                        ">Later</button>
                        <button onclick="window.location.reload()" style="
                            background: white;
                            color: #2563eb;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 6px;
                            font-size: 12px;
                            font-weight: bold;
                            cursor: pointer;
                        ">Update Now</button>
                    </div>
                `;
                
                // Add slide-in animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideInUp {
                        from { transform: translateY(100%); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(prompt);
            }
            
            // --- Splash Screen ---
            const splashScreen = document.getElementById('splash-screen');
            const splashOverlay = document.getElementById('splash-screen-overlay');
            
            const splashCloseBtn = document.getElementById('splash-close-btn');
            function hideSplash() {
                if (!splashOverlay) return;
                splashScreen.classList.add('fade-out');
                splashOverlay.classList.add('fade-out');
                setTimeout(() => {
                    splashOverlay.remove();
                }, 600);
            }
            splashCloseBtn.addEventListener('click', hideSplash);
            // Allow Enter / Space to trigger while focused
            splashCloseBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); hideSplash(); }
            });
            // Give initial focus for accessibility
            setTimeout(() => { splashCloseBtn.focus(); }, 50);

            // About button - simple alert instead of complex dialog
            const aboutBtn = document.getElementById('about-btn');
            aboutBtn.addEventListener('click', () => {
                alert(`Gaze Tracking Canvas - Visual Target Management System

Developed by Niall Brown, Early Childhood Vision Consultant (ECVC)

This application streamlines the process of managing visual targets, backgrounds, and foregrounds for vision assessment and eye gaze tracking applications.

MIT License - Copyright © 2024 Niall Brown (ECVC)
This software is provided "as is" without warranty of any kind.`);
            });

            // Export Info Dialog functionality
            const exportInfoBtn = document.getElementById('export-info-btn');
            const exportInfoDialogOverlay = document.getElementById('export-info-dialog-overlay');
            const exportInfoDialogClose = document.getElementById('export-info-dialog-close');

            function showExportInfoDialog() {
                exportInfoDialogOverlay.classList.add('show');
                setTimeout(() => exportInfoDialogClose.focus(), 100);
            }

            function hideExportInfoDialog() {
                exportInfoDialogOverlay.classList.remove('show');
                setTimeout(() => exportInfoBtn.focus(), 300);
            }

            exportInfoBtn.addEventListener('click', showExportInfoDialog);
            exportInfoDialogClose.addEventListener('click', hideExportInfoDialog);

            // Close dialog with Escape key
            exportInfoDialogOverlay.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    hideExportInfoDialog();
                }
            });

            // Close dialog when clicking outside
            exportInfoDialogOverlay.addEventListener('click', (e) => {
                if (e.target === exportInfoDialogOverlay) {
                    hideExportInfoDialog();
                }
            });

            // Allow Enter/Space on close button
            exportInfoDialogClose.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    hideExportInfoDialog();
                }
            });
            
            // --- DOM Elements ---
            const canvas = document.getElementById('main-canvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvas-container');
            
            const controlsDrawer = document.getElementById('controls-drawer');
            const mediaLibrary = document.getElementById('media-library');
            const toggleControlsBtn = document.getElementById('toggle-controls-btn');
            const toggleLibraryBtn = document.getElementById('toggle-library-btn');
            const fullscreenToggle = document.getElementById('fullscreen-toggle');
            const fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
            const fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');
            const fullscreenText = document.getElementById('fullscreen-text');
            
            const imageUpload = document.getElementById('image-upload');
            const folderUpload = document.getElementById('folder-upload');
            const backgroundsGrid = document.getElementById('backgrounds-grid');
            const foregroundsGrid = document.getElementById('foregrounds-grid');
            const visualTargetsGrid = document.getElementById('visual-targets-grid');
            const backgroundsEmptyState = document.getElementById('backgrounds-empty-state');
            const foregroundsEmptyState = document.getElementById('foregrounds-empty-state');
            const visualTargetsEmptyState = document.getElementById('visual-targets-empty-state');
            
            const selectTool = document.getElementById('select-tool');
            const textTool = document.getElementById('text-tool');
            const rectTool = document.getElementById('rect-tool');
            const squareTool = document.getElementById('square-tool');
            const circleTool = document.getElementById('circle-tool');
            const triangleTool = document.getElementById('triangle-tool');
            const starTool = document.getElementById('star-tool');
            const octagonTool = document.getElementById('octagon-tool');

            const bgColorSlider = document.getElementById('bg-color-slider');
            const presetColorBtns = document.querySelectorAll('.preset-color-bg');
            const bgImageInput = document.getElementById('bg-image-input');
            const deleteBgBtn = document.getElementById('delete-bg-btn');
            const fgImageInput = document.getElementById('fg-image-input');
            const deleteFgBtn = document.getElementById('delete-fg-btn');

            const layerList = document.getElementById('layer-list');
            const layersEmptyState = document.getElementById('layers-empty-state');
            const contextMenu = document.getElementById('context-menu');
            const accordionButtons = document.querySelectorAll('.accordion-button');
            
            // Progress Bar Elements
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressDetail = document.getElementById('progress-detail');

            // Properties Panel Elements
            const propertiesPanel = document.getElementById('properties-panel-content');
            const textProperties = document.getElementById('text-properties');
            const shapeProperties = document.getElementById('shape-properties');
            const transformProperties = document.getElementById('transform-properties');
            const imageProperties = document.getElementById('image-properties');
            const animationProperties = document.getElementById('animation-properties');
            const noSelectionProperties = document.getElementById('no-selection-properties');
            const textContentInput = document.getElementById('text-content-input');
            const textColorInput = document.getElementById('text-color-input');
            const textSizeInput = document.getElementById('text-size-input');
            const textFontSelect = document.getElementById('text-font-select');
            // Large handles: always enabled (removed toggle)
            // --- Touch / Pointer Capability Flags ---
            const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
            // Base handle size (will be user-adjustable)
            let handleSize = 24; // Moderate circular handles for better aesthetics & touch
            let largeHandlesForced = true; // kept for minimal code changes
            let activePointers = new Map();
            let pinchStartInfo = null; // { distance, objOrig }
            let longPressTimer = null;
            const LONG_PRESS_MS = 550;
            let longPressStart = null; // {x,y}
            let lastTapTime = 0; let lastTapPos = null; const DOUBLE_TAP_MS = 350; const DOUBLE_TAP_DIST = 30;
            const textBoldToggle = document.getElementById('text-bold-toggle');
            const textItalicToggle = document.getElementById('text-italic-toggle');
            const shapeColorInput = document.getElementById('shape-color-input');
            const flipHorizontalBtn = document.getElementById('flip-horizontal-btn');
            const flipVerticalBtn = document.getElementById('flip-vertical-btn');
            const rotate90Btn = document.getElementById('rotate-90-btn');
            
            // Animation Elements
            const animationSelect = document.getElementById('animation-select');
            const animationSettings = document.getElementById('animation-settings');
            const animationDuration = document.getElementById('animation-duration');
            const animationCycles = document.getElementById('animation-cycles');
            const animationIntensity = document.getElementById('animation-intensity');
            const durationValue = document.getElementById('duration-value');
            const cyclesValue = document.getElementById('cycles-value');
            const intensityValue = document.getElementById('intensity-value');
            const animationControlBtn = document.getElementById('animation-control-btn');
            const playIcon = document.getElementById('play-icon');
            const stopIcon = document.getElementById('stop-icon');
            const controlText = document.getElementById('control-text');
            const animationPanel = document.getElementById('animation-panel');
            const animationTriggers = document.getElementById('animation-triggers');
            const animationEasing = document.getElementById('animation-easing');
            const animationIteration = document.getElementById('animation-iteration');
            const livePreviewToggle = document.getElementById('live-preview-toggle');

            // --- State ---
            let objects = [];
            let selectedObject = null;
            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let dragStartX, dragStartY;
            let currentTool = 'select';
            let backgroundColor = '#000000'; // Default to black
            let backgroundImage = null;
            let foregroundImage = null;
            let animationLoopRunning = false;
            let lastTime = 0;
            let pingPongDirection = 1; // used for ping-pong loop style
            
            // Grid State
            let currentGrid = null; // null, 2, 4, 6, 9, or 12
            let gridFrames = [];
            let showGuides = true; // Show position guides
            let enableAutoSnap = true; // Enable automatic snapping
            let snapStrength = 80; // Increased for easier snapping
            let isSnapping = false;
            let snapAnimation = null;
            let tempGridVisibility = false; // Track if grid was temporarily shown during drag
            
            // Shape Creation State
            // Color harmony palettes - each palette contains harmonious colors
            const colorHarmonyPalettes = {
                // Warm Sunset palette
                warm: [
                    '#FF6B35', '#F7931E', '#FFD23F', '#FF4500', '#FF8C42',
                    '#FF6347', '#FFA500', '#FFB347', '#FF7F50', '#FF8C69'
                ],
                // Cool Ocean palette  
                cool: [
                    '#0077BE', '#00A8CC', '#7DD3C0', '#4ECDC4', '#45B7D1',
                    '#96CEB4', '#85C1E9', '#5DADE2', '#3498DB', '#2E86AB'
                ],
                // Earth/Nature palette
                earth: [
                    '#8FBC8F', '#228B22', '#32CD32', '#9ACD32', '#6B8E23',
                    '#708238', '#87A96B', '#A4BE7B', '#C5D6A6', '#8FC93A'
                ],
                // Purple/Magenta palette
                cosmic: [
                    '#8E44AD', '#9B59B6', '#AF7AC5', '#C39BD3', '#D7BDE2',
                    '#BA55D3', '#DA70D6', '#DDA0DD', '#E6E6FA', '#9370DB'
                ],
                // Vibrant Mixed (complementary colors)
                vibrant: [
                    '#E74C3C', '#3498DB', '#F39C12', '#2ECC71', '#9B59B6',
                    '#E67E22', '#1ABC9C', '#34495E', '#F1C40F', '#16A085'
                ]
            };
            
            // Current palette and color management
            let currentPalette = 'vibrant'; // Start with vibrant
            let currentColorIndex = 0;
            let paletteRotationCount = 0;
            
            // Function to get next harmonious color
            function getNextHarmoniousColor() {
                const palette = colorHarmonyPalettes[currentPalette];
                const color = palette[currentColorIndex];
                
                currentColorIndex++;
                
                // When we reach the end of a palette, switch to the next one
                if (currentColorIndex >= palette.length) {
                    currentColorIndex = 0;
                    paletteRotationCount++;
                    
                    // Cycle through palettes
                    const paletteNames = Object.keys(colorHarmonyPalettes);
                    const currentPaletteIndex = paletteNames.indexOf(currentPalette);
                    const nextPaletteIndex = (currentPaletteIndex + 1) % paletteNames.length;
                    currentPalette = paletteNames[nextPaletteIndex];
                }
                
                return color;
            }
            
            let shapeOffsetX = 0;
            let shapeOffsetY = 0;
            
            // Media Library State (encapsulated via MediaLibrary object)
            const MediaLibrary = (() => {
                const assets = {
                    backgrounds: [],
                    foregrounds: [],
                    visualTargets: []
                };
                return {
                    assets,
                    add(category, el, metadata = {}){ 
                        // Add auto-load metadata to the element
                        if (metadata.autoLoaded) {
                            el.dataset.autoLoaded = 'true';
                            el.dataset.autoLoadSource = metadata.sourceFolderName || 'Auto-loaded';
                            el.dataset.autoLoadCategory = metadata.category || category;
                            el.dataset.loadedAt = new Date().toISOString();
                        }
                        assets[category].push(el); 
                    },
                    remove(category, el){ const i = assets[category].indexOf(el); if(i>-1) assets[category].splice(i,1); },
                    move(from,to,el){ this.remove(from,el); this.add(to,el); },
                    list(category){ return assets[category]; },
                    isEmpty(category){ return assets[category].length===0; },
                    getAutoLoadedFiles(category){ 
                        return assets[category].filter(el => el.dataset.autoLoaded === 'true'); 
                    },
                    clearAutoLoadedFiles(category){ 
                        const autoLoadedFiles = this.getAutoLoadedFiles(category);
                        autoLoadedFiles.forEach(el => this.remove(category, el));
                        return autoLoadedFiles.length;
                    },
                    getAllAutoLoadedFiles(){
                        const allAutoLoaded = [];
                        Object.keys(assets).forEach(category => {
                            const autoFiles = this.getAutoLoadedFiles(category);
                            autoFiles.forEach(file => {
                                allAutoLoaded.push({
                                    file,
                                    category,
                                    sourceFolderName: file.dataset.autoLoadSource,
                                    loadedAt: file.dataset.loadedAt
                                });
                            });
                        });
                        return allAutoLoaded;
                    }
                };
            })();
            // Backwards compatibility alias
            const mediaAssets = MediaLibrary.assets;
            
            // Animation State
            let animatedObjects = [];
            let animationPanelVisible = false;

            // Animation Panel Management
            function updateAnimationTriggerPanel() {
                // Show any object that has an animation type configured (running or not)
                const animatedObjs = objects.filter(obj => !!obj.animationType);
                animationTriggers.innerHTML = '';
                
                if (animatedObjs.length === 0) {
                    hideAnimationPanel();
                    return;
                }
                
                animatedObjs.forEach((obj, index) => {
                    const triggerBtn = document.createElement('button');
                    triggerBtn.className = `animation-trigger-btn ${obj.animationType}`;
                    triggerBtn.dataset.objectId = obj.id;
                    triggerBtn.dataset.keyIndex = index + 1;
                    triggerBtn.title = `${obj.name} - Press ${index + 1}`;
                    
                    triggerBtn.innerHTML = `
                        <div class="key-indicator">${index + 1}</div>
                        <div class="animation-icon">⚬</div>
                        <div class="object-name">${obj.name}</div>
                    `;
                    
                    triggerBtn.addEventListener('click', () => {
                        triggerAnimation(obj);
                        if(obj === selectedObject) updateAnimationControlButton();
                    });
                    
                    animationTriggers.appendChild(triggerBtn);
                });
                
                showAnimationPanel();
            }
            
            function showAnimationPanel() {
                if (!animationPanelVisible) {
                    animationPanel.classList.remove('translate-y-full');
                    animationPanelVisible = true;
                }
            }
            
            function hideAnimationPanel() {
                if (animationPanelVisible) {
                    animationPanel.classList.add('translate-y-full');
                    animationPanelVisible = false;
                }
            }
            
            function triggerAnimation(obj) {
                if (!obj || !obj.animationType) {
                    console.warn('Animation trigger failed: Invalid object or no animation type');
                    return false;
                }
                
                // Restart animation from beginning
                obj.isAnimating = true;
                obj.animationStartTime = performance.now();
                obj.cycleCount = 0;

                if (obj.animationType) {
                    // Visual feedback on trigger button
                    const triggerBtn = document.querySelector(`[data-object-id="${obj.id}"]`);
                    if (triggerBtn) {
                        triggerBtn.classList.add('triggering');
                        setTimeout(() => {
                            triggerBtn.classList.remove('triggering');
                        }, 500);
                    }
                    if(selectedObject === obj) {
                        updateAnimationControlButton();
                    }
                    
                    // Start animation loop if not already running
                    if (!animationLoopRunning) {
                        startAnimationLoop();
                    }
                    ensureRenderLoop();
                    return true;
                }
                return false;
            }
            
            function startAnimationLoop() {
                if (animationLoopRunning) return; // Prevent multiple loops
                animationLoopRunning = true;
                lastTime = 0;
                
                function animate(currentTime) {
                    if (lastTime === 0) lastTime = currentTime;
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;
                    
                    // Check if any objects are still animating
                    const stillAnimating = objects.some(obj => obj.isAnimating);
                    
                    if (stillAnimating) {
                        draw();
                        requestAnimationFrame(animate);
                    } else {
                        animationLoopRunning = false;
                        lastTime = 0;
                        // All animations finished — reset preview button UI
                        try {
                            if (typeof updateAnimationControlButton === 'function') {
                                updateAnimationControlButton();
                            }
                        } catch {}
                    }
                }
                
                requestAnimationFrame(animate);
            }

            // --- Canvas Setup ---
            function getCanvasDimensions() {
                const rect = canvasContainer.getBoundingClientRect();
                return { width: rect.width, height: rect.height };
            }
            
            function resizeCanvas() {
                const rect = canvasContainer.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Set the canvas internal size accounting for device pixel ratio
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                
                // Set the canvas CSS size to the display size
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                
                // Scale the context to match device pixel ratio
                ctx.scale(dpr, dpr);
                
                // Recalculate grid frames if a grid is active
                if (currentGrid) {
                    gridFrames = calculateGridFrames(currentGrid);
                    if (typeof recomputeGridOccupancy === 'function') recomputeGridOccupancy();
                }
                
                draw();
            }
            // Initialize large handles preference
            (function initHandlePreference(){
                applyHandleSize();
            })();
            function applyHandleSize(){ handleSize = 24; }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Initialize status indicators
            updateStatusIndicators();
            
            // Initialize empty states
            updateLayerList();
            updateEmptyStates();

            // --- Drawing Engine ---
            function draw() {
                const dpr = window.devicePixelRatio || 1;
                const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                
                // Reset transform to clear any previous scaling
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Apply device pixel ratio scaling
                ctx.scale(dpr, dpr);
                
                // Configure image smoothing for crisp rendering
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.fillStyle = backgroundColor;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                if (backgroundImage) {
                    drawCoverImage(backgroundImage.img, canvasWidth, canvasHeight);
                }

                objects.sort((a, b) => a.zIndex - b.zIndex).forEach(obj => {
                    if (obj.visible) {
                       obj.draw(ctx);
                    }
                });
                
                if (foregroundImage) {
                    drawCoverImage(foregroundImage.img, canvasWidth, canvasHeight);
                }

                // Draw grid overlay
                drawGridOverlay();

                if (selectedObject && currentTool === 'select') {
                    drawSelectionHandles(selectedObject);
                }
            }

            // Continuous render loop to keep video frames updating
            let continuousLoop = false;
            function ensureRenderLoop() {
                if (continuousLoop) return;
                continuousLoop = true;
                function loop() {
                    const hasVideo = objects.some(o => o.type === 'video');
                    const dragging = isDragging || isResizing;
                    const animating = objects.some(o => o.isAnimating);
                    const snapping = isSnapping;
                    if (hasVideo || dragging || animating || snapping) {
                        draw();
                        requestAnimationFrame(loop);
                    } else {
                        continuousLoop = false; // allow restart when needed
                    }
                }
                requestAnimationFrame(loop);
            }
            
            function drawCoverImage(img, canvasWidth, canvasHeight) {
                const canvasRatio = canvasWidth / canvasHeight;
                const imgRatio = img.width / img.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imgRatio > canvasRatio) {
                    // Image is wider than canvas
                    drawHeight = canvasHeight;
                    drawWidth = drawHeight * imgRatio;
                    drawX = (canvasWidth - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas
                    drawWidth = canvasWidth;
                    drawHeight = drawWidth / imgRatio;
                    drawX = 0;
                    drawY = (canvasHeight - drawHeight) / 2;
                }
                
                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            }
            
            function drawSelectionHandles(obj) {
                const center = { x: obj.x + obj.width / 2, y: obj.y + obj.height / 2 };
                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.rotate(obj.rotation);
                ctx.translate(-center.x, -center.y);
                
                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                ctx.setLineDash([]);
                
                getResizeHandles(obj).forEach(handle => {
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#4f46e5';
                    ctx.lineWidth = 2;
                    const radius = (handle.size / 2);
                    const cx = handle.x + handle.size / 2;
                    const cy = handle.y + handle.size / 2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                });
                ctx.restore();
            }

            // --- Object Classes ---
            class CanvasObject { 
                constructor(x, y, width, height, zIndex, type) { 
                    this.id = Date.now() + Math.random(); 
                    this.x = x; 
                    this.y = y; 
                    this.initialX = x; 
                    this.initialY = y; 
                    this.width = width; 
                    this.height = height; 
                    this.zIndex = zIndex; 
                    this.type = type; 
                    this.visible = true; 
                    this.rotation = 0; 
                    this.scale = 1; 
                    this.flipHorizontal = false;
                    this.flipVertical = false;
                    // Animation properties
                    this.animationType = null;
                    this.animationDuration = 1.0;
                    this.animationCycles = 1; // Default to a single cycle
                    this.animationIntensity = 5;
                    this.cycleCount = 0;
                    this.animationEasing = 'ease-in-out';
                    this.animationIteration = 'infinite'; // 'infinite' | '1' | 'yoyo'
                    this.isAnimating = false;
                    this.animationStartTime = 0;
                    this.animationCycleTime = 0; // accumulative for smooth looping
                } 
                
                isPointInside(px, py) { 
                    const center = { x: this.x + this.width / 2, y: this.y + this.height / 2 }; 
                    const translatedX = px - center.x; 
                    const translatedY = py - center.y; 
                    const rotatedX = translatedX * Math.cos(-this.rotation) - translatedY * Math.sin(-this.rotation); 
                    const rotatedY = translatedX * Math.sin(-this.rotation) + translatedY * Math.cos(-this.rotation); 
                    return Math.abs(rotatedX) <= this.width / 2 && Math.abs(rotatedY) <= this.height / 2; 
                } 
                
                draw(ctx) { 
                    const center = { x: this.x + this.width / 2, y: this.y + this.height / 2 }; 
                    ctx.save(); 
                    ctx.translate(center.x, center.y); 
                    ctx.rotate(this.rotation); 
                    ctx.scale(
                        this.scale * (this.flipHorizontal ? -1 : 1), 
                        this.scale * (this.flipVertical ? -1 : 1)
                    ); 
                    
                    // Apply animation transform only while actively animating
                    if (this.animationType && this.isAnimating) {
                        // Cycle-based animation
                        const now = performance.now();
                        if(!this.animationStartTime) this.animationStartTime = now;
                        const elapsed = (now - this.animationStartTime) / 1000; // seconds
                        const cycle = this.animationDuration || 1;
                        const maxCycles = this.animationCycles || 5;
                        
                        // Calculate current cycle and progress within cycle
                        const totalCyclesFloat = elapsed / cycle;
                        const currentCycle = Math.floor(totalCyclesFloat);
                        let rawProgress = totalCyclesFloat - currentCycle; // 0..1 within current cycle
                        
                        // Check if we've completed all cycles
                        if (currentCycle >= maxCycles) {
                            // Smooth conclusion - gradually reduce intensity in final portion
                            const fadeTime = 1.0; // 1 second fade out for smooth ending
                            const finalCycleProgress = (totalCyclesFloat - maxCycles) / fadeTime;
                            
                            if (finalCycleProgress >= 1) {
                                // Animation completely finished - keep type so user can restart
                                this.isAnimating = false;
                                this.animationStartTime = 0;
                                this.cycleCount = 0;
                                // If this was the selected object, revert the play/stop UI
                                try {
                                    if (typeof updateAnimationControlButton === 'function' && typeof selectedObject !== 'undefined' && selectedObject === this) {
                                        updateAnimationControlButton();
                                    }
                                } catch {}
                            } else {
                                // Continue motion while smoothly fading intensity to zero
                                const fadeMultiplier = Math.cos((finalCycleProgress * Math.PI) / 2); // Smooth fade using cosine
                                this.tempFadeMultiplier = fadeMultiplier;
                                this.applyAnimationTransform(ctx, rawProgress);
                                this.tempFadeMultiplier = 1; // Reset
                            }
                        } else {
                            // Normal animation with smooth start
                            this.cycleCount = currentCycle;
                            
                            // Apply smooth start-up for first cycle
                            let startupMultiplier = 1;
                            if (currentCycle === 0 && rawProgress < 0.3) {
                                // Smooth ease-in during first 30% of first cycle
                                const startupProgress = rawProgress / 0.3;
                                startupMultiplier = Math.sin((startupProgress * Math.PI) / 2); // Smooth start using sine
                            }
                            
                            this.tempStartupMultiplier = startupMultiplier;
                            this.applyAnimationTransform(ctx, rawProgress);
                            this.tempStartupMultiplier = 1; // Reset
                        }
                    }
                    
                    ctx.translate(-center.x, -center.y); 
                    this.drawContent(ctx); 
                    ctx.restore(); 
                } 
                
                applyAnimationTransform(ctx, progress) {
                    const baseIntensity = this.animationIntensity;
                    const fadeMultiplier = this.tempFadeMultiplier || 1;
                    const startupMultiplier = this.tempStartupMultiplier || 1;
                    const intensity = baseIntensity * fadeMultiplier * startupMultiplier;
                    
                    // Clamp progress to prevent overshooting
                    const clampedProgress = Math.max(0, Math.min(1, progress));
                    
                    switch (this.animationType) {
                        case 'gentle-shake': {
                            // Smooth sinusoidal shake - starts and ends at center
                            const angle = clampedProgress * Math.PI * 2;
                            const shakeX = Math.sin(angle) * intensity;
                            ctx.translate(shakeX, 0);
                            break; 
                        }
                        case 'pendum': {
                            // Smooth pendulum swing - starts and ends at center (equilibrium)
                            const amplitudeRad = (intensity * 3) * Math.PI / 180;
                            const angle = clampedProgress * Math.PI * 2;
                            // Use sine for pendulum to start/end at center position
                            const pendulumAngle = Math.sin(angle) * amplitudeRad;
                            const pivotTopY = -this.height / 2;
                            ctx.translate(0, pivotTopY);
                            ctx.rotate(pendulumAngle);
                            ctx.translate(0, -pivotTopY);
                            break; 
                        }
                        case 'circular': {
                            // Smooth circular orbit - continuous motion
                            const radius = intensity * 2;
                            const angle = clampedProgress * Math.PI * 2;
                            const circularX = Math.cos(angle) * radius;
                            const circularY = Math.sin(angle) * radius;
                            ctx.translate(circularX, circularY);
                            break; 
                        }
                    }
                }
                
                startAnimation() {
                    if(!this.animationType) return false;
                    this.isAnimating = true;
                    this.animationStartTime = performance.now();
                    this.cycleCount = 0;
                    return true;
                }
                
                drawContent(ctx) { } 
                updateMetrics() { } 
            }
            class ImageObject extends CanvasObject { 
                constructor(img, x, y, width, height, zIndex, type = 'image') { 
                    super(x, y, width, height, zIndex, type); 
                    this.img = img; 
                    this.name = type === 'foreground' ? `[FG] ${img.dataset.name}` : (img.dataset.name || 'Image'); 
                } 
                
                drawContent(ctx) { 
                    // Note: Flipping is handled by the base class draw() method
                    // so we don't need to apply it here again
                    ctx.drawImage(this.img, this.x, this.y, this.width, this.height); 
                } 
            }
            
            class VideoObject extends CanvasObject { 
                constructor(video, x, y, width, height, zIndex, type = 'video') { 
                    super(x, y, width, height, zIndex, type); 
                    this.video = video; 
                    this.name = video.dataset.name || 'Video'; 
                } 
                
                drawContent(ctx) { 
                    // Draw video frame to canvas
                    ctx.drawImage(this.video, this.x, this.y, this.width, this.height); 
                } 
            }
    class TextObject extends CanvasObject { 
                constructor(text, x, y, zIndex) { 
                    super(x, y, 0, 0, zIndex, 'text'); 
                    this.text = text; 
                    this.color = '#FFFFFF'; 
                    this.size = 40; 
            this.fontFamily = 'Luciole, "Atkinson Hyperlegible", Inter, system-ui, sans-serif';
        this.fontWeight = 400;
        this.fontStyle = 'normal';
            this.name = `Text: "${text.substring(0, 15)}..."`; 
                    this.initialX = x;
                    this.initialY = y;
                    this.hasBeenPositioned = false; // Track if text has been initially positioned
                    this.updateMetrics(); 
                } 
                drawContent(ctx) { 
                    ctx.fillStyle = this.color; 
            ctx.font = `${this.fontStyle} ${this.fontWeight} ${this.size}px ${this.fontFamily}`; 
                    ctx.textBaseline = 'top'; 
                    ctx.fillText(this.text, this.x, this.y); 
                } 
                updateMetrics() { 
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = `${this.fontStyle} ${this.fontWeight} ${this.size}px ${this.fontFamily}`; 
                    const metrics = tempCtx.measureText(this.text); 
                    
                    // Store old dimensions
                    const oldWidth = this.width || 0;
                    const oldHeight = this.height || 0;
                    
                    // Update dimensions
                    this.width = metrics.width; 
                    this.height = this.size; 
                    
                    // Only update position if it's initial creation (not during resize or edit)
                    if (!this.isResizing && !this.hasBeenPositioned) {
                        this.x = this.initialX - this.width / 2; 
                        this.y = this.initialY - this.height / 2;
                        this.hasBeenPositioned = true;
                    }
                    
                    this.name = `Text: "${this.text.substring(0, 15)}..."`; 
                } 
            }
            class ShapeObject extends CanvasObject { 
                constructor(shapeType, x, y, zIndex, color = '#FF5733') { 
                    // Set initial dimensions; make rectangles slightly wider than tall for recognizability
                    let initWidth = 100;
                    let initHeight = 100;
                    if (shapeType === 'rect') {
                        initWidth = 120; // slightly longer on X axis
                        initHeight = 100;
                    }
                    super(x - initWidth/2, y - initHeight/2, initWidth, initHeight, zIndex, 'shape'); 
                    this.shapeType = shapeType; 
                    this.color = color; 
                    this.name = `Shape: ${shapeType}`; 
                } 
                drawContent(ctx) { 
                    // Save the current context state
                    ctx.save();
                    
                    // Add subtle shadow for depth
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 2;
                    
                    switch(this.shapeType) { 
                        case 'rect': 
                            // Create gradient for rectangle
                            const rectGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            rectGradient.addColorStop(0, this.color);
                            rectGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            
                            ctx.fillStyle = rectGradient;
                            
                            // Draw rounded rectangle
                            const rectRadius = Math.min(8, Math.min(this.width, this.height) / 4);
                            ctx.beginPath();
                            ctx.roundRect(this.x, this.y, this.width, this.height, rectRadius);
                            ctx.fill();
                            
                            // Add subtle border
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            break; 
                        case 'square':
                            // Render a square (same as rect, but the size is enforced elsewhere)
                            const sqGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            sqGradient.addColorStop(0, this.color);
                            sqGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            ctx.fillStyle = sqGradient;
                            const sqRadius = Math.min(8, Math.min(this.width, this.height) / 4);
                            ctx.beginPath();
                            ctx.roundRect(this.x, this.y, this.width, this.height, sqRadius);
                            ctx.fill();
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            break;
                            
                        case 'circle': 
                            // Create radial gradient for circle
                            const centerX = this.x + this.width / 2;
                            const centerY = this.y + this.height / 2;
                            const radius = this.width / 2;
                            
                            const circleGradient = ctx.createRadialGradient(
                                centerX - radius * 0.3, centerY - radius * 0.3, 0,
                                centerX, centerY, radius
                            );
                            circleGradient.addColorStop(0, this.adjustColorBrightness(this.color, 30));
                            circleGradient.addColorStop(0.7, this.color);
                            circleGradient.addColorStop(1, this.adjustColorBrightness(this.color, -25));
                            
                            ctx.fillStyle = circleGradient;
                            ctx.beginPath(); 
                            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2); 
                            ctx.fill();
                            
                            // Add subtle border
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            break; 
                            
                        case 'triangle': 
                            // Create linear gradient for triangle
                            const triangleGradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                            triangleGradient.addColorStop(0, this.adjustColorBrightness(this.color, 20));
                            triangleGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            
                            ctx.fillStyle = triangleGradient;
                            ctx.beginPath(); 
                            ctx.moveTo(this.x + this.width / 2, this.y); 
                            ctx.lineTo(this.x + this.width, this.y + this.height); 
                            ctx.lineTo(this.x, this.y + this.height); 
                            ctx.closePath(); 
                            ctx.fill();
                            
                            // Add subtle border
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.lineJoin = 'round';
                            ctx.stroke();
                            break;
                        case 'star':
                            const starGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            starGradient.addColorStop(0, this.adjustColorBrightness(this.color, 20));
                            starGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            ctx.fillStyle = starGradient;
                            ctx.beginPath();
                            this.drawStar(ctx, this.x + this.width / 2, this.y + this.height / 2, 5, this.width / 2, this.width / 4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.lineJoin = 'round';
                            ctx.stroke();
                            break;
                        case 'octagon':
                            const octagonGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                            octagonGradient.addColorStop(0, this.adjustColorBrightness(this.color, 20));
                            octagonGradient.addColorStop(1, this.adjustColorBrightness(this.color, -20));
                            ctx.fillStyle = octagonGradient;
                            ctx.beginPath();
                            this.drawPolygon(ctx, this.x + this.width / 2, this.y + this.height / 2, 8, this.width / 2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.shadowColor = 'transparent';
                            ctx.strokeStyle = this.adjustColorBrightness(this.color, -30);
                            ctx.lineWidth = 1;
                            ctx.lineJoin = 'round';
                            ctx.stroke();
                            break;
                    }
                    
                    // Restore the context state
                    ctx.restore();
                }

                drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                    let rot = Math.PI / 2 * 3;
                    let x = cx;
                    let y = cy;
                    let step = Math.PI / spikes;

                    ctx.moveTo(cx, cy - outerRadius);
                    for (let i = 0; i < spikes; i++) {
                        x = cx + Math.cos(rot) * outerRadius;
                        y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y);
                        rot += step;

                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y);
                        rot += step;
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                }

                drawPolygon(ctx, cx, cy, sides, radius) {
                    const angle = 2 * Math.PI / sides;
                    ctx.moveTo(cx + radius * Math.cos(0), cy + radius * Math.sin(0));
                    for (let i = 1; i <= sides; i++) {
                        ctx.lineTo(cx + radius * Math.cos(i * angle), cy + radius * Math.sin(i * angle));
                    }
                }
                
                // Helper method to adjust color brightness
                adjustColorBrightness(color, amount) {
                    // Convert hex to RGB
                    const hex = color.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    
                    // Adjust brightness
                    const newR = Math.max(0, Math.min(255, r + amount));
                    const newG = Math.max(0, Math.min(255, g + amount));
                    const newB = Math.max(0, Math.min(255, b + amount));
                    
                    // Convert back to hex
                    const toHex = (c) => {
                        const hex = c.toString(16);
                        return hex.length === 1 ? "0" + hex : hex;
                    };
                    
                    return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
                } 
            }
            
            // --- Layer & Properties Panel Management ---
            function updateAccordionHeightForCategory(category) {
                // Removed problematic accordion height updates that were causing visual issues
                // The accordion now uses fixed max-height for stability
            }
            
            function updateLayerList() { 
                layerList.innerHTML = ''; 
                const sortedObjects = [...objects].sort((a, b) => b.zIndex - a.zIndex); 
                
                if (sortedObjects.length === 0) {
                    layersEmptyState.style.display = 'block';
                    layerList.style.display = 'none';
                    return;
                }
                
                layersEmptyState.style.display = 'none';
                layerList.style.display = 'block';
                
                sortedObjects.forEach((obj, index) => { 
                    const isTop = index === 0; 
                    const isBottom = index === sortedObjects.length - 1; 
                    const div = document.createElement('div'); 
                    div.className = `layer-item px-3 py-1 mb-1 rounded-md flex justify-between items-center cursor-pointer text-xs transition-all ${selectedObject?.id === obj.id ? 'selected' : ''}`; 
                    div.dataset.id = obj.id; 
                    
                    const nameSpan = document.createElement('span'); 
                    nameSpan.textContent = obj.name; 
                    nameSpan.className = 'flex-grow truncate mr-1 ml-1 font-medium text-xs overflow-hidden'; 
                    div.appendChild(nameSpan); 
                    
                    const controls = document.createElement('div'); 
                    controls.className = 'flex items-center gap-1'; 
                    
                    const upBtn = document.createElement('button'); 
                    upBtn.innerHTML = '▲'; 
                    upBtn.className = 'layer-item-button'; 
                    upBtn.disabled = isTop; 
                    upBtn.title = 'Move up'; 
                    upBtn.onclick = (e) => { e.stopPropagation(); moveObject(obj.id, 'up'); }; 
                    controls.appendChild(upBtn); 
                    
                    const downBtn = document.createElement('button'); 
                    downBtn.innerHTML = '▼'; 
                    downBtn.className = 'layer-item-button'; 
                    downBtn.disabled = isBottom; 
                    downBtn.title = 'Move down'; 
                    downBtn.onclick = (e) => { e.stopPropagation(); moveObject(obj.id, 'down'); }; 
                    controls.appendChild(downBtn); 
                    
                    const visibilityToggle = document.createElement('button'); 
                    visibilityToggle.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 616 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>';
                    visibilityToggle.className = `layer-item-button ${!obj.visible ? 'layer-visibility-hidden' : ''}`;
                    visibilityToggle.title = obj.visible ? 'Hide' : 'Show'; 
                    visibilityToggle.onclick = (e) => { 
                        e.stopPropagation(); 
                        obj.visible = !obj.visible; 
                        draw(); 
                        updateLayerList(); 
                    }; 
                    controls.appendChild(visibilityToggle); 
                    
                    div.appendChild(controls); 
                    div.onclick = () => { 
                        setSelectedObject(objects.find(o => o.id === obj.id)); 
                    }; 
                    layerList.appendChild(div); 
                }); 
            }
            function updatePropertiesPanel() { 
                propertiesPanel.style.display = 'block'; 
                noSelectionProperties.style.display = 'none'; 
                textProperties.style.display = 'none'; 
                shapeProperties.style.display = 'none'; 
                transformProperties.style.display = 'none';
                imageProperties.style.display = 'none';
                const animationProperties = document.getElementById('animation-properties');
                const noSelectionMsg = document.getElementById('no-selection-message');
                // Always start hidden
                animationProperties.style.display = 'none';
                
                if (selectedObject) { 
                    // Show transform properties for all objects
                    transformProperties.style.display = 'block';
                    // Do not offer rotation for text objects
                    if (selectedObject.type === 'text') {
                        rotate90Btn.style.display = 'none';
                    } else {
                        rotate90Btn.style.display = '';
                    }
                    
                    if (selectedObject.type === 'text') { 
                        textProperties.style.display = 'block'; 
                        textContentInput.value = selectedObject.text; 
                        textColorInput.value = selectedObject.color; 
                        textSizeInput.value = selectedObject.size; 
                        // Set font dropdown based on current family
                        if (selectedObject.fontFamily?.includes('Atkinson')) textFontSelect.value = 'atkinson';
                        else if (selectedObject.fontFamily?.includes('Andika')) textFontSelect.value = 'andika';
                        else if (selectedObject.fontFamily?.includes('Noto Serif')) textFontSelect.value = 'serif';
                        else if (selectedObject.fontFamily?.startsWith('Inter')) textFontSelect.value = 'inter';
                        else if (selectedObject.fontFamily?.startsWith('system-ui')) textFontSelect.value = 'system';
                        else textFontSelect.value = 'luciole';
                        // Sync style toggles
                        textBoldToggle.classList.toggle('active', (selectedObject.fontWeight || 400) >= 600);
                        textBoldToggle.setAttribute('aria-pressed', ((selectedObject.fontWeight || 400) >= 600).toString());
                        textItalicToggle.classList.toggle('active', (selectedObject.fontStyle || 'normal') === 'italic');
                        textItalicToggle.setAttribute('aria-pressed', ((selectedObject.fontStyle || 'normal') === 'italic').toString());
                    } else if (selectedObject.type === 'shape') { 
                        shapeProperties.style.display = 'block'; 
                        shapeColorInput.value = selectedObject.color; 
                    } else if (selectedObject.type === 'image') {
                        imageProperties.style.display = 'block';
                        // Update flip button states
                        flipHorizontalBtn.classList.toggle('active', selectedObject.flipHorizontal || false);
                        flipVerticalBtn.classList.toggle('active', selectedObject.flipVertical || false);
                    }
                    // Show animation properties only for animatable types
                    const animatableTypes = ['text','shape','image'];
                    if (animatableTypes.includes(selectedObject.type)) {
                        animationProperties.style.display = 'block';
                        animationProperties.classList.remove('hidden');
                    }
                } else { 
                    noSelectionProperties.style.display = 'block'; 
                    if (objects.length === 0) {
                        noSelectionMsg.textContent = 'Add a visual target, shape, or text object to see its properties here.';
                    } else {
                        noSelectionMsg.textContent = 'Select an object on the canvas to see and edit its properties.';
                    }
                    animationProperties.style.display = 'none';
                } 
                
                // Update animation properties at the end to ensure proper sync
                updateAnimationProperties();
            }
            
            // Debounce timer for animation properties updates
            let animationUpdateTimeout = null;
            
            function updateAnimationProperties() {
                // Clear any pending updates
                if (animationUpdateTimeout) {
                    clearTimeout(animationUpdateTimeout);
                }
                
                // Use a small delay to batch updates and prevent accordion flicker
                animationUpdateTimeout = setTimeout(() => {
                    if (selectedObject) {
                        // Ensure animation properties exist with defaults
                        if (typeof selectedObject.animationDuration === 'undefined') {
                            selectedObject.animationDuration = 1.0;
                        }
                        if (typeof selectedObject.animationIntensity === 'undefined') {
                            selectedObject.animationIntensity = 5;
                        }
                        
                        // Update animation button selection
                        const animationButtons = document.querySelectorAll('.animation-type-btn');
                        animationButtons.forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.animation === (selectedObject.animationType || ''));
                        });
                        
                        animationDuration.value = selectedObject.animationDuration;
                        animationCycles.value = selectedObject.animationCycles || 1;
                        animationIntensity.value = selectedObject.animationIntensity;
                        
                        // Update text displays
                        const durVal = parseFloat(selectedObject.animationDuration);
                        durationValue.textContent = durVal <= 0.7 ? 'Fast' : durVal >= 2 ? 'Slow' : 'Medium';
                        const cyclesVal = parseInt(selectedObject.animationCycles || 1);
                        cyclesValue.textContent = cyclesVal + ' cycle' + (cyclesVal === 1 ? '' : 's');
                        const intVal = parseInt(selectedObject.animationIntensity);
                        intensityValue.textContent = intVal <= 3 ? 'Small' : intVal >= 7 ? 'Large' : 'Medium';
                        
                        // Show/hide animation settings based on selection
                        updateAnimationUIVisibility();
                        updateAnimationControlButton();
                    } else {
                        // Clear all animation button selections when no object selected
                        const animationButtons = document.querySelectorAll('.animation-type-btn');
                        animationButtons.forEach(btn => btn.classList.remove('active'));
                        animationSettings.classList.add('hidden');
                    }
                    animationUpdateTimeout = null;
                }, 50); // 50ms debounce
            }
            
            function setSelectedObject(obj) { 
                selectedObject = obj; 
                draw(); 
                updateLayerList(); 
                updatePropertiesPanel(); 
                updateAnimationControlButton();
                updateAnimationTriggerPanel();
            }

            // --- UI Interaction ---
            function updateStatusIndicators() {
                // Map status IDs to their accordion button (assumes structure: indicator inside button span sibling)
                const mapping = [
                    { id: 'tools-status', buttonIndex: 0 },
                    { id: 'properties-status', buttonIndex: 1 },
                    { id: 'background-status', buttonIndex: 2 },
                    { id: 'layers-status', buttonIndex: 3 }
                ];

                mapping.forEach(m => {
                    const indicator = document.getElementById(m.id);
                    if (!indicator) return;
                    // Find nearest ancestor button
                    const btn = indicator.closest('button.accordion-button');
                    let isExpanded = false;
                    if (btn) {
                        isExpanded = btn.getAttribute('aria-expanded') === 'true';
                    }
                    indicator.className = `status-indicator ${isExpanded ? 'status-active' : 'status-drawer-closed'}`;
                });
            }
            
            toggleControlsBtn.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                mediaLibrary.classList.remove('open'); 
                controlsDrawer.classList.toggle('open'); 
                updateStatusIndicators();
            });
            
            toggleLibraryBtn.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                controlsDrawer.classList.remove('open'); 
                mediaLibrary.classList.toggle('open'); 
                updateStatusIndicators();
            });
            
            // Fullscreen toggle functionality
            fullscreenToggle.addEventListener('click', async (e) => {
                e.stopPropagation();
                
                try {
                    if (!document.fullscreenElement) {
                        // Enter fullscreen
                        await document.documentElement.requestFullscreen();
                        fullscreenEnterIcon.classList.add('hidden');
                        fullscreenExitIcon.classList.remove('hidden');
                        fullscreenText.textContent = 'Exit Fullscreen';
                        fullscreenToggle.classList.add('active');
                    } else {
                        // Exit fullscreen
                        await document.exitFullscreen();
                        fullscreenEnterIcon.classList.remove('hidden');
                        fullscreenExitIcon.classList.add('hidden');
                        fullscreenText.textContent = 'Enter Fullscreen';
                        fullscreenToggle.classList.remove('active');
                    }
                } catch (error) {
                    console.log('Fullscreen not supported or failed:', error);
                }
            });
            
            // Listen for fullscreen changes (e.g., when user presses ESC)
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    fullscreenEnterIcon.classList.remove('hidden');
                    fullscreenExitIcon.classList.add('hidden');
                    fullscreenText.textContent = 'Enter Fullscreen';
                    fullscreenToggle.classList.remove('active');
                } else {
                    fullscreenEnterIcon.classList.add('hidden');
                    fullscreenExitIcon.classList.remove('hidden');
                    fullscreenText.textContent = 'Exit Fullscreen';
                    fullscreenToggle.classList.add('active');
                }
            });

            // Export Scene button (clean snapshot without selection box)
            const saveImageBtn = document.getElementById('save-image-btn');
            saveImageBtn.addEventListener('click', () => {
                try {
                    const prevSelected = selectedObject;
                    // Hide selection box
                    selectedObject = null;
                    draw();
                    requestAnimationFrame(() => {
                        canvas.toBlob((blob) => {
                            // Restore selection
                            selectedObject = prevSelected;
                            draw();
                            if (!blob) {
                                alert('Failed to create image.');
                                return;
                            }
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                            link.download = `gaze-tracker-image-${timestamp}.png`;
                            link.href = url;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                            saveImageBtn.classList.add('active');
                            setTimeout(()=> saveImageBtn.classList.remove('active'), 900);
                        }, 'image/png', 1.0);
                    });
                } catch (err) {
                    console.error('Save image failed', err);
                    alert('Failed to save image.');
                }
            });
            
            accordionButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const isExpanded = button.getAttribute('aria-expanded') === 'true';
                    button.setAttribute('aria-expanded', !isExpanded);
            
                    // The content is the next sibling of the button's parent header
                    const content = button.parentElement.nextElementSibling;
                    if (content && content.classList.contains('accordion-content')) {
                        if (!isExpanded) {
                            // Expand: use a stable max-height approach
                            content.style.maxHeight = '2000px'; // Large enough for any content
                        } else {
                            // Collapse
                            content.style.maxHeight = '0px';
                        }
                    }
                    // After toggle, refresh indicator lights
                    updateStatusIndicators();
                });
            
                // Set initial state for accordions that are open by default
                if (button.getAttribute('aria-expanded') === 'true') {
                    const content = button.parentElement.nextElementSibling;
                    if (content) {
                       content.style.maxHeight = '2000px'; // Stable initial height
                    }
                }
                // Set initial indicators once
                updateStatusIndicators();
            });

            controlsDrawer.addEventListener('click', e => e.stopPropagation());
            mediaLibrary.addEventListener('click', e => e.stopPropagation());

            // --- Auto Load Settings Panel Logic ---
            const mediaSettingsToggle = document.getElementById('media-settings-toggle');
            const mediaSettingsPanel = document.getElementById('media-settings-panel');
            const autoLoadVisualTargetsChk = document.getElementById('auto-load-visual-targets');
            const autoLoadBackgroundsChk = document.getElementById('auto-load-backgrounds');
            const autoLoadForegroundsChk = document.getElementById('auto-load-foregrounds');
            const pickVTBtn = document.getElementById('pick-vt-folder');
            const pickBGBtn = document.getElementById('pick-bg-folder');
            const pickFGBtn = document.getElementById('pick-fg-folder');
            const clearVTBtn = document.getElementById('clear-vt-folder');
            const clearBGBtn = document.getElementById('clear-bg-folder');
            const clearFGBtn = document.getElementById('clear-fg-folder');
            const runAutoLoadNowBtn = document.getElementById('run-auto-load-now');
            
            // New UI elements (keeping only essential ones)
            
            // File management elements
            const viewAutoLoadedBtn = document.getElementById('view-auto-loaded-files');
            const clearAllAutoLoadedBtn = document.getElementById('clear-all-auto-loaded');
            const autoLoadedInfo = document.getElementById('auto-loaded-info');
            
            // Toast notification elements
            const autoLoadToast = document.getElementById('auto-load-toast');
            const toastIcon = document.getElementById('toast-icon');
            const toastTitle = document.getElementById('toast-title');
            const toastMessage = document.getElementById('toast-message');
            const toastProgressContainer = document.getElementById('toast-progress-container');
            const toastProgressBar = document.getElementById('toast-progress-bar');
            const toastProgressText = document.getElementById('toast-progress-text');
            const toastClose = document.getElementById('toast-close');
            

            const AUTO_LOAD_KEY = 'autoLoadFolders.v1';
            let autoLoadConfig = { visualTargets: null, backgrounds: null, foregrounds: null, enabled: { visualTargets:false, backgrounds:false, foregrounds:false } };

            // Persistent Directory Handle Storage via IndexedDB -----------------
            const supportsFSAccess = 'showDirectoryPicker' in window && 'indexedDB' in window;
            let handlesDBPromise = null;
            function getHandlesDB(){
                if(!supportsFSAccess) return Promise.resolve(null);
                if(handlesDBPromise) return handlesDBPromise;
                handlesDBPromise = new Promise((resolve, reject)=>{
                    const req = indexedDB.open('autoLoadHandlesDB',1);
                    req.onupgradeneeded = e => {
                        const db = req.result;
                        if(!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
                    };
                    req.onsuccess = ()=> resolve(req.result);
                    req.onerror = ()=> reject(req.error);
                });
                return handlesDBPromise;
            }
            async function saveHandlePersistent(key, handle){
                const db = await getHandlesDB(); if(!db) return;
                return new Promise((resolve,reject)=>{
                    const tx = db.transaction('handles','readwrite');
                    tx.objectStore('handles').put(handle, key);
                    tx.oncomplete = ()=> resolve();
                    tx.onerror = ()=> reject(tx.error);
                });
            }
            async function deleteHandlePersistent(key){
                const db = await getHandlesDB(); if(!db) return;
                return new Promise((resolve,reject)=>{
                    const tx = db.transaction('handles','readwrite');
                    tx.objectStore('handles').delete(key);
                    tx.oncomplete = ()=> resolve();
                    tx.onerror = ()=> reject(tx.error);
                });
            }
            async function loadPersistentHandles(){
                const db = await getHandlesDB(); if(!db) return;
                await Promise.all(['visualTargets','backgrounds','foregrounds'].map(key => new Promise((resolve)=>{
                    const tx = db.transaction('handles','readonly');
                    const req = tx.objectStore('handles').get(key);
                    req.onsuccess = ()=> {
                        const handle = req.result;
                        if(handle){
                            if(!autoLoadConfig[key]) autoLoadConfig[key] = { name: handle.name || (autoLoadConfig[key]?.name)|| 'Folder', handle };
                            else autoLoadConfig[key].handle = handle;
                        }
                        resolve();
                    };
                    req.onerror = ()=> resolve();
                })));
            }
            async function ensurePermission(dirHandle){
                if(!dirHandle) return false;
                try {
                    let perm = await dirHandle.queryPermission({mode:'read'});
                    if(perm === 'granted') return true;
                    if(perm === 'prompt') {
                        perm = await dirHandle.requestPermission({mode:'read'});
                        return perm === 'granted';
                    }
                } catch(e){ console.warn('Permission check failed', e); }
                return false;
            }

            function loadAutoLoadConfig() {
                try {
                    const raw = localStorage.getItem(AUTO_LOAD_KEY);
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        if (parsed && parsed.enabled) autoLoadConfig = parsed;
                    }
                } catch(e) { console.warn('Failed to parse auto load config', e); }
            }
            function saveAutoLoadConfig() {
                localStorage.setItem(AUTO_LOAD_KEY, JSON.stringify(autoLoadConfig));
            }
            function updateAutoLoadUI(skipPermissionChecks = false) {
                const categories = ['visualTargets', 'backgrounds', 'foregrounds'];
                
                categories.forEach(key => {
                    const prefix = key === 'visualTargets' ? 'vt' : key === 'backgrounds' ? 'bg' : 'fg';
                    const checkbox = document.getElementById(`auto-load-${key.replace('Targets', '-targets')}`);
                    const indicator = document.getElementById(`${prefix}-status-indicator`);
                    const fileCount = document.getElementById(`${prefix}-file-count`);
                    const folderInfo = document.getElementById(`${prefix}-folder-info`);
                    const clearBtn = document.getElementById(`clear-${prefix}-folder`);
                    
                    const config = autoLoadConfig[key];
                    const enabled = autoLoadConfig.enabled[key];
                    
                    // Update checkbox
                    if (checkbox) checkbox.checked = enabled && !!config;
                    
                    // Update status indicator
                    if (indicator) {
                        indicator.className = 'w-3 h-3 rounded-full';
                        if (config && config.handle) {
                            indicator.classList.add('bg-green-500');
                            indicator.title = 'Folder connected';
                        } else {
                            indicator.classList.add('bg-slate-500');
                            indicator.title = 'No folder selected';
                        }
                    }
                    
                    // Update folder info
                    if (folderInfo) {
                        if (config && config.name) {
                            folderInfo.textContent = `📁 ${config.name}`;
                            folderInfo.classList.remove('text-slate-400');
                            folderInfo.classList.add('text-slate-300');
                        } else {
                            folderInfo.textContent = 'No folder selected';
                            folderInfo.classList.remove('text-slate-300');
                            folderInfo.classList.add('text-slate-400');
                        }
                    }
                    
                    // Show/hide file count
                    if (fileCount) {
                        if (config && config.handle) {
                            // Update file counts, optionally skipping permission checks
                            updateFileCount(key, prefix, skipPermissionChecks);
                        } else {
                            fileCount.classList.add('hidden');
                        }
                    }
                    
                    // Update clear button
                    if (clearBtn) {
                        clearBtn.classList.toggle('inactive', !config);
                    }
                });
            }
            
            async function updateFileCount(key, prefix, skipPermissionCheck = false) {
                const config = autoLoadConfig[key];
                const fileCountEl = document.getElementById(`${prefix}-file-count`);
                const indicator = document.getElementById(`${prefix}-status-indicator`);
                
                if (!config || !config.handle || !fileCountEl) return;
                
                try {
                    // Skip permission checks on startup to avoid prompts
                    if (!skipPermissionCheck) {
                        const hasPermission = await ensurePermission(config.handle);
                        if (!hasPermission) {
                            // Update indicator to show permission needed
                            if (indicator) {
                                indicator.className = 'w-3 h-3 rounded-full bg-yellow-500';
                                indicator.title = 'Permission needed - click to load files';
                            }
                            const folderInfo = document.getElementById(`${prefix}-folder-info`);
                            if (folderInfo) {
                                folderInfo.textContent = `📁 ${config.name} (click to grant permission)`;
                                folderInfo.classList.remove('text-slate-300');
                                folderInfo.classList.add('text-yellow-400');
                            }
                            return;
                        }
                    }
                    
                    // If skipping permission check, just show folder as connected
                    if (skipPermissionCheck) {
                        if (indicator) {
                            indicator.className = 'w-3 h-3 rounded-full bg-green-500';
                            indicator.title = 'Folder connected';
                        }
                        fileCountEl.textContent = 'Ready to load';
                        fileCountEl.classList.remove('hidden');
                        return;
                    }
                    
                    // Get file extensions for this category
                    const extensions = getExtensionsForCategory(key);
                    const files = await loadDirectoryEntries(config.handle, extensions);
                    
                    // Update file count
                    fileCountEl.textContent = `${files.length} file${files.length !== 1 ? 's' : ''}`;
                    fileCountEl.classList.remove('hidden');
                    
                    // Update indicator color based on file count
                    if (indicator) {
                        if (files.length > 0) {
                            indicator.className = 'w-3 h-3 rounded-full bg-green-500';
                            indicator.title = `${files.length} files ready`;
                        } else {
                            indicator.className = 'w-3 h-3 rounded-full bg-orange-500';
                            indicator.title = 'No supported files found';
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to count files for ${key}:`, error);
                    if (indicator) {
                        indicator.className = 'w-3 h-3 rounded-full bg-red-500';
                        indicator.title = 'Error accessing folder';
                    }
                }
            }
            
            function getExtensionsForCategory(key) {
                switch (key) {
                    case 'visualTargets':
                        return ['.png','.jpg','.jpeg','.gif','.webp','.mp4','.mov','.avi','.mkv','.webm','.3gp','.wmv','.flv','.m4v'];
                    case 'backgrounds':
                    case 'foregrounds':
                        return ['.png','.jpg','.jpeg','.gif','.webp'];
                    default:
                        return [];
                }
            }
            
            // Toast notification system
            function showToast(title, message, type = 'info', showProgress = false) {
                if (!autoLoadToast) return;
                
                // Set icon based on type
                const iconSvg = {
                    'info': '<svg class="w-5 h-5 text-blue-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>',
                    'success': '<svg class="w-5 h-5 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>',
                    'error': '<svg class="w-5 h-5 text-red-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg>',
                    'warning': '<svg class="w-5 h-5 text-yellow-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>'
                };
                
                toastIcon.innerHTML = iconSvg[type] || iconSvg['info'];
                toastTitle.textContent = title;
                toastMessage.textContent = message;
                
                if (showProgress) {
                    toastProgressContainer.classList.remove('hidden');
                    toastProgressBar.style.width = '0%';
                    toastProgressText.textContent = '';
                } else {
                    toastProgressContainer.classList.add('hidden');
                }
                
                autoLoadToast.classList.remove('hidden');
                
                // Auto-hide for success and info messages (unless showing progress)
                if (!showProgress && (type === 'success' || type === 'info')) {
                    setTimeout(() => hideToast(), 5000);
                }
            }
            
            function updateToastProgress(progress, text = '') {
                if (toastProgressBar && toastProgressText) {
                    toastProgressBar.style.width = `${Math.max(0, Math.min(100, progress))}%`;
                    toastProgressText.textContent = text;
                }
            }
            
            function hideToast() {
                if (autoLoadToast) {
                    autoLoadToast.classList.add('hidden');
                    toastProgressContainer.classList.add('hidden');
                }
            }
            
            // File management functions
            function showAutoLoadedFilesInfo() {
                const allAutoLoaded = MediaLibrary.getAllAutoLoadedFiles();
                
                if (allAutoLoaded.length === 0) {
                    autoLoadedInfo.textContent = 'No auto-loaded files found.';
                    autoLoadedInfo.classList.remove('hidden');
                    return;
                }
                
                const categoryCount = {};
                allAutoLoaded.forEach(item => {
                    if (!categoryCount[item.category]) {
                        categoryCount[item.category] = 0;
                    }
                    categoryCount[item.category]++;
                });
                
                const infoText = Object.entries(categoryCount)
                    .map(([category, count]) => {
                        const categoryName = category === 'visualTargets' ? 'Visual Targets' : 
                                           category === 'backgrounds' ? 'Backgrounds' : 'Foregrounds';
                        return `${categoryName}: ${count}`;
                    })
                    .join(' | ');
                
                autoLoadedInfo.textContent = `Auto-loaded files: ${infoText} (Total: ${allAutoLoaded.length})`;
                autoLoadedInfo.classList.remove('hidden');
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    autoLoadedInfo.classList.add('hidden');
                }, 10000);
            }
            
            function clearAllAutoLoadedFiles() {
                const allAutoLoaded = MediaLibrary.getAllAutoLoadedFiles();
                
                if (allAutoLoaded.length === 0) {
                    showToast('No Files to Clear', 'No auto-loaded files found.', 'info');
                    return;
                }
                
                if (!confirm(`This will remove ${allAutoLoaded.length} auto-loaded files from the media library. Continue?`)) {
                    return;
                }
                
                let totalCleared = 0;
                Object.keys(MediaLibrary.assets).forEach(category => {
                    const cleared = MediaLibrary.clearAutoLoadedFiles(category);
                    totalCleared += cleared;
                });
                
                // Update media library display
                MediaLibrary.updateView();
                
                showToast('Files Cleared', `Removed ${totalCleared} auto-loaded files from the media library.`, 'success');
                
                // Update file counts
                setTimeout(() => {
                    updateAutoLoadUI();
                }, 500);
            }
            async function refreshPermissionStates(){
                // Update status indicators and folder info based on permissions
                for (const key of ['visualTargets','backgrounds','foregrounds']){
                    const entry = autoLoadConfig[key];
                    if(entry && entry.handle){
                        const granted = await ensurePermission(entry.handle);
                        const prefix = key === 'visualTargets' ? 'vt' : key === 'backgrounds' ? 'bg' : 'fg';
                        const indicator = document.getElementById(`${prefix}-status-indicator`);
                        const folderInfo = document.getElementById(`${prefix}-folder-info`);
                        
                        if(!granted){
                            if (indicator) {
                                indicator.className = 'w-3 h-3 rounded-full bg-yellow-500';
                                indicator.title = 'Permission needed';
                            }
                            if (folderInfo) {
                                folderInfo.textContent = `📁 ${entry.name || 'Folder'} (permission needed)`;
                                folderInfo.classList.remove('text-slate-300');
                                folderInfo.classList.add('text-yellow-400');
                            }
                        }
                    }
                }
                updateAutoLoadUI();
            }
            async function pickDirectoryFor(key) {
                if (!window.showDirectoryPicker) {
                    showToast('Browser Not Supported', 'Your browser does not support directory access. Use a Chromium-based browser.', 'error');
                    return;
                }
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    autoLoadConfig[key] = { name: dirHandle.name, handle: dirHandle }; // Persist handle in IndexedDB
                    autoLoadConfig.enabled[key] = true; // Always enable when user picks a folder
                    
                    // Save and update UI
                    saveHandlePersistent(key, dirHandle).catch(()=>{});
                    saveAutoLoadConfig();
                    updateAutoLoadUI(); // Check permissions now since user actively selected folder
                    
                    // Show success feedback
                    const categoryName = key === 'visualTargets' ? 'Visual Targets' : 
                                       key === 'backgrounds' ? 'Backgrounds' : 'Foregrounds';
                    showToast('Folder Connected', `${categoryName} folder "${dirHandle.name}" has been connected successfully.`, 'success');
                    
                } catch(e) { 
                    if (e.name !== 'AbortError') {
                        console.warn('Folder pick cancelled/failed', e);
                        showToast('Folder Selection Failed', 'Unable to select folder. Please try again.', 'error');
                    }
                }
            }
            // Legacy placeholder retained (no-op)
            function saveHandlesTransient(){ }

            async function loadDirectoryEntries(dirHandle, filters) {
                if (!dirHandle) return [];
                const entries = [];
                try {
                    for await (const [name, handle] of dirHandle.entries()) {
                        if (handle.kind === 'file') {
                            const lower = name.toLowerCase();
                            if (filters.some(f=> lower.endsWith(f))) {
                                const file = await handle.getFile();
                                entries.push(file);
                            }
                        }
                    }
                } catch(e) { console.warn('Directory read failed', e); }
                return entries;
            }
            async function runAutoLoad(isUserInitiated = false) {
                const categories = [
                    { key: 'visualTargets', handle: autoLoadConfig.visualTargets?.handle, enabled: autoLoadConfig.enabled.visualTargets, extensions: ['.png','.jpg','.jpeg','.gif','.webp','.mp4','.mov','.avi','.mkv','.webm','.3gp','.wmv','.flv','.m4v'] },
                    { key: 'backgrounds', handle: autoLoadConfig.backgrounds?.handle, enabled: autoLoadConfig.enabled.backgrounds, extensions: ['.png','.jpg','.jpeg','.gif','.webp'] },
                    { key: 'foregrounds', handle: autoLoadConfig.foregrounds?.handle, enabled: autoLoadConfig.enabled.foregrounds, extensions: ['.png','.jpg','.jpeg','.gif','.webp'] }
                ];

                const enabledCategories = categories.filter(cat => cat.enabled && cat.handle);
                if (enabledCategories.length === 0) {
                    if (isUserInitiated) {
                        showToast('No Folders Selected', 'Please select and enable folders before running auto-load.', 'warning');
                    }
                    return;
                }

                if (isUserInitiated) {
                    showToast('Auto-Loading Files', 'Checking permissions and loading files...', 'info', true);
                }

                // Check for permissions and request if necessary
                let permissionIssues = [];
                for (const cat of enabledCategories) {
                    const hasPermission = await ensurePermission(cat.handle);
                    if (!hasPermission) {
                        if (isUserInitiated) {
                            try {
                                await cat.handle.requestPermission({ mode: 'read' });
                            } catch (e) {
                                permissionIssues.push(cat.key);
                            }
                        } else {
                            permissionIssues.push(cat.key);
                        }
                    }
                }

                if (permissionIssues.length > 0 && isUserInitiated) {
                    const folderNames = permissionIssues.map(key => {
                        switch(key) {
                            case 'visualTargets': return 'Visual Targets';
                            case 'backgrounds': return 'Backgrounds';
                            case 'foregrounds': return 'Foregrounds';
                            default: return key;
                        }
                    }).join(', ');
                    showToast('Permission Required', `Permission needed for: ${folderNames}. Some folders will be skipped.`, 'warning');
                }

                let totalLoaded = 0;
                let processedCategories = 0;
                
                for (const cat of enabledCategories) {
                    try {
                        // Final check, in case permission was just denied
                        if (await ensurePermission(cat.handle)) {
                            const files = await loadDirectoryEntries(cat.handle, cat.extensions);
                            if (files.length > 0) {
                                const folderName = autoLoadConfig[cat.key]?.name || 'Auto-loaded folder';
                                await handleFiles(files, cat.key, true, folderName);
                                totalLoaded += files.length;
                            }
                        }
                    } catch (e) {
                        console.warn(`Failed to load ${cat.key}:`, e);
                        if (isUserInitiated) {
                            const categoryName = cat.key === 'visualTargets' ? 'Visual Targets' : 
                                               cat.key === 'backgrounds' ? 'Backgrounds' : 'Foregrounds';
                            showToast('Load Error', `Failed to load files from ${categoryName} folder.`, 'error');
                        }
                    }
                    
                    processedCategories++;
                    if (isUserInitiated) {
                        updateToastProgress((processedCategories / enabledCategories.length) * 100, 
                                          `Processed ${processedCategories}/${enabledCategories.length} folders`);
                    }
                }

                if (isUserInitiated) {
                    setTimeout(() => {
                        hideToast();
                        if (totalLoaded > 0) {
                            showToast('Loading Complete', `Successfully loaded ${totalLoaded} files!`, 'success');
                        } else {
                            showToast('No Files Loaded', 'Make sure folders contain supported files and permissions are granted.', 'warning');
                        }
                    }, 500);
                }
                
                // Update file counts after loading
                setTimeout(() => {
                    updateAutoLoadUI(); // Don't skip permission checks after user-initiated loading
                }, 1000);
            }

            mediaSettingsToggle?.addEventListener('click', () => {
                const expanded = mediaSettingsToggle.getAttribute('aria-expanded') === 'true';
                mediaSettingsToggle.setAttribute('aria-expanded', !expanded);
                if (expanded) {
                    mediaSettingsPanel.style.maxHeight = '0px';
                } else {
                    mediaSettingsPanel.style.maxHeight = '2000px'; // Increased from 1000px to accommodate all content
                }
            });
            autoLoadVisualTargetsChk?.addEventListener('change', e => { autoLoadConfig.enabled.visualTargets = e.target.checked; saveAutoLoadConfig(); });
            autoLoadBackgroundsChk?.addEventListener('change', e => { autoLoadConfig.enabled.backgrounds = e.target.checked; saveAutoLoadConfig(); });
            autoLoadForegroundsChk?.addEventListener('change', e => { autoLoadConfig.enabled.foregrounds = e.target.checked; saveAutoLoadConfig(); });
            pickVTBtn?.addEventListener('click', () => pickDirectoryFor('visualTargets'));
            pickBGBtn?.addEventListener('click', () => pickDirectoryFor('backgrounds'));
            pickFGBtn?.addEventListener('click', () => pickDirectoryFor('foregrounds'));
            clearVTBtn?.addEventListener('click', () => { 
                autoLoadConfig.visualTargets=null; 
                autoLoadConfig.enabled.visualTargets=false; 
                deleteHandlePersistent('visualTargets').catch(()=>{}); 
                saveAutoLoadConfig(); 
                updateAutoLoadUI(); 
            });
            clearBGBtn?.addEventListener('click', () => { 
                autoLoadConfig.backgrounds=null; 
                autoLoadConfig.enabled.backgrounds=false; 
                deleteHandlePersistent('backgrounds').catch(()=>{}); 
                saveAutoLoadConfig(); 
                updateAutoLoadUI(); 
            });
            clearFGBtn?.addEventListener('click', () => { 
                autoLoadConfig.foregrounds=null; 
                autoLoadConfig.enabled.foregrounds=false; 
                deleteHandlePersistent('foregrounds').catch(()=>{}); 
                saveAutoLoadConfig(); 
                updateAutoLoadUI(); 
            });
            runAutoLoadNowBtn?.addEventListener('click', () => runAutoLoad(true));

            // File management event listeners
            viewAutoLoadedBtn?.addEventListener('click', showAutoLoadedFilesInfo);
            clearAllAutoLoadedBtn?.addEventListener('click', clearAllAutoLoadedFiles);
            
            // Toast notification close button
            toastClose?.addEventListener('click', hideToast);

            function updateImportButtonVisibility(){
                // This function is no longer needed but kept to avoid breaking other parts of the code
            }

            loadAutoLoadConfig();
            updateAutoLoadUI(true); // Skip permission checks on startup
            // Load any persisted handles and update UI without auto-running
            loadPersistentHandles().then(()=> {
                // Don't check permissions or auto-run on startup to avoid annoying prompts
                // refreshPermissionStates(); // Commented out to prevent startup permission prompts
                updateAutoLoadUI(true); // Just update the UI without permission checks
            });

            // --- Cache Management ---
            const clearAppCacheBtn = document.getElementById('clear-app-cache');
            const checkAppVersionBtn = document.getElementById('check-app-version');
            const versionInfo = document.getElementById('version-info');
            
            clearAppCacheBtn?.addEventListener('click', async () => {
                const button = clearAppCacheBtn;
                const originalText = button.textContent;
                
                try {
                    button.textContent = 'Clearing...';
                    button.disabled = true;
                    
                    // Clear all caches
                    if ('caches' in window) {
                        const cacheNames = await caches.keys();
                        await Promise.all(cacheNames.map(name => caches.delete(name)));
                    }
                    
                    // Clear service worker cache via message
                    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                        const messageChannel = new MessageChannel();
                        messageChannel.port1.onmessage = (event) => {
                            if (event.data.success) {
                                console.log('Service worker cache cleared');
                            }
                        };
                        navigator.serviceWorker.controller.postMessage(
                            { type: 'CLEAR_CACHE' }, 
                            [messageChannel.port2]
                        );
                    }
                    
                    // Show success message
                    button.textContent = 'Cache Cleared!';
                    button.classList.remove('upload-button');
                    button.classList.add('delete-button');
                    
                    // Reload after brief delay
                    setTimeout(() => {
                        window.location.reload(true);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Cache clearing failed:', error);
                    button.textContent = 'Error - Try Ctrl+Shift+R';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 3000);
                }
            });
            
            checkAppVersionBtn?.addEventListener('click', async () => {
                const currentVersion = APP_VERSION;
                const storedVersion = localStorage.getItem(VERSION_KEY) || 'unknown';
                const lastUpdate = localStorage.getItem('lastForceReload');
                
                let serviceWorkerVersion = 'not available';
                
                // Try to get service worker version
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    try {
                        const messageChannel = new MessageChannel();
                        messageChannel.port1.onmessage = (event) => {
                            serviceWorkerVersion = event.data.version || 'unknown';
                            updateVersionDisplay();
                        };
                        navigator.serviceWorker.controller.postMessage(
                            { type: 'GET_VERSION' }, 
                            [messageChannel.port2]
                        );
                        
                        // Fallback timeout
                        setTimeout(updateVersionDisplay, 1000);
                    } catch (e) {
                        updateVersionDisplay();
                    }
                } else {
                    updateVersionDisplay();
                }
                
                function updateVersionDisplay() {
                    versionInfo.classList.remove('hidden');
                    const lastUpdateDate = lastUpdate ? new Date(parseInt(lastUpdate)).toLocaleDateString() : 'Never';
                    const statusIcon = storedVersion === currentVersion ? '✅' : '⚠️';
                    const statusText = storedVersion === currentVersion ? 'Up to date' : 'Version mismatch';
                    
                    versionInfo.innerHTML = `
                        <div class="text-emerald-400 font-medium mb-1">📋 Version Status</div>
                        <div class="grid grid-cols-2 gap-1 text-xs">
                            <div>Current:</div><div class="text-slate-200">${currentVersion}</div>
                            <div>Stored:</div><div class="text-slate-200">${storedVersion}</div>
                            <div>SW:</div><div class="text-slate-200">${serviceWorkerVersion}</div>
                            <div>Last Clear:</div><div class="text-slate-200">${lastUpdateDate}</div>
                        </div>
                        <div class="mt-2 text-xs font-medium ${storedVersion === currentVersion ? 'text-emerald-400' : 'text-yellow-400'}">
                            ${statusIcon} ${statusText}
                        </div>
                    `;
                }
            });

            // --- Grid System ---
            const gridsToggle = document.getElementById('grids-toggle');
            const gridsPanel = document.getElementById('grids-panel');
            const showGuidesChk = document.getElementById('show-position-guides');
            const enableAutoSnapChk = document.getElementById('enable-auto-snap');
            const arrangeTargetsBtn = document.getElementById('arrange-all-targets');
            const turnOffGridBtn = document.getElementById('turn-off-grid');
            
            // Grid calculation functions
            function calculateGridFrames(frameCount) {
                if (!frameCount) return [];
                
                const frames = [];
                let cols, rows;
                
                // Determine grid layout
                switch (frameCount) {
                    case 2:
                        cols = 2; rows = 1;
                        break;
                    case 4:
                        cols = 2; rows = 2;
                        break;
                    case 6:
                        cols = 3; rows = 2;
                        break;
                    case 9:
                        cols = 3; rows = 3;
                        break;
                    case 12:
                        cols = 4; rows = 3;
                        break;
                    default:
                        return [];
                }
                
                const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                const frameWidth = canvasWidth / cols;
                const frameHeight = canvasHeight / rows;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        frames.push({
                            x: col * frameWidth + frameWidth / 2,
                            y: row * frameHeight + frameHeight / 2,
                            width: frameWidth,
                            height: frameHeight,
                            col,
                            row,
                            occupied: false // Simplified occupancy tracking
                        });
                    }
                }
                
                return frames;
            }
            
        function findNearestGridFrame(x, y) {
                if (!currentGrid || gridFrames.length === 0) return null;
                
                let nearestFrame = null;
                let minDistance = snapStrength;
                
                gridFrames.forEach(frame => {
                    const distance = Math.sqrt((x - frame.x) ** 2 + (y - frame.y) ** 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestFrame = frame;
                    }
                });
                
                return nearestFrame;
            }
            
            function snapToGrid(x, y, isShiftHeld = false) {
                if (!currentGrid || !enableAutoSnap || isShiftHeld) return { x, y };
                
                // Ensure grid frames are calculated for current canvas size
                if (gridFrames.length === 0 && currentGrid) {
                    gridFrames = calculateGridFrames(currentGrid);
                }
                
                const nearestFrame = findNearestGridFrame(x, y);
                if (nearestFrame) {
                    const dx = nearestFrame.x - x;
                    const dy = nearestFrame.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= snapStrength) {
                        // Always use smooth magnetic falloff for natural feel
                        const normalizedDist = distance / snapStrength; // 0 to 1
                        const strength = Math.max(0.3, 1 - (normalizedDist * normalizedDist)); // Quadratic falloff with minimum
                        const snapX = x + dx * strength;
                        const snapY = y + dy * strength;
                        return { x: snapX, y: snapY };
                    }
                }
                
                return { x, y };
            }
            
            // Helper functions to get object center and convert between center and position
            function getObjectCenter(obj) {
                if (!obj) return { x: 0, y: 0 };
                
                let centerX, centerY;
                
                if (obj.type === 'circle') {
                    centerX = obj.x;
                    centerY = obj.y;
                } else if (obj.type === 'text') {
                    // For text, x,y is top-left; compute center from width/height
                    centerX = obj.x + (obj.width || 0) / 2;
                    centerY = obj.y + (obj.height || 0) / 2;
                } else {
                    // For rectangles, images, videos - position is top-left, so calculate center
                    centerX = obj.x + obj.width / 2;
                    centerY = obj.y + obj.height / 2;
                }
                
                return { x: centerX, y: centerY };
            }
            
            function setObjectCenterPosition(obj, centerX, centerY) {
                if (!obj) return;
                
                if (obj.type === 'circle') {
                    obj.x = centerX;
                    obj.y = centerY;
                } else if (obj.type === 'text') {
                    // Place top-left so the visual center aligns with the target
                    obj.x = centerX - (obj.width || 0) / 2;
                    obj.y = centerY - (obj.height || 0) / 2;
                } else {
                    // For rectangles, images, videos - set position so center is at target
                    obj.x = centerX - obj.width / 2;
                    obj.y = centerY - obj.height / 2;
                }
            }
            
            function snapObjectCenterToGrid(obj, isShiftHeld = false) {
                if (!obj || !currentGrid || isShiftHeld) return;
                
                const center = getObjectCenter(obj);
                const snappedCenter = snapToGrid(center.x, center.y, isShiftHeld);
                
                // Only update if snapping actually occurred
                if (snappedCenter.x !== center.x || snappedCenter.y !== center.y) {
                    setObjectCenterPosition(obj, snappedCenter.x, snappedCenter.y);
                    return true;
                }
                return false;
            }
            
            function animateSnapToGrid(object, targetCenterX, targetCenterY, startCenterX, startCenterY, duration = 200) {
                if (isSnapping) return; // Prevent multiple animations
                
                isSnapping = true;
                const startTime = performance.now();
                
                // If no start center provided, get current center
                if (startCenterX === undefined || startCenterY === undefined) {
                    const currentCenter = getObjectCenter(object);
                    startCenterX = currentCenter.x;
                    startCenterY = currentCenter.y;
                }
                
                // Ensure render loop is active
                ensureRenderLoop();
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Smooth easing function (ease-out)
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    const currentCenterX = startCenterX + (targetCenterX - startCenterX) * easeOut;
                    const currentCenterY = startCenterY + (targetCenterY - startCenterY) * easeOut;
                    
                    setObjectCenterPosition(object, currentCenterX, currentCenterY);
                    
                    draw();
                    
                    if (progress < 1) {
                        snapAnimation = requestAnimationFrame(animate);
                    } else {
                        isSnapping = false;
                        snapAnimation = null;
                        // Recompute occupancy after snap animation completes
                        if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                            recomputeGridOccupancy();
                        }
                    }
                }
                
                snapAnimation = requestAnimationFrame(animate);
            }
            
            function drawGridOverlay() {
                if (!currentGrid || !showGuides || gridFrames.length === 0) return;
                
                ctx.save();
                
                // Draw position guides with elegant styling
                gridFrames.forEach((frame, index) => {
                    // Draw beautiful frame outline with premium styling
                    ctx.strokeStyle = 'rgba(129, 140, 248, 0.25)'; // Soft indigo with more opacity
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]); // Solid lines
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    const left = frame.x - frame.width / 2 + 30;
                    const top = frame.y - frame.height / 2 + 30;
                    const width = frame.width - 60;
                    const height = frame.height - 60;
                    
                    // Create smooth rounded rectangle with subtle shadow
                    const radius = 16;
                    
                    // Subtle shadow/glow effect
                    ctx.shadowColor = 'rgba(129, 140, 248, 0.15)';
                    ctx.shadowBlur = 6;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(left + radius, top);
                    ctx.lineTo(left + width - radius, top);
                    ctx.quadraticCurveTo(left + width, top, left + width, top + radius);
                    ctx.lineTo(left + width, top + height - radius);
                    ctx.quadraticCurveTo(left + width, top + height, left + width - radius, top + height);
                    ctx.lineTo(left + radius, top + height);
                    ctx.quadraticCurveTo(left, top + height, left, top + height - radius);
                    ctx.lineTo(left, top + radius);
                    ctx.quadraticCurveTo(left, top, left + radius, top);
                    ctx.stroke();
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // Add subtle corner accents
                    ctx.setLineDash([]);
                    ctx.strokeStyle = 'rgba(129, 140, 248, 0.4)';
                    ctx.lineWidth = 1;
                    const accentSize = 8;
                    
                    // Top-left corner accent
                    ctx.beginPath();
                    ctx.moveTo(left, top + radius);
                    ctx.quadraticCurveTo(left, top, left + radius, top);
                    ctx.moveTo(left + radius - accentSize, top);
                    ctx.lineTo(left + radius + accentSize, top);
                    ctx.moveTo(left, top + radius - accentSize);
                    ctx.lineTo(left, top + radius + accentSize);
                    ctx.stroke();
                    
                    // Draw premium position dot area with cleaner styling
                    ctx.setLineDash([]);
                    
                    // Subtle outer glow ring (reduced intensity for cleaner look)
                    const outerGradient = ctx.createRadialGradient(frame.x, frame.y, 6, frame.x, frame.y, 14);
                    outerGradient.addColorStop(0, 'rgba(129, 140, 248, 0.15)');
                    outerGradient.addColorStop(1, 'rgba(129, 140, 248, 0)');
                    ctx.fillStyle = outerGradient;
                    ctx.beginPath();
                    ctx.arc(frame.x, frame.y, 14, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw occupancy indicator based on frame.occupied status
                    if (frame.occupied) {
                        // Occupied - filled dot with green theme
                        const mainGradient = ctx.createRadialGradient(
                            frame.x - 2, frame.y - 2, 0,  // Inner highlight offset
                            frame.x, frame.y, 10
                        );
                        mainGradient.addColorStop(0, 'rgba(134, 239, 172, 1)'); // Light green highlight
                        mainGradient.addColorStop(0.7, 'rgba(34, 197, 94, 0.95)'); // Main green
                        mainGradient.addColorStop(1, 'rgba(21, 128, 61, 0.9)'); // Darker edge
                        
                        ctx.fillStyle = mainGradient;
                        ctx.shadowColor = 'rgba(34, 197, 94, 0.5)';
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        
                        // Inner white highlight for occupied indication
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(frame.x - 1, frame.y - 1, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Small filled center dot to show occupancy
                        ctx.fillStyle = 'rgba(21, 128, 61, 0.8)';
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Empty - hollow dot with original blue theme but lighter
                        const mainGradient = ctx.createRadialGradient(
                            frame.x - 2, frame.y - 2, 0,  // Inner highlight offset
                            frame.x, frame.y, 10
                        );
                        mainGradient.addColorStop(0, 'rgba(165, 180, 252, 0.6)'); // Light indigo highlight
                        mainGradient.addColorStop(0.7, 'rgba(129, 140, 248, 0.5)'); // Main indigo, reduced opacity
                        mainGradient.addColorStop(1, 'rgba(79, 70, 229, 0.4)'); // Darker edge, reduced opacity
                        
                        // Draw hollow circle (stroke only for empty)
                        ctx.strokeStyle = mainGradient;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Very subtle inner fill to show it's a valid drop target
                        ctx.fillStyle = 'rgba(165, 180, 252, 0.1)';
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Small highlight on the ring
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(frame.x, frame.y, 8, Math.PI * 1.2, Math.PI * 1.8);
                        ctx.stroke();
                    }
                });
                
                // Enhanced active position highlight when dragging
                if (isDragging && selectedObject) {
                    const center = getObjectCenter(selectedObject);
                    const nearest = findNearestGridFrame(center.x, center.y);
                    if (nearest) {
                        const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                        if (distance <= snapStrength) {
                            // Premium animated highlight rings
                            const time = Date.now() * 0.002;
                            const pulse1 = (Math.sin(time) * 0.4 + 0.6);
                            const pulse2 = (Math.sin(time + Math.PI * 0.5) * 0.3 + 0.7);
                            const pulse3 = (Math.sin(time + Math.PI) * 0.2 + 0.8);
                            
                            // Outer expanding ring
                            ctx.strokeStyle = `rgba(34, 197, 94, ${pulse1 * 0.3})`;
                            ctx.lineWidth = 3;
                            ctx.setLineDash([]);
                            ctx.beginPath();
                            ctx.arc(nearest.x, nearest.y, 25 + pulse2 * 6, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Middle solid ring
                            ctx.setLineDash([]);
                            ctx.strokeStyle = `rgba(34, 197, 94, ${pulse2 * 0.7})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(nearest.x, nearest.y, 18, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Inner glow
                            const snapGradient = ctx.createRadialGradient(nearest.x, nearest.y, 0, nearest.x, nearest.y, 15);
                            snapGradient.addColorStop(0, `rgba(34, 197, 94, ${pulse3 * 0.4})`);
                            snapGradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                            ctx.fillStyle = snapGradient;
                            ctx.beginPath();
                            ctx.arc(nearest.x, nearest.y, 15, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                ctx.restore();
            }
            
        function setGrid(frameCount) {
                // Remove selection from all grid buttons
                document.querySelectorAll('.grid-button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                
                if (frameCount === currentGrid) {
                    // Deselect current grid
                    currentGrid = null;
            gridFrames = [];
                    turnOffGridBtn.style.display = 'none';
                } else {
                    // Select new grid
                    currentGrid = frameCount;
            gridFrames = calculateGridFrames(frameCount);
                    
                    // Add selection to clicked button
                    const button = document.getElementById(`grid-${frameCount}`);
                    if (button) {
                        button.classList.add('selected');
                    }
                    
                    turnOffGridBtn.style.display = 'block';
                }
                
                recomputeGridOccupancy?.();
                requestAnimationFrame(draw);
            }
            
            // Grid event listeners
            gridsToggle?.addEventListener('click', () => {
                const expanded = gridsToggle.getAttribute('aria-expanded') === 'true';
                gridsToggle.setAttribute('aria-expanded', !expanded);
                if (expanded) {
                    gridsPanel.style.maxHeight = '0px';
                } else {
                    gridsPanel.style.maxHeight = '1000px';
                }
            });
            
            // Grid button event listeners
            [2, 4, 6, 9, 12].forEach(count => {
                const button = document.getElementById(`grid-${count}`);
                button?.addEventListener('click', () => setGrid(count));
            });
            
            // Simplified grid controls
            showGuidesChk?.addEventListener('change', () => {
                showGuides = showGuidesChk.checked;
                
                // Recompute occupancy when guides are shown to ensure accurate display
                if (showGuides && currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
                
                requestAnimationFrame(draw);
            });
            
            enableAutoSnapChk?.addEventListener('change', () => {
                enableAutoSnap = enableAutoSnapChk.checked;
            });
            
            arrangeTargetsBtn?.addEventListener('click', () => {
                if (!currentGrid) return;
                const visibleObjects = objects.filter(o => o.visible);
                
                // First recompute occupancy to get current state
                recomputeGridOccupancy();
                
                // Get available (non-occupied) frames
                const availableFrames = gridFrames.filter(frame => !frame.occupied);
                
                if (availableFrames.length === 0) {
                    // Show toast notification that grid is full
                    showToast('Grid is full! No available positions for auto-arrangement.', 'warning');
                    return;
                }
                
                // Only arrange as many objects as we have available positions
                const objectsToArrange = visibleObjects.slice(0, availableFrames.length);
                const skippedObjects = visibleObjects.length - objectsToArrange.length;
                
                // Distribute objects to available positions
                objectsToArrange.forEach((obj, i) => {
                    const frame = availableFrames[i];
                    setObjectCenterPosition(obj, frame.x, frame.y);
                });
                
                // Show feedback about the arrangement
                if (skippedObjects > 0) {
                    showToast(`Arranged ${objectsToArrange.length} objects. ${skippedObjects} objects skipped (grid full).`, 'info');
                } else {
                    showToast(`Successfully arranged ${objectsToArrange.length} objects to grid positions.`, 'success');
                }
                
                recomputeGridOccupancy();
                requestAnimationFrame(draw);
            });
            
            turnOffGridBtn?.addEventListener('click', () => {
                setGrid(null);
            });

            // Simple grid helpers
            function clearGridOccupancy() {
                gridFrames.forEach(f => f.occupied = false);
            }
            
            function recomputeGridOccupancy() {
                clearGridOccupancy();
                // Mark frames as occupied based on object proximity
                objects.forEach(obj => {
                    if (!obj.visible) return;
                    const center = getObjectCenter(obj);
                    const nearest = findNearestGridFrame(center.x, center.y);
                    if (nearest) {
                        const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                        // Use a reasonable threshold for occupancy detection
                        // Objects that are snapped should be very close, but account for small positioning variations
                        if (distance <= 20) { // Reasonable threshold for detecting snapped objects
                            nearest.occupied = true;
                            // Debug: uncomment the line below to see occupancy detection in console
                            // console.log(`Object at (${center.x.toFixed(1)}, ${center.y.toFixed(1)}) occupies grid point at (${nearest.x}, ${nearest.y}), distance: ${distance.toFixed(2)}`);
                        }
                    }
                });
                
                // Force a redraw to update occupancy indicators
                requestAnimationFrame(draw);
            }

            // --- Media Handling ---
            function showProgress() {
                progressContainer.style.display = 'block';
            }
            
            function hideProgress() {
                progressContainer.style.display = 'none';
            }
            
            function updateProgress(current, total) {
                const percentage = Math.round((current / total) * 100);
                progressFill.style.width = percentage + '%';
                progressDetail.textContent = `${current} of ${total} files processed`;
            }
            
            async function handleFiles(files, categoryOverride = 'visualTargets', isAutoLoad = false, sourceFolderName = null) { 
                const mediaFiles = Array.from(files).filter(file => 
                    file.type.startsWith('image/') || 
                    file.type.startsWith('video/') ||
                    file.name.toLowerCase().endsWith('.gif')
                );
                
                if (mediaFiles.length === 0) return;
                
                // Store fullscreen state before loading
                const wasFullscreen = !!document.fullscreenElement;
                
                if (mediaFiles.length > 1) {
                    showProgress();
                    updateProgress(0, mediaFiles.length);
                }
                
                for (let i = 0; i < mediaFiles.length; i++) {
                    const file = mediaFiles[i];
                    
                    await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = e => {
                            if (file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.mp4') || 
                                file.name.toLowerCase().endsWith('.mov') || file.name.toLowerCase().endsWith('.avi') ||
                                file.name.toLowerCase().endsWith('.mkv') || file.name.toLowerCase().endsWith('.webm') ||
                                file.name.toLowerCase().endsWith('.3gp') || file.name.toLowerCase().endsWith('.wmv') ||
                                file.name.toLowerCase().endsWith('.flv') || file.name.toLowerCase().endsWith('.m4v')) {
                                // Handle video files
                                const video = document.createElement('video');
                                video.src = e.target.result;
                                video.dataset.name = file.name;
                                video.loop = true;
                                video.muted = true;
                                video.playsInline = true;
                                video.onloadedmetadata = () => {
                                    addMediaItem(video, categoryOverride, isAutoLoad, sourceFolderName);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                                video.onerror = () => {
                                    console.error('Error loading video:', file.name);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                            } else {
                                // Handle image files (including GIFs)
                                const img = new Image();
                                img.src = e.target.result;
                                img.dataset.name = file.name;
                                img.onload = () => {
                                    addMediaItem(img, categoryOverride, isAutoLoad, sourceFolderName);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                                img.onerror = () => {
                                    console.error('Error loading image:', file.name);
                                    if (mediaFiles.length > 1) {
                                        updateProgress(i + 1, mediaFiles.length);
                                    }
                                    resolve();
                                };
                            }
                        };
                        reader.readAsDataURL(file);
                    });
                    
                    // Small delay to allow UI to update
                    if (mediaFiles.length > 10) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                if (mediaFiles.length > 1) {
                    // Hide progress bar after a short delay
                    setTimeout(hideProgress, 500);
                }
                
                // Restore fullscreen state if it was active before loading
                if (wasFullscreen && !document.fullscreenElement) {
                    try {
                        await document.documentElement.requestFullscreen();
                    } catch (error) {
                        console.log('Could not restore fullscreen after image loading:', error);
                    }
                }
            }
            function addMediaItem(mediaElement, category = 'visualTargets', isAutoLoad = false, sourceFolderName = null) { 
                // Add to specified category with auto-load metadata
                const metadata = isAutoLoad ? {
                    autoLoaded: true,
                    sourceFolderName: sourceFolderName,
                    category: category
                } : {};
                addToMediaLibrary(mediaElement, category, metadata);
            }
            
            function addToMediaLibrary(mediaElement, category, metadata = {}) {
                // Add to memory via abstraction
                MediaLibrary.add(category, mediaElement, metadata);
                
                // Add to UI
                const targetGrid = getGridForCategory(category);
                const emptyState = getEmptyStateForCategory(category);
                
                if (targetGrid && emptyState) {
                    emptyState.style.display = 'none';
                    targetGrid.style.display = 'grid';
                }
                
                createMediaItemElement(mediaElement, category, targetGrid);
                
                // Update accordion height for the category
                updateAccordionHeightForCategory(category);
            }
            
            function getGridForCategory(category) {
                switch(category) {
                    case 'backgrounds': return backgroundsGrid;
                    case 'foregrounds': return foregroundsGrid;
                    case 'visualTargets': return visualTargetsGrid;
                    default: return null;
                }
            }
            
            function getEmptyStateForCategory(category) {
                switch(category) {
                    case 'backgrounds': return backgroundsEmptyState;
                    case 'foregrounds': return foregroundsEmptyState;
                    case 'visualTargets': return visualTargetsEmptyState;
                    default: return null;
                }
            }
            
            function createMediaItemElement(mediaElement, category, targetGrid) {
                const div = document.createElement('div'); 
                div.className = 'media-item relative cursor-pointer'; 
                
                const isVideo = mediaElement.tagName === 'VIDEO';
                const displayElement = document.createElement(isVideo ? 'video' : 'img');
                
                if (isVideo) {
                    displayElement.src = mediaElement.src;
                    displayElement.className = 'absolute top-0 left-0 w-full h-full object-cover';
                    displayElement.muted = true;
                    displayElement.loop = true;
                    displayElement.playsInline = true;
                    displayElement.dataset.name = mediaElement.dataset.name;
                    displayElement.dataset.category = category;
                    
                    // Auto-play video on hover for preview
                    div.addEventListener('mouseenter', () => {
                        displayElement.play().catch(e => console.log('Video play failed:', e));
                    });
                    div.addEventListener('mouseleave', () => {
                        displayElement.pause();
                        displayElement.currentTime = 0;
                    });
                } else {
                    displayElement.src = mediaElement.src;
                    displayElement.className = 'absolute top-0 left-0 w-full h-full object-cover';
                    displayElement.draggable = true;
                    displayElement.dataset.name = mediaElement.dataset.name;
                    displayElement.dataset.category = category;
                }
                
                const overlay = document.createElement('div');
                overlay.className = 'absolute inset-0 bg-black bg-opacity-0 hover:bg-opacity-30 transition-all duration-300 flex items-center justify-center';
                
                // Add video indicator icon for videos
                if (isVideo) {
                    const videoIndicator = document.createElement('div');
                    videoIndicator.className = 'absolute top-2 right-2 bg-black bg-opacity-70 rounded-full p-1';
                    videoIndicator.innerHTML = `
                        <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    `;
                    div.appendChild(videoIndicator);
                }
                
                if (category === 'backgrounds') {
                    overlay.innerHTML = `
                        <div class="text-white opacity-0 hover:opacity-100 transition-opacity duration-300">
                            <svg class="w-6 h-6 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            <p class="text-xs font-medium">Set Background</p>
                        </div>
                    `;
                } else if (category === 'foregrounds') {
                    overlay.innerHTML = `
                        <div class="text-white opacity-0 hover:opacity-100 transition-opacity duration-300">
                            <svg class="w-6 h-6 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                            </svg>
                            <p class="text-xs font-medium">Set Foreground</p>
                        </div>
                    `;
                } else {
                    overlay.innerHTML = `
                        <div class="text-white opacity-0 hover:opacity-100 transition-opacity duration-300">
                            <svg class="w-6 h-6 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <circle cx="12" cy="12" r="10"></circle>
                                <circle cx="12" cy="12" r="6"></circle>
                                <circle cx="12" cy="12" r="2"></circle>
                            </svg>
                            <p class="text-xs font-medium">Add to Canvas</p>
                        </div>
                    `;
                }
                
                div.appendChild(displayElement); 
                // Remove button (red X)
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.setAttribute('aria-label', 'Remove asset');
                removeBtn.className = 'remove-media-btn';
                removeBtn.innerHTML = '&times;';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeMediaItem(mediaElement, category, div);
                });
                div.appendChild(removeBtn);
                div.appendChild(overlay);
                targetGrid.appendChild(div); 
                
                if (!isVideo) {
                    displayElement.addEventListener('dragstart', (e) => { 
                        e.dataTransfer.setData('text/plain', mediaElement.src); 
                        e.dataTransfer.setData('name', mediaElement.dataset.name); 
                        e.dataTransfer.setData('category', category);
                        e.dataTransfer.setData('mediaType', isVideo ? 'video' : 'image');
                    }); 
                }
                
                div.addEventListener('click', () => { 
                    if (category === 'backgrounds') {
                        setBackgroundImage(mediaElement);
                    } else if (category === 'foregrounds') {
                        setForegroundImage(mediaElement);
                    } else {
                        if (isVideo) {
                            addVideoToCanvas(mediaElement.src, mediaElement.dataset.name);
                        } else {
                            addImageToCanvas(mediaElement.src, mediaElement.dataset.name); 
                        }
                        // Removed auto-close behavior - let users manually close drawer after selecting multiple items
                    }
                }); 
                
                // Add context menu for moving between categories
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMediaContextMenu(e.clientX, e.clientY, mediaElement, category, div);
                });
            }

            function removeMediaItem(mediaElement, category, elementDiv) {
                // Remove from data structure via abstraction
                MediaLibrary.remove(category, mediaElement);
                // If currently set as background or foreground, clear it
                if (category === 'backgrounds' && backgroundImage && backgroundImage.img === mediaElement) {
                    backgroundImage = null;
                    // keep button visible but inactive state handled below
                }
                if (category === 'foregrounds' && foregroundImage && foregroundImage.img === mediaElement) {
                    foregroundImage = null;
                    // keep button visible but inactive state handled below
                }
                // Remove DOM element
                if (elementDiv && elementDiv.parentNode) {
                    elementDiv.parentNode.removeChild(elementDiv);
                }
                // Update empty state
                updateEmptyStates();
                // Redraw if needed
                updateBgFgDeleteStates();
                draw();
            }
            
            function setBackgroundImage(img) {
                backgroundImage = { img: img };
                updateBgFgDeleteStates();
                draw();
            }
            
            function setForegroundImage(img) {
                foregroundImage = { img: img };
                updateBgFgDeleteStates();
                draw();
            }

            function updateBgFgDeleteStates() {
                if (backgroundImage) {
                    deleteBgBtn.classList.remove('inactive');
                } else {
                    deleteBgBtn.classList.add('inactive');
                }
                if (foregroundImage) {
                    deleteFgBtn.classList.remove('inactive');
                } else {
                    deleteFgBtn.classList.add('inactive');
                }
            }
            
            function showMediaContextMenu(x, y, img, currentCategory, element) {
                const menu = document.createElement('div');
                menu.className = 'context-menu';
                menu.style.display = 'block';
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                
                const categories = [
                    { key: 'backgrounds', label: 'Move to Backgrounds' },
                    { key: 'foregrounds', label: 'Move to Foregrounds' },
                    { key: 'visualTargets', label: 'Move to Visual Targets' }
                ];
                
                categories.forEach(cat => {
                    if (cat.key !== currentCategory) {
                        const button = document.createElement('button');
                        button.textContent = cat.label;
                        button.addEventListener('click', () => {
                            moveMediaItem(img, currentCategory, cat.key, element);
                            document.body.removeChild(menu);
                        });
                        menu.appendChild(button);
                    }
                });
                
                document.body.appendChild(menu);
                
                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                        document.removeEventListener('click', closeMenu);
                    });
                }, 100);
            }
            
            function moveMediaItem(img, fromCategory, toCategory, element) {
                // Move using abstraction
                MediaLibrary.move(fromCategory, toCategory, img);
                
                // Remove from old grid
                element.parentNode.removeChild(element);
                
                // Add to new grid
                const targetGrid = getGridForCategory(toCategory);
                const emptyState = getEmptyStateForCategory(toCategory);
                
                if (targetGrid && emptyState) {
                    emptyState.style.display = 'none';
                    targetGrid.style.display = 'grid';
                }
                
                createMediaItemElement(img, toCategory, targetGrid);
                
                // Update accordion heights for both categories
                updateAccordionHeightForCategory(fromCategory);
                updateAccordionHeightForCategory(toCategory);
                
                // Update empty states
                updateEmptyStates();
            }
            
            function updateEmptyStates() {
                Object.keys(mediaAssets).forEach(category => {
                    const grid = getGridForCategory(category);
                    const emptyState = getEmptyStateForCategory(category);
                    if (!grid || !emptyState) return;
                    if (MediaLibrary.isEmpty(category)) {
                        emptyState.style.display = 'block';
                        grid.style.display = 'none';
                    } else {
                        emptyState.style.display = 'none';
                        grid.style.display = 'grid';
                    }
                });
            }
            imageUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'visualTargets'));
            folderUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'visualTargets'));

            const bgFolderUpload = document.getElementById('bg-folder-upload');
            if (bgFolderUpload) {
                bgFolderUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'backgrounds'));
            }
            const fgFolderUpload = document.getElementById('fg-folder-upload');
            if (fgFolderUpload) {
                fgFolderUpload.addEventListener('change', (e) => handleFiles(e.target.files, 'foregrounds'));
            }

            // --- Canvas Drag & Drop ---
            function addImageToCanvas(imgSrc, name, x, y) { 
                const img = new Image(); 
                img.src = imgSrc; 
                img.dataset.name = name; 
                img.onload = () => { 
                    const w = 150; 
                    const h = (img.height / img.width) * w; 
                    const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                    const finalX = (x === undefined) ? (canvasWidth / 2) - (w / 2) : x - (w/2); 
                    const finalY = (y === undefined) ? (canvasHeight / 2) - (h / 2) : y - (h/2); 
                    const newObj = new ImageObject(img, finalX, finalY, w, h, getNextZIndex()); 
                    objects.push(newObj); 
                    setSelectedObject(newObj); 
                    updateAnimationTriggerPanel(); 
                    
                    // Recompute grid occupancy after adding new object
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                }; 
            }
            
            function addVideoToCanvas(videoSrc, name, x, y) { 
                const video = document.createElement('video'); 
                video.src = videoSrc; 
                video.dataset.name = name; 
                video.muted = true;
                video.loop = true;
                video.playsInline = true;
                video.onloadedmetadata = () => { 
                    const w = 150; 
                    const h = (video.videoHeight / video.videoWidth) * w; 
                    const { width: canvasWidth, height: canvasHeight } = getCanvasDimensions();
                    const finalX = (x === undefined) ? (canvasWidth / 2) - (w / 2) : x - (w/2); 
                    const finalY = (y === undefined) ? (canvasHeight / 2) - (h / 2) : y - (h/2); 
                    const newObj = new VideoObject(video, finalX, finalY, w, h, getNextZIndex()); 
                    objects.push(newObj); 
                    setSelectedObject(newObj); 
                    updateAnimationTriggerPanel(); 
                    video.play().catch(e => console.log('Video autoplay failed:', e));
                    ensureRenderLoop();
                    
                    // Recompute grid occupancy after adding new video object
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                }; 
            }
            canvas.addEventListener('dragover', (e) => e.preventDefault());
            canvas.addEventListener('drop', (e) => { 
                e.preventDefault(); 
                const mediaSrc = e.dataTransfer.getData('text/plain'); 
                const name = e.dataTransfer.getData('name'); 
                const mediaType = e.dataTransfer.getData('mediaType') || 'image';
                if (!mediaSrc) return; 
                const rect = canvas.getBoundingClientRect(); 
                const x = e.clientX - rect.left; 
                const y = e.clientY - rect.top; 
                if (mediaType === 'video') {
                    addVideoToCanvas(mediaSrc, name, x, y);
                } else {
                    addImageToCanvas(mediaSrc, name, x, y); 
                }
            });

            // --- Tool Selection & Mouse Events ---
            function setActiveTool(tool) { currentTool = tool; document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active')); const activeBtn = document.getElementById(`${tool}-tool`); if(activeBtn) activeBtn.classList.add('active'); }

            // --- Animation Helper Mapping ---
            const friendlyToInternal = {
                'gentle-shake': 'gentle-shake', // Micro Jiggle
                'pendum': 'pendum',             // Soft Sway
                'circular': 'circular'          // Orbit Loop
            };

            function applyAnimationSettings(obj) {
                if(!obj) return;
                // animationType is now set directly by button clicks, not from dropdown
                obj.animationDuration = parseFloat(animationDuration.value) || 1;
                obj.animationCycles = parseInt(animationCycles.value) || 1;
                obj.animationIntensity = parseInt(animationIntensity.value) || 5;
                obj.animationEasing = 'ease-in-out';  // Always use smooth easing
                obj.animationIteration = 'infinite';  // Always loop
                // NOTE: Do NOT start the animation here. Only store settings.
                // Animation starts when user presses the Start Motion button or numeric trigger.
            }

            function updateAnimationUIVisibility() {
                const selectedAnimation = document.querySelector('.animation-type-btn.active');
                const animationType = selectedAnimation ? selectedAnimation.dataset.animation : '';
                if(animationType) {
                    animationSettings.classList.remove('hidden');
                } else {
                    animationSettings.classList.add('hidden');
                }
            }

            // Animation type button handlers
            const animationButtons = document.querySelectorAll('.animation-type-btn');
            animationButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active from all buttons
                    animationButtons.forEach(b => b.classList.remove('active'));
                    // Add active to clicked button
                    btn.classList.add('active');
                    
                    if(selectedObject) {
                        selectedObject.animationType = btn.dataset.animation;
                        applyAnimationSettings(selectedObject);
                        updateAnimationControlButton();
                        updateAnimationTriggerPanel();
                    }
                    updateAnimationUIVisibility();
                });
            });

            // Legacy support - remove old dropdown listener
            if(animationSelect) {
                // Dropdown replaced with buttons - this code can be removed
            }

            [animationDuration, animationCycles, animationIntensity].forEach(ctrl => {
                if(ctrl) ctrl.addEventListener('input', () => {
                    if(ctrl === animationDuration) {
                        const val = parseFloat(animationDuration.value);
                        durationValue.textContent = val <= 0.7 ? 'Fast' : val >= 2 ? 'Slow' : 'Medium';
                    }
                    if(ctrl === animationCycles) {
                        const val = parseInt(animationCycles.value) || 1;
                        cyclesValue.textContent = val + ' cycle' + (val === 1 ? '' : 's');
                    }
                    if(ctrl === animationIntensity) {
                        const val = parseInt(animationIntensity.value);
                        intensityValue.textContent = val <= 3 ? 'Small' : val >= 7 ? 'Large' : 'Medium';
                    }
                    if(selectedObject) {
                        applyAnimationSettings(selectedObject);
                        updateAnimationControlButton();
                        updateAnimationTriggerPanel();
                    }
                });
            });

            function updateAnimationControlButton() {
                if(!selectedObject || !selectedObject.animationType) {
                    if(animationControlBtn) {
                        animationControlBtn.style.display = 'none';
                    }
                    return;
                }
                
                if(animationControlBtn) {
                    animationControlBtn.style.display = 'block';
                    const isRunning = !!selectedObject.isAnimating;
                    
                    if(isRunning) {
                        playIcon.classList.add('hidden');
                        stopIcon.classList.remove('hidden');
                        controlText.textContent = 'Stop Motion';
                    } else {
                        playIcon.classList.remove('hidden');
                        stopIcon.classList.add('hidden');
                        controlText.textContent = 'Start Motion';
                    }
                }
            }

            if(animationControlBtn) {
                animationControlBtn.addEventListener('click', () => {
                    if(!selectedObject) return;
                    const isRunning = !!selectedObject.isAnimating;
                    if(isRunning) {
                        selectedObject.isAnimating = false;
                        selectedObject.animationStartTime = 0;
                        selectedObject.cycleCount = 0;
                    } else {
                        // Ensure settings exist then start
                        if(!selectedObject.animationType) applyAnimationSettings(selectedObject);
                        selectedObject.isAnimating = true;
                        selectedObject.animationStartTime = performance.now();
                        selectedObject.cycleCount = 0;
                        ensureRenderLoop();
                    }
                    updateAnimationControlButton();
                    draw(); // Refresh display
                });
            }
            function addCanvasObject(type) { 
                const { width: cWidth, height: cHeight } = getCanvasDimensions();
                const centerX = cWidth / 2; 
                const centerY = cHeight / 2; 
                let newObj; 
                
                if(type === 'text') { 
                    // Add slight offset for text objects too
                    const textX = centerX + shapeOffsetX;
                    const textY = centerY + shapeOffsetY;
                    newObj = new TextObject("Text", textX, textY, getNextZIndex()); 
                } else { 
                    // Get next harmonious color
                    const color = getNextHarmoniousColor();
                    
                    // Calculate offset position
                    const shapeX = centerX + shapeOffsetX;
                    const shapeY = centerY + shapeOffsetY;
                    
                    newObj = new ShapeObject(type, shapeX, shapeY, getNextZIndex(), color); 
                } 
                
                // Update offset for next object (spiral pattern)
                const offsetAmount = 40;
                const angle = objects.length * 0.5; // Spiral angle
                shapeOffsetX = Math.cos(angle) * offsetAmount * (1 + objects.length * 0.2);
                shapeOffsetY = Math.sin(angle) * offsetAmount * (1 + objects.length * 0.2);
                
                // Keep offset within reasonable bounds
                const { width: cWidth2, height: cHeight2 } = getCanvasDimensions();
                const maxOffset = Math.min(cWidth2, cHeight2) / 3;
                shapeOffsetX = Math.max(-maxOffset, Math.min(maxOffset, shapeOffsetX));
                shapeOffsetY = Math.max(-maxOffset, Math.min(maxOffset, shapeOffsetY));
                
                objects.push(newObj); 
                setActiveTool('select'); 
                setSelectedObject(newObj); 
                updateAnimationTriggerPanel(); 
                
                // Recompute grid occupancy after adding new canvas object
                if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
            }
            selectTool.addEventListener('click', () => setActiveTool('select'));
            textTool.addEventListener('click', () => addCanvasObject('text'));
            rectTool.addEventListener('click', () => addCanvasObject('rect'));
            squareTool.addEventListener('click', () => addCanvasObject('square'));
            circleTool.addEventListener('click', () => addCanvasObject('circle'));
            triangleTool.addEventListener('click', () => addCanvasObject('triangle'));
            starTool.addEventListener('click', () => addCanvasObject('star'));
            octagonTool.addEventListener('click', () => addCanvasObject('octagon'));
            function getMousePos(e) { const rect = canvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; }
            function getObjectAt(x, y) { const sorted = [...objects].sort((a, b) => b.zIndex - a.zIndex); for (const obj of sorted) { if (obj.visible && obj.isPointInside(x, y)) { return obj; } } return null; }
            // Upgrade to Pointer Events (covers mouse + touch + pen)
            canvas.addEventListener('pointerdown', (e) => { 
                canvas.setPointerCapture(e.pointerId);
                const { x, y } = getMousePos(e); 
                activePointers.set(e.pointerId, { x, y });
                // Long press detection for context menu (only primary & touch/pen)
                if (e.isPrimary) {
                    longPressStart = { x: e.clientX, y: e.clientY };
                    clearTimeout(longPressTimer);
                    longPressTimer = setTimeout(() => {
                        if (!isDragging && !isResizing) {
                            const obj = getObjectAt(x, y);
                            if (obj) { setSelectedObject(obj); showContextMenu(longPressStart.x, longPressStart.y); }
                        }
                    }, LONG_PRESS_MS);
                }
                if (e.button === 2) { const obj = getObjectAt(x, y); if (obj) { setSelectedObject(obj); e.preventDefault(); showContextMenu(e.clientX, e.clientY); } return; }
                hideContextMenu(); 
                // Allow dragging even when not explicitly in select tool for touch convenience
                const allowDirectDrag = currentTool === 'select' || e.pointerType !== 'mouse';
                if (!allowDirectDrag) return; 
                isDragging = false; isResizing = false; 
                const handle = getResizeHandleAt(x, y); 
                if (handle) { 
                    isResizing = true; resizeHandle = handle.position; setSelectedObject(handle.object); 
                    selectedObject.original = { x: selectedObject.x, y: selectedObject.y, width: selectedObject.width, height: selectedObject.height, size: selectedObject.size }; 
                } else { 
                    const obj = getObjectAt(x, y); setSelectedObject(obj); 
                    if (obj) { 
                        isDragging = true; 
                        dragStartX = x - obj.x; 
                        dragStartY = y - obj.y; 
                        
                        // Show grid temporarily during drag if a grid is enabled but hidden
                        if (currentGrid && !showGuides) {
                            showGuides = true;
                            tempGridVisibility = true; // Flag to remember we temporarily enabled it
                            if (showGuidesChk) showGuidesChk.checked = true;
                        }
                    } 
                } 
                startPinchIfPossible();
            });
            canvas.addEventListener('pointermove', (e) => { 
                const { x, y } = getMousePos(e); 
                if (activePointers.has(e.pointerId)) { activePointers.set(e.pointerId, { x, y }); }
                if (activePointers.size === 2 && pinchStartInfo && selectedObject) { 
                    // Pinch to uniformly scale (text -> size; shapes/images -> width/height)
                    const pts = Array.from(activePointers.values()); 
                    const dist = pointerDistance(pts[0], pts[1]); 
                    const scale = Math.max(0.2, dist / pinchStartInfo.distance); 
                    if (selectedObject.type === 'text') { 
                        selectedObject.size = pinchStartInfo.objOrig.size * scale; 
                        selectedObject.updateMetrics(); 
                        // Keep center consistent
                        selectedObject.x = pinchStartInfo.objOrig.x + (pinchStartInfo.objOrig.width - selectedObject.width) / 2; 
                        selectedObject.y = pinchStartInfo.objOrig.y + (pinchStartInfo.objOrig.height - selectedObject.height) / 2; 
                    } else { 
                        selectedObject.width = pinchStartInfo.objOrig.width * scale; 
                        selectedObject.height = pinchStartInfo.objOrig.height * scale; 
                    }
                    
                    // Recompute grid occupancy after pinch scaling
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                    
                    ensureRenderLoop();
                    draw(); 
                    return; 
                }
                if (isResizing) { resizeObject(x, y); return; } 
                if (isDragging && selectedObject) { 
                    // First, move object to follow mouse normally
                    const newX = x - dragStartX; 
                    const newY = y - dragStartY;
                    selectedObject.x = newX;
                    selectedObject.y = newY;
                    
                    // Then check if center should snap to grid
                    const center = getObjectCenter(selectedObject);
                    const snappedCenter = snapToGrid(center.x, center.y, e.shiftKey);
                    
                    // If snapping occurred, adjust object position so center is at snap point
                    if (snappedCenter.x !== center.x || snappedCenter.y !== center.y) {
                        setObjectCenterPosition(selectedObject, snappedCenter.x, snappedCenter.y);
                    }
                    
                    draw(); 
                    return; 
                } 
                const handle = getResizeHandleAt(x, y); 
                if (handle) { canvas.style.cursor = handle.cursor; } else if (getObjectAt(x, y)) { canvas.style.cursor = 'move'; } else { canvas.style.cursor = 'default'; }
            });
            function cancelLongPress() { clearTimeout(longPressTimer); longPressTimer = null; }
            canvas.addEventListener('pointerup', (e) => { 
                cancelLongPress();
                
                // Final snap when releasing a dragged object
                if (isDragging && selectedObject && currentGrid && !e.shiftKey) {
                    const center = getObjectCenter(selectedObject);
                    const nearest = findNearestGridFrame(center.x, center.y);
                    if (nearest) {
                        const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                        if (distance <= snapStrength) {
                            // Use smooth animation for final snap - animate center to grid point
                            const currentCenter = getObjectCenter(selectedObject);
                            animateSnapToGrid(selectedObject, nearest.x, nearest.y, currentCenter.x, currentCenter.y);
                        }
                    }
                }
                
                if (isResizing && selectedObject) { 
                    selectedObject.initialX = selectedObject.x; 
                    selectedObject.initialY = selectedObject.y; 
                    // Recompute grid occupancy after resize is complete
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                }
                
                // Recompute grid occupancy after any dragging ends (in case object moved)
                if (isDragging && currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
                
                // Hide grid if it was temporarily shown during drag
                if (isDragging && tempGridVisibility) {
                    showGuides = false;
                    tempGridVisibility = false;
                    if (showGuidesChk) showGuidesChk.checked = false;
                    requestAnimationFrame(draw); // Force redraw to hide grid
                }
                
                activePointers.delete(e.pointerId); 
                if (activePointers.size < 2) pinchStartInfo = null; 
                isDragging = false; isResizing = false; resizeHandle = null; 
                // Double-tap detection for quick select/deselect
                if (e.pointerType !== 'mouse') {
                    const now = performance.now();
                    const { x, y } = getMousePos(e);
                    if (now - lastTapTime < DOUBLE_TAP_MS && lastTapPos && Math.hypot(lastTapPos.x - x, lastTapPos.y - y) < DOUBLE_TAP_DIST) {
                        const obj = getObjectAt(x, y);
                        if (obj) {
                            if (selectedObject && selectedObject.id === obj.id) {
                                // Deselect
                                setSelectedObject(null);
                            } else {
                                setSelectedObject(obj);
                            }
                        }
                        lastTapTime = 0; lastTapPos = null;
                    } else {
                        lastTapTime = now; lastTapPos = { x, y };
                    }
                }
            });
            canvas.addEventListener('pointercancel', (e) => { activePointers.delete(e.pointerId); pinchStartInfo = null; cancelLongPress(); });
            canvas.addEventListener('pointerleave', (e) => { if (!canvas.hasPointerCapture?.(e.pointerId)) { activePointers.delete(e.pointerId); } });
            
            // --- Properties Panel Listeners ---
            textContentInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'text') {
                    // Store current center position before changing text
                    const currentCenterX = selectedObject.x + selectedObject.width / 2;
                    const currentCenterY = selectedObject.y + selectedObject.height / 2;
                    
                    selectedObject.text = e.target.value; 
                    selectedObject.isResizing = true; 
                    selectedObject.updateMetrics(); 
                    selectedObject.isResizing = false; 
                    
                    // Restore center position after text change
                    selectedObject.x = currentCenterX - selectedObject.width / 2;
                    selectedObject.y = currentCenterY - selectedObject.height / 2;
                    
                    // Recompute grid occupancy after text content change
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                    
                    draw(); 
                    updateLayerList(); 
                } 
            });
            textColorInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'text') { 
                    selectedObject.color = e.target.value; 
                    draw(); 
                } 
            });
            textSizeInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'text') {
                    // Store current center position before changing size
                    const currentCenterX = selectedObject.x + selectedObject.width / 2;
                    const currentCenterY = selectedObject.y + selectedObject.height / 2;
                    
                    selectedObject.size = parseInt(e.target.value); 
                    selectedObject.isResizing = true; 
                    selectedObject.updateMetrics(); 
                    selectedObject.isResizing = false; 
                    
                    // Restore center position after size change
                    selectedObject.x = currentCenterX - selectedObject.width / 2;
                    selectedObject.y = currentCenterY - selectedObject.height / 2;
                    
                    // Recompute grid occupancy after size change
                    if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                        recomputeGridOccupancy();
                    }
                    
                    draw(); 
                } 
            });
            // Style toggles
            textBoldToggle.addEventListener('click', () => {
                if (selectedObject?.type === 'text') {
                    const isBold = (selectedObject.fontWeight || 400) >= 600;
                    selectedObject.fontWeight = isBold ? 400 : 700;
                    textBoldToggle.classList.toggle('active', !isBold);
                    textBoldToggle.setAttribute('aria-pressed', (!isBold).toString());
                    selectedObject.updateMetrics();
                    draw();
                } else {
                    textBoldToggle.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => textBoldToggle.style.animation = '', 300);
                }
            });
            textItalicToggle.addEventListener('click', () => {
                if (selectedObject?.type === 'text') {
                    const isItalic = (selectedObject.fontStyle || 'normal') === 'italic';
                    selectedObject.fontStyle = isItalic ? 'normal' : 'italic';
                    textItalicToggle.classList.toggle('active', !isItalic);
                    textItalicToggle.setAttribute('aria-pressed', (!isItalic).toString());
                    selectedObject.updateMetrics();
                    draw();
                } else {
                    textItalicToggle.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => textItalicToggle.style.animation = '', 300);
                }
            });
            shapeColorInput.addEventListener('input', (e) => { 
                if(selectedObject?.type === 'shape') { 
                    selectedObject.color = e.target.value; 
                    draw(); 
                } 
            });
            
            // Flip functionality
            flipHorizontalBtn.addEventListener('click', () => {
                if(selectedObject?.type === 'image') {
                    selectedObject.flipHorizontal = !selectedObject.flipHorizontal;
                    flipHorizontalBtn.classList.toggle('active', selectedObject.flipHorizontal);
                    draw();
                } else {
                    // Show feedback if no image selected
                    flipHorizontalBtn.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => flipHorizontalBtn.style.animation = '', 300);
                }
            });
            
            flipVerticalBtn.addEventListener('click', () => {
                if(selectedObject?.type === 'image') {
                    selectedObject.flipVertical = !selectedObject.flipVertical;
                    flipVerticalBtn.classList.toggle('active', selectedObject.flipVertical);
                    draw();
                } else {
                    // Show feedback if no image selected
                    flipVerticalBtn.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => flipVerticalBtn.style.animation = '', 300);
                }
            });

            // Rotate 90 degrees functionality
            rotate90Btn.addEventListener('click', () => {
                if(selectedObject && selectedObject.type !== 'text') {
                    // Initialize rotation if it doesn't exist
                    if (!selectedObject.rotation) {
                        selectedObject.rotation = 0;
                    }
                    // Add 90 degrees (converted to radians)
                    selectedObject.rotation += (90 * Math.PI) / 180;
                    // Keep rotation between 0-2π radians
                    if (selectedObject.rotation >= 2 * Math.PI) {
                        selectedObject.rotation -= 2 * Math.PI;
                    }
                    draw();
                } else {
                    // Show feedback if no object selected
                    rotate90Btn.style.animation = 'shake 0.3s ease-in-out';
                    setTimeout(() => rotate90Btn.style.animation = '', 300);
                }
            });

            // --- Other functions (BG/FG controls, Resizing, Animation, etc.) ---
            function moveObject(objectId, direction) { 
                const sorted = [...objects].sort((a, b) => a.zIndex - b.zIndex); 
                const currentIndex = sorted.findIndex(o => o.id === objectId); 
                let swapIndex; 
                if (direction === 'up') { 
                    swapIndex = currentIndex + 1; 
                } else { 
                    swapIndex = currentIndex - 1; 
                } 
                if (swapIndex >= 0 && swapIndex < sorted.length) { 
                    let tempZ = sorted[currentIndex].zIndex; 
                    sorted[currentIndex].zIndex = sorted[swapIndex].zIndex; 
                    sorted[swapIndex].zIndex = tempZ; 
                } 
                draw(); 
                updateLayerList(); 
            }
            
            function getNextZIndex() { 
                const maxZ = objects.reduce((max, obj) => (obj.zIndex > max ? obj.zIndex : max), 0); 
                return maxZ + 1; 
            }
            
            // Background color handling
            bgColorSlider.addEventListener('input', (e) => { 
                backgroundColor = e.target.value; 
                backgroundImage = null; 
                deleteBgBtn.classList.add('hidden'); 
                bgImageInput.value = ''; 
                
                // Update selected state on preset buttons
                presetColorBtns.forEach(btn => {
                    if (btn.dataset.color === e.target.value) {
                        btn.classList.add('selected');
                    } else {
                        btn.classList.remove('selected');
                    }
                });
                
                draw(); 
            });
            
            presetColorBtns.forEach(btn => { 
                btn.addEventListener('click', (e) => { 
                    // Remove selected class from all buttons
                    presetColorBtns.forEach(b => b.classList.remove('selected'));
                    // Add selected class to clicked button
                    e.target.classList.add('selected');
                    
                    backgroundColor = e.target.dataset.color; 
                    bgColorSlider.value = backgroundColor; 
                    backgroundImage = null; 
                    deleteBgBtn.classList.add('hidden'); 
                    bgImageInput.value = ''; 
                    draw(); 
                }); 
            });
            bgImageInput.addEventListener('change', (e) => { 
                const file = e.target.files[0]; 
                if (file) { 
                    // Store fullscreen state before loading
                    const wasFullscreen = !!document.fullscreenElement;
                    
                    const reader = new FileReader(); 
                    reader.onload = (event) => { 
                        const img = new Image(); 
                        img.onload = async () => { 
                            img.dataset.name = file.name;
                            backgroundImage = { img: img, name: 'Background Image' }; 
                            updateBgFgDeleteStates(); 
                            // Add to media library
                            addToMediaLibrary(img, 'backgrounds');
                            draw(); 
                            
                            // Restore fullscreen state if it was active before loading
                            if (wasFullscreen && !document.fullscreenElement) {
                                try {
                                    await document.documentElement.requestFullscreen();
                                } catch (error) {
                                    console.log('Could not restore fullscreen after background image loading:', error);
                                }
                            }
                        }; 
                        img.src = event.target.result; 
                    }; 
                    reader.readAsDataURL(file); 
                } 
            });
            
            deleteBgBtn.addEventListener('click', () => { 
                if (!backgroundImage) return; 
                backgroundImage = null; 
                bgImageInput.value = ''; 
                updateBgFgDeleteStates();
                draw(); 
            });
            
            fgImageInput.addEventListener('change', (e) => { 
                const file = e.target.files[0]; 
                if (file) { 
                    // Store fullscreen state before loading
                    const wasFullscreen = !!document.fullscreenElement;
                    
                    const reader = new FileReader(); 
                    reader.onload = (event) => { 
                        const img = new Image(); 
                        img.onload = async () => { 
                            img.dataset.name = file.name;
                            foregroundImage = { img: img, name: 'Foreground Image' }; 
                            updateBgFgDeleteStates(); 
                            // Add to media library
                            addToMediaLibrary(img, 'foregrounds');
                            draw(); 
                            
                            // Restore fullscreen state if it was active before loading
                            if (wasFullscreen && !document.fullscreenElement) {
                                try {
                                    await document.documentElement.requestFullscreen();
                                } catch (error) {
                                    console.log('Could not restore fullscreen after foreground image loading:', error);
                                }
                            }
                        }; 
                        img.src = event.target.result; 
                    }; 
                    reader.readAsDataURL(file); 
                } 
            });
            
            deleteFgBtn.addEventListener('click', () => { 
                if (!foregroundImage) return; 
                foregroundImage = null; 
                fgImageInput.value = ''; 
                updateBgFgDeleteStates();
                draw(); 
            });
            
            // --- Resize Handle Functions ---
            function getResizeHandles(obj) { 
                const s = handleSize; 
                return [ 
                    { position: 'tl', x: obj.x - s/2, y: obj.y - s/2, size: s, cursor: 'nwse-resize' }, 
                    { position: 'tr', x: obj.x + obj.width - s/2, y: obj.y - s/2, size: s, cursor: 'nesw-resize' }, 
                    { position: 'bl', x: obj.x - s/2, y: obj.y + obj.height - s/2, size: s, cursor: 'nesw-resize' }, 
                    { position: 'br', x: obj.x + obj.width - s/2, y: obj.y + obj.height - s/2, size: s, cursor: 'nwse-resize' }, 
                ]; 
            }
            function pointerDistance(p1, p2) { const dx = p1.x - p2.x; const dy = p1.y - p2.y; return Math.hypot(dx, dy); }
            function startPinchIfPossible() { 
                if (activePointers.size === 2 && selectedObject) { 
                    const pts = Array.from(activePointers.values()); 
                    pinchStartInfo = { distance: pointerDistance(pts[0], pts[1]), objOrig: { x: selectedObject.x, y: selectedObject.y, width: selectedObject.width, height: selectedObject.height, size: selectedObject.size } }; 
                } 
            }
            
            function getResizeHandleAt(x, y) { 
                if (!selectedObject) return null; 
                for (const handle of getResizeHandles(selectedObject)) { 
                    if (x >= handle.x && x <= handle.x + handle.size && y >= handle.y && y <= handle.y + handle.size) { 
                        return { object: selectedObject, position: handle.position, cursor: handle.cursor }; 
                    } 
                } 
                return null; 
            }
            
            function resizeObject(mouseX, mouseY) { 
                if (!selectedObject || !selectedObject.original) return; 
                const obj = selectedObject; 
                const orig = obj.original; 
                
                // Check if object is pinned to a grid point
                let pinnedGridPoint = null;
                if (currentGrid && gridFrames.length > 0) {
                    const center = getObjectCenter(obj);
                    const nearest = findNearestGridFrame(center.x, center.y);
                    if (nearest) {
                        const distance = Math.sqrt((center.x - nearest.x) ** 2 + (center.y - nearest.y) ** 2);
                        if (distance <= 20) { // Use same threshold as occupancy detection
                            pinnedGridPoint = nearest;
                        }
                    }
                }
                
                if (obj.type === 'text') { 
                    // Store the original center position (from when resize started or grid point if pinned)
                    let centerX, centerY;
                    if (pinnedGridPoint) {
                        centerX = pinnedGridPoint.x;
                        centerY = pinnedGridPoint.y;
                    } else {
                        centerX = orig.x + orig.width / 2; 
                        centerY = orig.y + orig.height / 2;
                    }
                    
                    // Calculate scale based on the resize handle being dragged
                    let scale = 1;
                    switch (resizeHandle) {
                        case 'br': // Bottom-right handle
                            const deltaX = mouseX - (orig.x + orig.width);
                            const deltaY = mouseY - (orig.y + orig.height);
                            const avgDelta = (deltaX + deltaY) / 2;
                            scale = Math.max(0.2, 1 + avgDelta / 100); // Adjust sensitivity
                            break;
                        case 'tl': // Top-left handle  
                            const deltaX2 = orig.x - mouseX;
                            const deltaY2 = orig.y - mouseY;
                            const avgDelta2 = (deltaX2 + deltaY2) / 2;
                            scale = Math.max(0.2, 1 + avgDelta2 / 100);
                            break;
                        default:
                            // For other handles, use distance from center
                            const dist = Math.hypot(mouseX - centerX, mouseY - centerY);
                            const baseDist = Math.max(orig.width, orig.height) / 2;
                            scale = Math.max(0.2, dist / baseDist);
                    }
                    
                    obj.size = Math.max(10, orig.size * scale); 
                    obj.isResizing = true; 
                    obj.updateMetrics(); 
                    obj.isResizing = false;
                    
                    // Keep text centered at pinned grid point or original position
                    obj.x = centerX - obj.width / 2; 
                    obj.y = centerY - obj.height / 2; 
                } else { 
                    const aspectRatio = orig.width / orig.height; 
                    let newWidth, newHeight; 
                    
                    if (pinnedGridPoint) {
                        // For grid-pinned objects, resize from center
                        const originalCenterX = pinnedGridPoint.x;
                        const originalCenterY = pinnedGridPoint.y;
                        
                        // Calculate distance from mouse to center to determine scale
                        const mouseDist = Math.hypot(mouseX - originalCenterX, mouseY - originalCenterY);
                        const originalDist = Math.hypot(orig.width / 2, orig.height / 2);
                        const scale = Math.max(0.2, mouseDist / originalDist);
                        
                        newWidth = Math.max(10, orig.width * scale);
                        newHeight = Math.max(10, orig.height * scale);
                        
                        // Position object so its center stays at the grid point
                        obj.x = originalCenterX - newWidth / 2;
                        obj.y = originalCenterY - newHeight / 2;
                    } else {
                        // Original corner-based resizing for non-pinned objects
                        switch (resizeHandle) { 
                            case 'br': 
                                newWidth = mouseX - orig.x; 
                                newHeight = mouseY - orig.y; 
                                obj.x = orig.x; 
                                obj.y = orig.y; 
                                break; 
                            case 'bl': 
                                newWidth = (orig.x + orig.width) - mouseX; 
                                newHeight = mouseY - orig.y; 
                                obj.x = mouseX; 
                                obj.y = orig.y; 
                                break; 
                            case 'tr': 
                                newWidth = mouseX - orig.x; 
                                newHeight = (orig.y + orig.height) - mouseY; 
                                obj.x = orig.x; 
                                obj.y = (orig.y + orig.height) - newHeight; 
                                break; 
                            case 'tl': 
                                newWidth = (orig.x + orig.width) - mouseX; 
                                newHeight = (orig.y + orig.height) - mouseY; 
                                obj.x = mouseX; 
                                obj.y = (orig.y + orig.height) - newHeight; 
                                break; 
                        }
                    }
                    
                    // For rectangles, allow deformation but snap to square when close
                    if (obj.shapeType === 'rect') {
                        const snapThreshold = 20; // Snap when within 20 pixels
                        const sizeDifference = Math.abs(newWidth - newHeight);
                        
                        if (sizeDifference < snapThreshold) {
                            // Snap to square - use the average size
                            const avgSize = (newWidth + newHeight) / 2;
                            newWidth = avgSize;
                            newHeight = avgSize;
                        }
                    } else if (obj.shapeType === 'square') {
                        // Always enforce square aspect ratio
                        const avgSize = Math.max(10, Math.min(Math.max(newWidth, 10), Math.max(newHeight, 10)));
                        newWidth = avgSize;
                        newHeight = avgSize;
                    } else {
                        // For other shapes (circles, triangles), maintain aspect ratio
                        newHeight = newWidth / aspectRatio;
                    }
                    
                    obj.width = newWidth > 10 ? newWidth : 10; 
                    obj.height = newHeight > 10 ? newHeight : 10; 
                } 
                
                // Recompute grid occupancy after resize since object center may have changed
                if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
                
                draw(); 
            }
            
            // --- Context Menu Functions ---
            function showContextMenu(x, y) { 
                // Determine if selection supports animation (text, shape, image only)
                const animateBtn = document.getElementById('ctx-animate');
                const animatableTypes = ['text','shape','image'];
                const canAnimate = selectedObject && animatableTypes.includes(selectedObject.type);
                animateBtn.style.display = canAnimate ? 'flex' : 'none';
                contextMenu.style.display = 'block'; 
                contextMenu.style.left = `${x}px`; 
                contextMenu.style.top = `${y}px`; 
            }
            
            function hideContextMenu() { 
                contextMenu.style.display = 'none'; 
            }
            
            function deleteObject(obj) { 
                objects = objects.filter(o => o.id !== obj.id); 
                setSelectedObject(null); 
                hideContextMenu(); 
                updateAnimationTriggerPanel(); // Update animation panel when object is deleted
                
                // Recompute grid occupancy after object deletion
                if (currentGrid && typeof recomputeGridOccupancy === 'function') {
                    recomputeGridOccupancy();
                }
            }
            
            // --- Event Listeners ---
            document.addEventListener('click', hideContextMenu);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            
            document.getElementById('ctx-delete').addEventListener('click', () => { 
                if (selectedObject) deleteObject(selectedObject); 
            });
            
            document.getElementById('ctx-bring-to-front').addEventListener('click', () => { 
                if(selectedObject) { 
                    selectedObject.zIndex = getNextZIndex(); 
                    draw(); 
                    updateLayerList(); 
                }
            });
            
            document.getElementById('ctx-send-to-back').addEventListener('click', () => { 
                if(selectedObject) { 
                    const minZ = Math.min(...objects.map(o => o.zIndex).filter(z => z > 0)); 
                    selectedObject.zIndex = minZ - 1; 
                    draw(); 
                    updateLayerList(); 
                }
            });
            
            // Legacy context menu animate removed in favor of drawer controls.
            
            animationDuration.addEventListener('input', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                if (selectedObject) {
                    selectedObject.animationDuration = parseFloat(e.target.value);
                    durationValue.textContent = parseFloat(e.target.value).toFixed(1) + 's';
                }
            });

            // Font selection for text objects
        textFontSelect.addEventListener('change', (e) => {
                e.stopPropagation();
                if (selectedObject && selectedObject.type === 'text') {
                    const val = e.target.value;
                    let ff = 'Luciole, "Atkinson Hyperlegible", Inter, system-ui, sans-serif';
                    if (val === 'atkinson') ff = '"Atkinson Hyperlegible", Luciole, Inter, system-ui, sans-serif';
            else if (val === 'andika') ff = 'Andika, Inter, system-ui, sans-serif';
                    else if (val === 'serif') ff = '"Noto Serif", Georgia, serif';
                    else if (val === 'inter') ff = 'Inter, system-ui, sans-serif';
                    else if (val === 'system') ff = 'system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
                    selectedObject.fontFamily = ff;
                    // Recalculate metrics and redraw
                    selectedObject.updateMetrics();
                    draw();
                }
            });
            
            animationIntensity.addEventListener('input', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                if (selectedObject) {
                    selectedObject.animationIntensity = parseInt(e.target.value);
                    intensityValue.textContent = e.target.value;
                }
            });
            
            // Preview button removed in simplified UI; retained logic not needed.
            
            // Keyboard shortcuts for animation triggers
            document.addEventListener('keydown', (e) => {
                // Only trigger if no input is focused
                if (document.activeElement.tagName === 'INPUT' || 
                    document.activeElement.tagName === 'TEXTAREA' || 
                    document.activeElement.tagName === 'SELECT') {
                    return;
                }
                
                const keyNum = parseInt(e.key);
                if (keyNum >= 1 && keyNum <= 9) {
                    const animatedObjs = objects.filter(obj => obj.animationType);
                    const target = animatedObjs[keyNum - 1];
                    if (target) {
                        e.preventDefault();
                        triggerAnimation(target);
                        if(target === selectedObject) updateAnimationControlButton();
                    }
                }
            });
            
            // --- Keyboard Events ---
            window.addEventListener('keydown', (e) => { 
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; 

                // Drawer Toggles
                if (e.ctrlKey && e.key === 'l') {
                    e.preventDefault();
                    toggleControlsBtn.click();
                }
                if (e.ctrlKey && e.key === 'm') {
                    e.preventDefault();
                    toggleLibraryBtn.click();
                }

                // Grid shortcuts
                if (e.key === 'g' && !e.ctrlKey && !e.altKey) {
                    e.preventDefault();
                    // Toggle guide visibility
                    showGuidesChk.checked = !showGuidesChk.checked;
                    showGuides = showGuidesChk.checked;
                    requestAnimationFrame(draw);
                }
                
                // Grid layout shortcuts (Ctrl + 2/4/6/9/1 for 2/4/6/9/12)
                if (e.ctrlKey && ['2', '4', '6', '9', '1'].includes(e.key)) {
                    e.preventDefault();
                    let gridCount;
                    switch(e.key) {
                        case '2': gridCount = 2; break;
                        case '4': gridCount = 4; break;
                        case '6': gridCount = 6; break;
                        case '9': gridCount = 9; break;
                        case '1': gridCount = 12; break; // Ctrl+1 for 12-grid
                    }
                    setGrid(gridCount);
                }
                
                // Arrange targets (Ctrl+Shift+G)
                if (e.ctrlKey && e.shiftKey && e.key === 'G') {
                    e.preventDefault();
                    if (currentGrid && arrangeTargetsBtn) {
                        arrangeTargetsBtn.click();
                    }
                }

                if (e.key === 'v') setActiveTool('select'); 
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedObject) { 
                    deleteObject(selectedObject); 
                } 
            });

            // --- Data Loss Warning ---
            let hasUnsavedChanges = false;
            
            // Track changes when objects are added
            const trackObjectChanges = () => {
                hasUnsavedChanges = true;
            };
            
            // Override objects.push to track changes
            const originalPush = objects.push;
            objects.push = function(...items) {
                trackObjectChanges();
                return originalPush.apply(this, items);
            };
            
            // Track deletions
            const originalDeleteObject = deleteObject;
            window.deleteObject = (obj) => {
                originalDeleteObject(obj);
                trackObjectChanges();
            };
            
            // Warn before page unload
            window.addEventListener('beforeunload', (e) => {
                if (hasUnsavedChanges && objects.length > 0) {
                    const message = 'You have unsaved work. Are you sure you want to leave? All canvas objects will be lost.';
                    e.preventDefault();
                    e.returnValue = message;
                    return message;
                }
            });

            // --- PWA Installation Prompt ---
            let deferredPrompt;
            
            window.addEventListener('beforeinstallprompt', (e) => {
                console.log('[PWA] Install prompt triggered');
                e.preventDefault();
                deferredPrompt = e;
                
                // Show install button or notification
                showInstallPrompt();
            });

            function showInstallPrompt() {
                // Create install notification
                const installNotification = document.createElement('div');
                installNotification.className = 'fixed top-4 right-4 z-50 bg-blue-600 text-white p-4 rounded-lg shadow-lg max-w-sm transition-all duration-300';
                installNotification.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                        </svg>
                        <div class="flex-1">
                            <h4 class="font-semibold">Install Gaze Tracker</h4>
                            <p class="text-sm opacity-90">Add to your home screen for quick access</p>
                        </div>
                        <button id="install-app-btn" class="bg-white text-blue-600 px-3 py-1 rounded font-medium text-sm hover:bg-gray-100 transition-colors">
                            Install
                        </button>
                        <button id="dismiss-install-btn" class="text-white hover:text-gray-200 transition-colors ml-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                `;
                
                document.body.appendChild(installNotification);
                
                // Handle install button click
                document.getElementById('install-app-btn').addEventListener('click', async () => {
                    if (deferredPrompt) {
                        deferredPrompt.prompt();
                        const { outcome } = await deferredPrompt.userChoice;
                        console.log('[PWA] User choice:', outcome);
                        deferredPrompt = null;
                        installNotification.remove();
                    }
                });
                
                // Handle dismiss button click
                document.getElementById('dismiss-install-btn').addEventListener('click', () => {
                    installNotification.remove();
                    deferredPrompt = null;
                });
                
                // Auto dismiss after 10 seconds
                setTimeout(() => {
                    if (installNotification.parentNode) {
                        installNotification.remove();
                    }
                }, 10000);
            }

            // --- Service Worker Registration ---
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', async () => {
                    try {
                        const registration = await navigator.serviceWorker.register('./sw.js');
                        console.log('[PWA] Service Worker registered successfully:', registration.scope);
                        
                        // Handle service worker updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    showUpdatePrompt(newWorker);
                                }
                            });
                        });
                    } catch (error) {
                        console.error('[PWA] Service Worker registration failed:', error);
                    }
                });
            }

            // About section is inline within the left drawer; no modal wiring required.

            function showUpdatePrompt(newWorker) {
                const updateNotification = document.createElement('div');
                updateNotification.className = 'fixed bottom-4 right-4 z-50 bg-green-600 text-white p-4 rounded-lg shadow-lg max-w-sm';
                updateNotification.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                        <div class="flex-1">
                            <h4 class="font-semibold">Update Available</h4>
                            <p class="text-sm opacity-90">A new version is ready</p>
                        </div>
                        <button id="update-app-btn" class="bg-white text-green-600 px-3 py-1 rounded font-medium text-sm hover:bg-gray-100">
                            Update
                        </button>
                    </div>
                `;
                
                document.body.appendChild(updateNotification);
                
                document.getElementById('update-app-btn').addEventListener('click', () => {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                    window.location.reload();
                });
            }
        });
    </script>
</body>
</html>
